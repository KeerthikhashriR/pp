<html>
<head>
<title>annotated_handlers.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
annotated_handlers.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Type annotations to use with `__get_pydantic_core_schema__` and `__get_pydantic_json_schema__`.&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations </span><span class="s2">as </span><span class="s1">_annotations</span>

<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Union</span>

<span class="s2">from </span><span class="s1">pydantic_core </span><span class="s2">import </span><span class="s1">core_schema</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_internal</span><span class="s3">.</span><span class="s1">_namespace_utils </span><span class="s2">import </span><span class="s1">NamespacesTuple</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">json_schema </span><span class="s2">import </span><span class="s1">JsonSchemaMode</span><span class="s3">, </span><span class="s1">JsonSchemaValue</span>

    <span class="s1">CoreSchemaOrField </span><span class="s3">= </span><span class="s1">Union</span><span class="s3">[</span>
        <span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">,</span>
        <span class="s1">core_schema</span><span class="s3">.</span><span class="s1">ModelField</span><span class="s3">,</span>
        <span class="s1">core_schema</span><span class="s3">.</span><span class="s1">DataclassField</span><span class="s3">,</span>
        <span class="s1">core_schema</span><span class="s3">.</span><span class="s1">TypedDictField</span><span class="s3">,</span>
        <span class="s1">core_schema</span><span class="s3">.</span><span class="s1">ComputedField</span><span class="s3">,</span>
    <span class="s3">]</span>

<span class="s1">__all__ </span><span class="s3">= </span><span class="s4">'GetJsonSchemaHandler'</span><span class="s3">, </span><span class="s4">'GetCoreSchemaHandler'</span>


<span class="s2">class </span><span class="s1">GetJsonSchemaHandler</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Handler to call into the next JSON schema generation function. 
 
    Attributes: 
        mode: Json schema mode, can be `validation` or `serialization`. 
    &quot;&quot;&quot;</span>

    <span class="s1">mode</span><span class="s3">: </span><span class="s1">JsonSchemaMode</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">core_schema</span><span class="s3">: </span><span class="s1">CoreSchemaOrField</span><span class="s3">, /) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Call the inner handler and get the JsonSchemaValue it returns. 
        This will call the next JSON schema modifying function up until it calls 
        into `pydantic.json_schema.GenerateJsonSchema`, which will raise a 
        `pydantic.errors.PydanticInvalidForJsonSchema` error if it cannot generate 
        a JSON schema. 
 
        Args: 
            core_schema: A `pydantic_core.core_schema.CoreSchema`. 
 
        Returns: 
            JsonSchemaValue: The JSON schema generated by the inner JSON schema modify 
            functions. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">resolve_ref_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">maybe_ref_json_schema</span><span class="s3">: </span><span class="s1">JsonSchemaValue</span><span class="s3">, /) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Get the real schema for a `{&quot;$ref&quot;: ...}` schema. 
        If the schema given is not a `$ref` schema, it will be returned as is. 
        This means you don't have to check before calling this function. 
 
        Args: 
            maybe_ref_json_schema: A JsonSchemaValue which may be a `$ref` schema. 
 
        Raises: 
            LookupError: If the ref is not found. 
 
        Returns: 
            JsonSchemaValue: A JsonSchemaValue that has no `$ref`. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>


<span class="s2">class </span><span class="s1">GetCoreSchemaHandler</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Handler to call into the next CoreSchema schema generation function.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">source_type</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, /) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Call the inner handler and get the CoreSchema it returns. 
        This will call the next CoreSchema modifying function up until it calls 
        into Pydantic's internal schema generation machinery, which will raise a 
        `pydantic.errors.PydanticSchemaGenerationError` error if it cannot generate 
        a CoreSchema for the given source type. 
 
        Args: 
            source_type: The input type. 
 
        Returns: 
            CoreSchema: The `pydantic-core` CoreSchema generated. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">source_type</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, /) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generate a schema unrelated to the current context. 
        Use this function if e.g. you are handling schema generation for a sequence 
        and want to generate a schema for its items. 
        Otherwise, you may end up doing something like applying a `min_length` constraint 
        that was intended for the sequence itself to its items! 
 
        Args: 
            source_type: The input type. 
 
        Returns: 
            CoreSchema: The `pydantic-core` CoreSchema generated. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">resolve_ref_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">maybe_ref_schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">, /) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Get the real schema for a `definition-ref` schema. 
        If the schema given is not a `definition-ref` schema, it will be returned as is. 
        This means you don't have to check before calling this function. 
 
        Args: 
            maybe_ref_schema: A `CoreSchema`, `ref`-based or not. 
 
        Raises: 
            LookupError: If the `ref` is not found. 
 
        Returns: 
            A concrete `CoreSchema`. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">field_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; str </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Get the name of the closest field to this validator.&quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">_get_types_namespace</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; NamespacesTuple</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Internal method used during type resolution for serializer annotations.&quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>
</pre>
</body>
</html>