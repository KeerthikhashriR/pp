<html>
<head>
<title>functional_serializers.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
functional_serializers.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;This module contains related classes and functions for serialization.&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">dataclasses</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span><span class="s3">, </span><span class="s1">partialmethod</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span><span class="s3">, </span><span class="s1">Annotated</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Callable</span><span class="s3">, </span><span class="s1">Literal</span><span class="s3">, </span><span class="s1">TypeVar</span><span class="s3">, </span><span class="s1">overload</span>

<span class="s2">from </span><span class="s1">pydantic_core </span><span class="s2">import </span><span class="s1">PydanticUndefined</span><span class="s3">, </span><span class="s1">core_schema</span>
<span class="s2">from </span><span class="s1">pydantic_core</span><span class="s3">.</span><span class="s1">core_schema </span><span class="s2">import </span><span class="s1">SerializationInfo</span><span class="s3">, </span><span class="s1">SerializerFunctionWrapHandler</span><span class="s3">, </span><span class="s1">WhenUsed</span>
<span class="s2">from </span><span class="s1">typing_extensions </span><span class="s2">import </span><span class="s1">TypeAlias</span>

<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">PydanticUndefinedAnnotation</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_internal </span><span class="s2">import </span><span class="s1">_decorators</span><span class="s3">, </span><span class="s1">_internal_dataclass</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">annotated_handlers </span><span class="s2">import </span><span class="s1">GetCoreSchemaHandler</span>


<span class="s3">@</span><span class="s1">dataclasses</span><span class="s3">.</span><span class="s1">dataclass</span><span class="s3">(**</span><span class="s1">_internal_dataclass</span><span class="s3">.</span><span class="s1">slots_true</span><span class="s3">, </span><span class="s1">frozen</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
<span class="s2">class </span><span class="s1">PlainSerializer</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Plain serializers use a function to modify the output of serialization. 
 
    This is particularly helpful when you want to customize the serialization for annotated types. 
    Consider an input of `list`, which will be serialized into a space-delimited string. 
 
    ```python 
    from typing import Annotated 
 
    from pydantic import BaseModel, PlainSerializer 
 
    CustomStr = Annotated[ 
        list, PlainSerializer(lambda x: ' '.join(x), return_type=str) 
    ] 
 
    class StudentModel(BaseModel): 
        courses: CustomStr 
 
    student = StudentModel(courses=['Math', 'Chemistry', 'English']) 
    print(student.model_dump()) 
    #&gt; {'courses': 'Math Chemistry English'} 
    ``` 
 
    Attributes: 
        func: The serializer function. 
        return_type: The return type for the function. If omitted it will be inferred from the type annotation. 
        when_used: Determines when this serializer should be used. Accepts a string with values `'always'`, 
            `'unless-none'`, `'json'`, and `'json-unless-none'`. Defaults to 'always'. 
    &quot;&quot;&quot;</span>

    <span class="s1">func</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">SerializerFunction</span>
    <span class="s1">return_type</span><span class="s3">: </span><span class="s1">Any </span><span class="s3">= </span><span class="s1">PydanticUndefined</span>
    <span class="s1">when_used</span><span class="s3">: </span><span class="s1">WhenUsed </span><span class="s3">= </span><span class="s4">'always'</span>

    <span class="s2">def </span><span class="s1">__get_pydantic_core_schema__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">source_type</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">: </span><span class="s1">GetCoreSchemaHandler</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Gets the Pydantic core schema. 
 
        Args: 
            source_type: The source type. 
            handler: The `GetCoreSchemaHandler` instance. 
 
        Returns: 
            The Pydantic core schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">schema </span><span class="s3">= </span><span class="s1">handler</span><span class="s3">(</span><span class="s1">source_type</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">return_type </span><span class="s2">is not </span><span class="s1">PydanticUndefined</span><span class="s3">:</span>
            <span class="s1">return_type </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">return_type</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s5"># Do not pass in globals as the function could be defined in a different module.</span>
                <span class="s5"># Instead, let `get_callable_return_type` infer the globals to use, but still pass</span>
                <span class="s5"># in locals that may contain a parent/rebuild namespace:</span>
                <span class="s1">return_type </span><span class="s3">= </span><span class="s1">_decorators</span><span class="s3">.</span><span class="s1">get_callable_return_type</span><span class="s3">(</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">func</span><span class="s3">,</span>
                    <span class="s1">localns</span><span class="s3">=</span><span class="s1">handler</span><span class="s3">.</span><span class="s1">_get_types_namespace</span><span class="s3">().</span><span class="s1">locals</span><span class="s3">,</span>
                <span class="s3">)</span>
            <span class="s2">except </span><span class="s1">NameError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">PydanticUndefinedAnnotation</span><span class="s3">.</span><span class="s1">from_name_error</span><span class="s3">(</span><span class="s1">e</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>

        <span class="s1">return_schema </span><span class="s3">= </span><span class="s2">None if </span><span class="s1">return_type </span><span class="s2">is </span><span class="s1">PydanticUndefined </span><span class="s2">else </span><span class="s1">handler</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">return_type</span><span class="s3">)</span>
        <span class="s1">schema</span><span class="s3">[</span><span class="s4">'serialization'</span><span class="s3">] = </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">plain_serializer_function_ser_schema</span><span class="s3">(</span>
            <span class="s1">function</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func</span><span class="s3">,</span>
            <span class="s1">info_arg</span><span class="s3">=</span><span class="s1">_decorators</span><span class="s3">.</span><span class="s1">inspect_annotated_serializer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func</span><span class="s3">, </span><span class="s4">'plain'</span><span class="s3">),</span>
            <span class="s1">return_schema</span><span class="s3">=</span><span class="s1">return_schema</span><span class="s3">,</span>
            <span class="s1">when_used</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">when_used</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">schema</span>


<span class="s3">@</span><span class="s1">dataclasses</span><span class="s3">.</span><span class="s1">dataclass</span><span class="s3">(**</span><span class="s1">_internal_dataclass</span><span class="s3">.</span><span class="s1">slots_true</span><span class="s3">, </span><span class="s1">frozen</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
<span class="s2">class </span><span class="s1">WrapSerializer</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Wrap serializers receive the raw inputs along with a handler function that applies the standard serialization 
    logic, and can modify the resulting value before returning it as the final output of serialization. 
 
    For example, here's a scenario in which a wrap serializer transforms timezones to UTC **and** utilizes the existing `datetime` serialization logic. 
 
    ```python 
    from datetime import datetime, timezone 
    from typing import Annotated, Any 
 
    from pydantic import BaseModel, WrapSerializer 
 
    class EventDatetime(BaseModel): 
        start: datetime 
        end: datetime 
 
    def convert_to_utc(value: Any, handler, info) -&gt; dict[str, datetime]: 
        # Note that `handler` can actually help serialize the `value` for 
        # further custom serialization in case it's a subclass. 
        partial_result = handler(value, info) 
        if info.mode == 'json': 
            return { 
                k: datetime.fromisoformat(v).astimezone(timezone.utc) 
                for k, v in partial_result.items() 
            } 
        return {k: v.astimezone(timezone.utc) for k, v in partial_result.items()} 
 
    UTCEventDatetime = Annotated[EventDatetime, WrapSerializer(convert_to_utc)] 
 
    class EventModel(BaseModel): 
        event_datetime: UTCEventDatetime 
 
    dt = EventDatetime( 
        start='2024-01-01T07:00:00-08:00', end='2024-01-03T20:00:00+06:00' 
    ) 
    event = EventModel(event_datetime=dt) 
    print(event.model_dump()) 
    ''' 
    { 
        'event_datetime': { 
            'start': datetime.datetime( 
                2024, 1, 1, 15, 0, tzinfo=datetime.timezone.utc 
            ), 
            'end': datetime.datetime( 
                2024, 1, 3, 14, 0, tzinfo=datetime.timezone.utc 
            ), 
        } 
    } 
    ''' 
 
    print(event.model_dump_json()) 
    ''' 
    {&quot;event_datetime&quot;:{&quot;start&quot;:&quot;2024-01-01T15:00:00Z&quot;,&quot;end&quot;:&quot;2024-01-03T14:00:00Z&quot;}} 
    ''' 
    ``` 
 
    Attributes: 
        func: The serializer function to be wrapped. 
        return_type: The return type for the function. If omitted it will be inferred from the type annotation. 
        when_used: Determines when this serializer should be used. Accepts a string with values `'always'`, 
            `'unless-none'`, `'json'`, and `'json-unless-none'`. Defaults to 'always'. 
    &quot;&quot;&quot;</span>

    <span class="s1">func</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">WrapSerializerFunction</span>
    <span class="s1">return_type</span><span class="s3">: </span><span class="s1">Any </span><span class="s3">= </span><span class="s1">PydanticUndefined</span>
    <span class="s1">when_used</span><span class="s3">: </span><span class="s1">WhenUsed </span><span class="s3">= </span><span class="s4">'always'</span>

    <span class="s2">def </span><span class="s1">__get_pydantic_core_schema__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">source_type</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">: </span><span class="s1">GetCoreSchemaHandler</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;This method is used to get the Pydantic core schema of the class. 
 
        Args: 
            source_type: Source type. 
            handler: Core schema handler. 
 
        Returns: 
            The generated core schema of the class. 
        &quot;&quot;&quot;</span>
        <span class="s1">schema </span><span class="s3">= </span><span class="s1">handler</span><span class="s3">(</span><span class="s1">source_type</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">return_type </span><span class="s2">is not </span><span class="s1">PydanticUndefined</span><span class="s3">:</span>
            <span class="s1">return_type </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">return_type</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s5"># Do not pass in globals as the function could be defined in a different module.</span>
                <span class="s5"># Instead, let `get_callable_return_type` infer the globals to use, but still pass</span>
                <span class="s5"># in locals that may contain a parent/rebuild namespace:</span>
                <span class="s1">return_type </span><span class="s3">= </span><span class="s1">_decorators</span><span class="s3">.</span><span class="s1">get_callable_return_type</span><span class="s3">(</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">func</span><span class="s3">,</span>
                    <span class="s1">localns</span><span class="s3">=</span><span class="s1">handler</span><span class="s3">.</span><span class="s1">_get_types_namespace</span><span class="s3">().</span><span class="s1">locals</span><span class="s3">,</span>
                <span class="s3">)</span>
            <span class="s2">except </span><span class="s1">NameError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">PydanticUndefinedAnnotation</span><span class="s3">.</span><span class="s1">from_name_error</span><span class="s3">(</span><span class="s1">e</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>

        <span class="s1">return_schema </span><span class="s3">= </span><span class="s2">None if </span><span class="s1">return_type </span><span class="s2">is </span><span class="s1">PydanticUndefined </span><span class="s2">else </span><span class="s1">handler</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">return_type</span><span class="s3">)</span>
        <span class="s1">schema</span><span class="s3">[</span><span class="s4">'serialization'</span><span class="s3">] = </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">wrap_serializer_function_ser_schema</span><span class="s3">(</span>
            <span class="s1">function</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func</span><span class="s3">,</span>
            <span class="s1">info_arg</span><span class="s3">=</span><span class="s1">_decorators</span><span class="s3">.</span><span class="s1">inspect_annotated_serializer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func</span><span class="s3">, </span><span class="s4">'wrap'</span><span class="s3">),</span>
            <span class="s1">return_schema</span><span class="s3">=</span><span class="s1">return_schema</span><span class="s3">,</span>
            <span class="s1">when_used</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">when_used</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">schema</span>


<span class="s2">if </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s1">_Partial</span><span class="s3">: </span><span class="s1">TypeAlias </span><span class="s3">= </span><span class="s4">'partial[Any] | partialmethod[Any]'</span>

    <span class="s1">FieldPlainSerializer</span><span class="s3">: </span><span class="s1">TypeAlias </span><span class="s3">= </span><span class="s4">'core_schema.SerializerFunction | _Partial'</span>
    <span class="s4">&quot;&quot;&quot;A field serializer method or function in `plain` mode.&quot;&quot;&quot;</span>

    <span class="s1">FieldWrapSerializer</span><span class="s3">: </span><span class="s1">TypeAlias </span><span class="s3">= </span><span class="s4">'core_schema.WrapSerializerFunction | _Partial'</span>
    <span class="s4">&quot;&quot;&quot;A field serializer method or function in `wrap` mode.&quot;&quot;&quot;</span>

    <span class="s1">FieldSerializer</span><span class="s3">: </span><span class="s1">TypeAlias </span><span class="s3">= </span><span class="s4">'FieldPlainSerializer | FieldWrapSerializer'</span>
    <span class="s4">&quot;&quot;&quot;A field serializer method or function.&quot;&quot;&quot;</span>

    <span class="s1">_FieldPlainSerializerT </span><span class="s3">= </span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s4">'_FieldPlainSerializerT'</span><span class="s3">, </span><span class="s1">bound</span><span class="s3">=</span><span class="s1">FieldPlainSerializer</span><span class="s3">)</span>
    <span class="s1">_FieldWrapSerializerT </span><span class="s3">= </span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s4">'_FieldWrapSerializerT'</span><span class="s3">, </span><span class="s1">bound</span><span class="s3">=</span><span class="s1">FieldWrapSerializer</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span>
<span class="s2">def </span><span class="s1">field_serializer</span><span class="s3">(</span>
    <span class="s1">field</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
    <span class="s3">/,</span>
    <span class="s3">*</span><span class="s1">fields</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
    <span class="s1">mode</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">'wrap'</span><span class="s3">],</span>
    <span class="s1">return_type</span><span class="s3">: </span><span class="s1">Any </span><span class="s3">= ...,</span>
    <span class="s1">when_used</span><span class="s3">: </span><span class="s1">WhenUsed </span><span class="s3">= ...,</span>
    <span class="s1">check_fields</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
<span class="s3">) </span><span class="s1">-&gt; Callable</span><span class="s3">[[</span><span class="s1">_FieldWrapSerializerT</span><span class="s3">], </span><span class="s1">_FieldWrapSerializerT</span><span class="s3">]: ...</span>


<span class="s3">@</span><span class="s1">overload</span>
<span class="s2">def </span><span class="s1">field_serializer</span><span class="s3">(</span>
    <span class="s1">field</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
    <span class="s3">/,</span>
    <span class="s3">*</span><span class="s1">fields</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
    <span class="s1">mode</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">'plain'</span><span class="s3">] = ...,</span>
    <span class="s1">return_type</span><span class="s3">: </span><span class="s1">Any </span><span class="s3">= ...,</span>
    <span class="s1">when_used</span><span class="s3">: </span><span class="s1">WhenUsed </span><span class="s3">= ...,</span>
    <span class="s1">check_fields</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
<span class="s3">) </span><span class="s1">-&gt; Callable</span><span class="s3">[[</span><span class="s1">_FieldPlainSerializerT</span><span class="s3">], </span><span class="s1">_FieldPlainSerializerT</span><span class="s3">]: ...</span>


<span class="s2">def </span><span class="s1">field_serializer</span><span class="s3">(</span>
    <span class="s3">*</span><span class="s1">fields</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
    <span class="s1">mode</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">'plain'</span><span class="s3">, </span><span class="s4">'wrap'</span><span class="s3">] = </span><span class="s4">'plain'</span><span class="s3">,</span>
    <span class="s1">return_type</span><span class="s3">: </span><span class="s1">Any </span><span class="s3">= </span><span class="s1">PydanticUndefined</span><span class="s3">,</span>
    <span class="s1">when_used</span><span class="s3">: </span><span class="s1">WhenUsed </span><span class="s3">= </span><span class="s4">'always'</span><span class="s3">,</span>
    <span class="s1">check_fields</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; </span><span class="s3">(</span>
    <span class="s1">Callable</span><span class="s3">[[</span><span class="s1">_FieldWrapSerializerT</span><span class="s3">], </span><span class="s1">_FieldWrapSerializerT</span><span class="s3">]</span>
    <span class="s3">| </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">_FieldPlainSerializerT</span><span class="s3">], </span><span class="s1">_FieldPlainSerializerT</span><span class="s3">]</span>
<span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Decorator that enables custom field serialization. 
 
    In the below example, a field of type `set` is used to mitigate duplication. A `field_serializer` is used to serialize the data as a sorted list. 
 
    ```python 
    from typing import Set 
 
    from pydantic import BaseModel, field_serializer 
 
    class StudentModel(BaseModel): 
        name: str = 'Jane' 
        courses: Set[str] 
 
        @field_serializer('courses', when_used='json') 
        def serialize_courses_in_order(self, courses: Set[str]): 
            return sorted(courses) 
 
    student = StudentModel(courses={'Math', 'Chemistry', 'English'}) 
    print(student.model_dump_json()) 
    #&gt; {&quot;name&quot;:&quot;Jane&quot;,&quot;courses&quot;:[&quot;Chemistry&quot;,&quot;English&quot;,&quot;Math&quot;]} 
    ``` 
 
    See [Custom serializers](../concepts/serialization.md#custom-serializers) for more information. 
 
    Four signatures are supported: 
 
    - `(self, value: Any, info: FieldSerializationInfo)` 
    - `(self, value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo)` 
    - `(value: Any, info: SerializationInfo)` 
    - `(value: Any, nxt: SerializerFunctionWrapHandler, info: SerializationInfo)` 
 
    Args: 
        fields: Which field(s) the method should be called on. 
        mode: The serialization mode. 
 
            - `plain` means the function will be called instead of the default serialization logic, 
            - `wrap` means the function will be called with an argument to optionally call the 
               default serialization logic. 
        return_type: Optional return type for the function, if omitted it will be inferred from the type annotation. 
        when_used: Determines the serializer will be used for serialization. 
        check_fields: Whether to check that the fields actually exist on the model. 
 
    Returns: 
        The decorator function. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">dec</span><span class="s3">(</span><span class="s1">f</span><span class="s3">: </span><span class="s1">FieldSerializer</span><span class="s3">) </span><span class="s1">-&gt; _decorators</span><span class="s3">.</span><span class="s1">PydanticDescriptorProxy</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]:</span>
        <span class="s1">dec_info </span><span class="s3">= </span><span class="s1">_decorators</span><span class="s3">.</span><span class="s1">FieldSerializerDecoratorInfo</span><span class="s3">(</span>
            <span class="s1">fields</span><span class="s3">=</span><span class="s1">fields</span><span class="s3">,</span>
            <span class="s1">mode</span><span class="s3">=</span><span class="s1">mode</span><span class="s3">,</span>
            <span class="s1">return_type</span><span class="s3">=</span><span class="s1">return_type</span><span class="s3">,</span>
            <span class="s1">when_used</span><span class="s3">=</span><span class="s1">when_used</span><span class="s3">,</span>
            <span class="s1">check_fields</span><span class="s3">=</span><span class="s1">check_fields</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">_decorators</span><span class="s3">.</span><span class="s1">PydanticDescriptorProxy</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">dec_info</span><span class="s3">)  </span><span class="s5"># pyright: ignore[reportArgumentType]</span>

    <span class="s2">return </span><span class="s1">dec  </span><span class="s5"># pyright: ignore[reportReturnType]</span>


<span class="s2">if </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s5"># The first argument in the following callables represent the `self` type:</span>

    <span class="s1">ModelPlainSerializerWithInfo</span><span class="s3">: </span><span class="s1">TypeAlias </span><span class="s3">= </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">SerializationInfo</span><span class="s3">], </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s4">&quot;&quot;&quot;A model serializer method with the `info` argument, in `plain` mode.&quot;&quot;&quot;</span>

    <span class="s1">ModelPlainSerializerWithoutInfo</span><span class="s3">: </span><span class="s1">TypeAlias </span><span class="s3">= </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Any</span><span class="s3">], </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s4">&quot;&quot;&quot;A model serializer method without the `info` argument, in `plain` mode.&quot;&quot;&quot;</span>

    <span class="s1">ModelPlainSerializer</span><span class="s3">: </span><span class="s1">TypeAlias </span><span class="s3">= </span><span class="s4">'ModelPlainSerializerWithInfo | ModelPlainSerializerWithoutInfo'</span>
    <span class="s4">&quot;&quot;&quot;A model serializer method in `plain` mode.&quot;&quot;&quot;</span>

    <span class="s1">ModelWrapSerializerWithInfo</span><span class="s3">: </span><span class="s1">TypeAlias </span><span class="s3">= </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">SerializerFunctionWrapHandler</span><span class="s3">, </span><span class="s1">SerializationInfo</span><span class="s3">], </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s4">&quot;&quot;&quot;A model serializer method with the `info` argument, in `wrap` mode.&quot;&quot;&quot;</span>

    <span class="s1">ModelWrapSerializerWithoutInfo</span><span class="s3">: </span><span class="s1">TypeAlias </span><span class="s3">= </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">SerializerFunctionWrapHandler</span><span class="s3">], </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s4">&quot;&quot;&quot;A model serializer method without the `info` argument, in `wrap` mode.&quot;&quot;&quot;</span>

    <span class="s1">ModelWrapSerializer</span><span class="s3">: </span><span class="s1">TypeAlias </span><span class="s3">= </span><span class="s4">'ModelWrapSerializerWithInfo | ModelWrapSerializerWithoutInfo'</span>
    <span class="s4">&quot;&quot;&quot;A model serializer method in `wrap` mode.&quot;&quot;&quot;</span>

    <span class="s1">ModelSerializer</span><span class="s3">: </span><span class="s1">TypeAlias </span><span class="s3">= </span><span class="s4">'ModelPlainSerializer | ModelWrapSerializer'</span>

    <span class="s1">_ModelPlainSerializerT </span><span class="s3">= </span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s4">'_ModelPlainSerializerT'</span><span class="s3">, </span><span class="s1">bound</span><span class="s3">=</span><span class="s1">ModelPlainSerializer</span><span class="s3">)</span>
    <span class="s1">_ModelWrapSerializerT </span><span class="s3">= </span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s4">'_ModelWrapSerializerT'</span><span class="s3">, </span><span class="s1">bound</span><span class="s3">=</span><span class="s1">ModelWrapSerializer</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span>
<span class="s2">def </span><span class="s1">model_serializer</span><span class="s3">(</span><span class="s1">f</span><span class="s3">: </span><span class="s1">_ModelPlainSerializerT</span><span class="s3">, /) </span><span class="s1">-&gt; _ModelPlainSerializerT</span><span class="s3">: ...</span>


<span class="s3">@</span><span class="s1">overload</span>
<span class="s2">def </span><span class="s1">model_serializer</span><span class="s3">(</span>
    <span class="s3">*, </span><span class="s1">mode</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">'wrap'</span><span class="s3">], </span><span class="s1">when_used</span><span class="s3">: </span><span class="s1">WhenUsed </span><span class="s3">= </span><span class="s4">'always'</span><span class="s3">, </span><span class="s1">return_type</span><span class="s3">: </span><span class="s1">Any </span><span class="s3">= ...</span>
<span class="s3">) </span><span class="s1">-&gt; Callable</span><span class="s3">[[</span><span class="s1">_ModelWrapSerializerT</span><span class="s3">], </span><span class="s1">_ModelWrapSerializerT</span><span class="s3">]: ...</span>


<span class="s3">@</span><span class="s1">overload</span>
<span class="s2">def </span><span class="s1">model_serializer</span><span class="s3">(</span>
    <span class="s3">*,</span>
    <span class="s1">mode</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">'plain'</span><span class="s3">] = ...,</span>
    <span class="s1">when_used</span><span class="s3">: </span><span class="s1">WhenUsed </span><span class="s3">= </span><span class="s4">'always'</span><span class="s3">,</span>
    <span class="s1">return_type</span><span class="s3">: </span><span class="s1">Any </span><span class="s3">= ...,</span>
<span class="s3">) </span><span class="s1">-&gt; Callable</span><span class="s3">[[</span><span class="s1">_ModelPlainSerializerT</span><span class="s3">], </span><span class="s1">_ModelPlainSerializerT</span><span class="s3">]: ...</span>


<span class="s2">def </span><span class="s1">model_serializer</span><span class="s3">(</span>
    <span class="s1">f</span><span class="s3">: </span><span class="s1">_ModelPlainSerializerT </span><span class="s3">| </span><span class="s1">_ModelWrapSerializerT </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">/,</span>
    <span class="s3">*,</span>
    <span class="s1">mode</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">'plain'</span><span class="s3">, </span><span class="s4">'wrap'</span><span class="s3">] = </span><span class="s4">'plain'</span><span class="s3">,</span>
    <span class="s1">when_used</span><span class="s3">: </span><span class="s1">WhenUsed </span><span class="s3">= </span><span class="s4">'always'</span><span class="s3">,</span>
    <span class="s1">return_type</span><span class="s3">: </span><span class="s1">Any </span><span class="s3">= </span><span class="s1">PydanticUndefined</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; </span><span class="s3">(</span>
    <span class="s1">_ModelPlainSerializerT</span>
    <span class="s3">| </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">_ModelWrapSerializerT</span><span class="s3">], </span><span class="s1">_ModelWrapSerializerT</span><span class="s3">]</span>
    <span class="s3">| </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">_ModelPlainSerializerT</span><span class="s3">], </span><span class="s1">_ModelPlainSerializerT</span><span class="s3">]</span>
<span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Decorator that enables custom model serialization. 
 
    This is useful when a model need to be serialized in a customized manner, allowing for flexibility beyond just specific fields. 
 
    An example would be to serialize temperature to the same temperature scale, such as degrees Celsius. 
 
    ```python 
    from typing import Literal 
 
    from pydantic import BaseModel, model_serializer 
 
    class TemperatureModel(BaseModel): 
        unit: Literal['C', 'F'] 
        value: int 
 
        @model_serializer() 
        def serialize_model(self): 
            if self.unit == 'F': 
                return {'unit': 'C', 'value': int((self.value - 32) / 1.8)} 
            return {'unit': self.unit, 'value': self.value} 
 
    temperature = TemperatureModel(unit='F', value=212) 
    print(temperature.model_dump()) 
    #&gt; {'unit': 'C', 'value': 100} 
    ``` 
 
    Two signatures are supported for `mode='plain'`, which is the default: 
 
    - `(self)` 
    - `(self, info: SerializationInfo)` 
 
    And two other signatures for `mode='wrap'`: 
 
    - `(self, nxt: SerializerFunctionWrapHandler)` 
    - `(self, nxt: SerializerFunctionWrapHandler, info: SerializationInfo)` 
 
        See [Custom serializers](../concepts/serialization.md#custom-serializers) for more information. 
 
    Args: 
        f: The function to be decorated. 
        mode: The serialization mode. 
 
            - `'plain'` means the function will be called instead of the default serialization logic 
            - `'wrap'` means the function will be called with an argument to optionally call the default 
                serialization logic. 
        when_used: Determines when this serializer should be used. 
        return_type: The return type for the function. If omitted it will be inferred from the type annotation. 
 
    Returns: 
        The decorator function. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">dec</span><span class="s3">(</span><span class="s1">f</span><span class="s3">: </span><span class="s1">ModelSerializer</span><span class="s3">) </span><span class="s1">-&gt; _decorators</span><span class="s3">.</span><span class="s1">PydanticDescriptorProxy</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]:</span>
        <span class="s1">dec_info </span><span class="s3">= </span><span class="s1">_decorators</span><span class="s3">.</span><span class="s1">ModelSerializerDecoratorInfo</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">=</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">return_type</span><span class="s3">=</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">when_used</span><span class="s3">=</span><span class="s1">when_used</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">_decorators</span><span class="s3">.</span><span class="s1">PydanticDescriptorProxy</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">dec_info</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">f </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">dec  </span><span class="s5"># pyright: ignore[reportReturnType]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">dec</span><span class="s3">(</span><span class="s1">f</span><span class="s3">)  </span><span class="s5"># pyright: ignore[reportReturnType]</span>


<span class="s1">AnyType </span><span class="s3">= </span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s4">'AnyType'</span><span class="s3">)</span>


<span class="s2">if </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s1">SerializeAsAny </span><span class="s3">= </span><span class="s1">Annotated</span><span class="s3">[</span><span class="s1">AnyType</span><span class="s3">, ...]  </span><span class="s5"># SerializeAsAny[list[str]] will be treated by type checkers as list[str]</span>
    <span class="s4">&quot;&quot;&quot;Force serialization to ignore whatever is defined in the schema and instead ask the object 
    itself how it should be serialized. 
    In particular, this means that when model subclasses are serialized, fields present in the subclass 
    but not in the original schema will be included. 
    &quot;&quot;&quot;</span>
<span class="s2">else</span><span class="s3">:</span>

    <span class="s3">@</span><span class="s1">dataclasses</span><span class="s3">.</span><span class="s1">dataclass</span><span class="s3">(**</span><span class="s1">_internal_dataclass</span><span class="s3">.</span><span class="s1">slots_true</span><span class="s3">)</span>
    <span class="s2">class </span><span class="s1">SerializeAsAny</span><span class="s3">:  </span><span class="s5"># noqa: D101</span>
        <span class="s2">def </span><span class="s1">__class_getitem__</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">item</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">Annotated</span><span class="s3">[</span><span class="s1">item</span><span class="s3">, </span><span class="s1">SerializeAsAny</span><span class="s3">()]</span>

        <span class="s2">def </span><span class="s1">__get_pydantic_core_schema__</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">, </span><span class="s1">source_type</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">: </span><span class="s1">GetCoreSchemaHandler</span>
        <span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
            <span class="s1">schema </span><span class="s3">= </span><span class="s1">handler</span><span class="s3">(</span><span class="s1">source_type</span><span class="s3">)</span>
            <span class="s1">schema_to_update </span><span class="s3">= </span><span class="s1">schema</span>
            <span class="s2">while </span><span class="s1">schema_to_update</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">] == </span><span class="s4">'definitions'</span><span class="s3">:</span>
                <span class="s1">schema_to_update </span><span class="s3">= </span><span class="s1">schema_to_update</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
                <span class="s1">schema_to_update </span><span class="s3">= </span><span class="s1">schema_to_update</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">]</span>
            <span class="s1">schema_to_update</span><span class="s3">[</span><span class="s4">'serialization'</span><span class="s3">] = </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">wrap_serializer_function_ser_schema</span><span class="s3">(</span>
                <span class="s2">lambda </span><span class="s1">x</span><span class="s3">, </span><span class="s1">h</span><span class="s3">: </span><span class="s1">h</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">schema</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">any_schema</span><span class="s3">()</span>
            <span class="s3">)</span>
            <span class="s2">return </span><span class="s1">schema</span>

        <span class="s1">__hash__ </span><span class="s3">= </span><span class="s1">object</span><span class="s3">.</span><span class="s1">__hash__</span>
</pre>
</body>
</html>