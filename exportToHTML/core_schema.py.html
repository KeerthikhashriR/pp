<html>
<head>
<title>core_schema.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #7a7e85;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
core_schema.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
This module contains definitions to build schemas which `pydantic_core` can 
validate and serialize. 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations </span><span class="s2">as </span><span class="s1">_annotations</span>

<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc </span><span class="s2">import </span><span class="s1">Hashable</span><span class="s3">, </span><span class="s1">Mapping</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">date</span><span class="s3">, </span><span class="s1">datetime</span><span class="s3">, </span><span class="s1">time</span><span class="s3">, </span><span class="s1">timedelta</span>
<span class="s2">from </span><span class="s1">decimal </span><span class="s2">import </span><span class="s1">Decimal</span>
<span class="s2">from </span><span class="s1">re </span><span class="s2">import </span><span class="s1">Pattern</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Callable</span><span class="s3">, </span><span class="s1">Literal</span><span class="s3">, </span><span class="s1">Union</span>

<span class="s2">from </span><span class="s1">typing_extensions </span><span class="s2">import </span><span class="s1">deprecated</span>

<span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&lt; (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">12</span><span class="s3">):</span>
    <span class="s2">from </span><span class="s1">typing_extensions </span><span class="s2">import </span><span class="s1">TypedDict</span>
<span class="s2">else</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TypedDict</span>

<span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&lt; (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">11</span><span class="s3">):</span>
    <span class="s2">from </span><span class="s1">typing_extensions </span><span class="s2">import </span><span class="s1">Protocol</span><span class="s3">, </span><span class="s1">Required</span><span class="s3">, </span><span class="s1">TypeAlias</span>
<span class="s2">else</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Protocol</span><span class="s3">, </span><span class="s1">Required</span><span class="s3">, </span><span class="s1">TypeAlias</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s1">pydantic_core </span><span class="s2">import </span><span class="s1">PydanticUndefined</span>
<span class="s2">else</span><span class="s3">:</span>
    <span class="s5"># The initial build of pydantic_core requires PydanticUndefined to generate</span>
    <span class="s5"># the core schema; so we need to conditionally skip it. mypy doesn't like</span>
    <span class="s5"># this at all, hence the TYPE_CHECKING branch above.</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">from </span><span class="s1">pydantic_core </span><span class="s2">import </span><span class="s1">PydanticUndefined</span>
    <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
        <span class="s1">PydanticUndefined </span><span class="s3">= </span><span class="s1">object</span><span class="s3">()</span>


<span class="s1">ExtraBehavior </span><span class="s3">= </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'allow'</span><span class="s3">, </span><span class="s6">'forbid'</span><span class="s3">, </span><span class="s6">'ignore'</span><span class="s3">]</span>


<span class="s2">class </span><span class="s1">CoreConfig</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Base class for schema configuration options. 
 
    Attributes: 
        title: The name of the configuration. 
        strict: Whether the configuration should strictly adhere to specified rules. 
        extra_fields_behavior: The behavior for handling extra fields. 
        typed_dict_total: Whether the TypedDict should be considered total. Default is `True`. 
        from_attributes: Whether to use attributes for models, dataclasses, and tagged union keys. 
        loc_by_alias: Whether to use the used alias (or first alias for &quot;field required&quot; errors) instead of 
            `field_names` to construct error `loc`s. Default is `True`. 
        revalidate_instances: Whether instances of models and dataclasses should re-validate. Default is 'never'. 
        validate_default: Whether to validate default values during validation. Default is `False`. 
        str_max_length: The maximum length for string fields. 
        str_min_length: The minimum length for string fields. 
        str_strip_whitespace: Whether to strip whitespace from string fields. 
        str_to_lower: Whether to convert string fields to lowercase. 
        str_to_upper: Whether to convert string fields to uppercase. 
        allow_inf_nan: Whether to allow infinity and NaN values for float fields. Default is `True`. 
        ser_json_timedelta: The serialization option for `timedelta` values. Default is 'iso8601'. 
        ser_json_bytes: The serialization option for `bytes` values. Default is 'utf8'. 
        ser_json_inf_nan: The serialization option for infinity and NaN values 
            in float fields. Default is 'null'. 
        val_json_bytes: The validation option for `bytes` values, complementing ser_json_bytes. Default is 'utf8'. 
        hide_input_in_errors: Whether to hide input data from `ValidationError` representation. 
        validation_error_cause: Whether to add user-python excs to the __cause__ of a ValidationError. 
            Requires exceptiongroup backport pre Python 3.11. 
        coerce_numbers_to_str: Whether to enable coercion of any `Number` type to `str` (not applicable in `strict` mode). 
        regex_engine: The regex engine to use for regex pattern validation. Default is 'rust-regex'. See `StringSchema`. 
        cache_strings: Whether to cache strings. Default is `True`, `True` or `'all'` is required to cache strings 
            during general validation since validators don't know if they're in a key or a value. 
        validate_by_alias: Whether to use the field's alias when validating against the provided input data. Default is `True`. 
        validate_by_name: Whether to use the field's name when validating against the provided input data. Default is `False`. Replacement for `populate_by_name`. 
        serialize_by_alias: Whether to serialize by alias. Default is `False`, expected to change to `True` in V3. 
    &quot;&quot;&quot;</span>

    <span class="s1">title</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s5"># settings related to typed dicts, model fields, dataclass fields</span>
    <span class="s1">extra_fields_behavior</span><span class="s3">: </span><span class="s1">ExtraBehavior</span>
    <span class="s1">typed_dict_total</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default: True</span>
    <span class="s5"># used for models, dataclasses, and tagged union keys</span>
    <span class="s1">from_attributes</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s5"># whether to use the used alias (or first alias for &quot;field required&quot; errors) instead of field_names</span>
    <span class="s5"># to construct error `loc`s, default True</span>
    <span class="s1">loc_by_alias</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s5"># whether instances of models and dataclasses (including subclass instances) should re-validate, default 'never'</span>
    <span class="s1">revalidate_instances</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'always'</span><span class="s3">, </span><span class="s6">'never'</span><span class="s3">, </span><span class="s6">'subclass-instances'</span><span class="s3">]</span>
    <span class="s5"># whether to validate default values during validation, default False</span>
    <span class="s1">validate_default</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s5"># used on typed-dicts and arguments</span>
    <span class="s5"># fields related to string fields only</span>
    <span class="s1">str_max_length</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">str_min_length</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">str_strip_whitespace</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">str_to_lower</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">str_to_upper</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s5"># fields related to float fields only</span>
    <span class="s1">allow_inf_nan</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default: True</span>
    <span class="s5"># the config options are used to customise serialization to JSON</span>
    <span class="s1">ser_json_timedelta</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'iso8601'</span><span class="s3">, </span><span class="s6">'float'</span><span class="s3">]  </span><span class="s5"># default: 'iso8601'</span>
    <span class="s1">ser_json_bytes</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'utf8'</span><span class="s3">, </span><span class="s6">'base64'</span><span class="s3">, </span><span class="s6">'hex'</span><span class="s3">]  </span><span class="s5"># default: 'utf8'</span>
    <span class="s1">ser_json_inf_nan</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'null'</span><span class="s3">, </span><span class="s6">'constants'</span><span class="s3">, </span><span class="s6">'strings'</span><span class="s3">]  </span><span class="s5"># default: 'null'</span>
    <span class="s1">val_json_bytes</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'utf8'</span><span class="s3">, </span><span class="s6">'base64'</span><span class="s3">, </span><span class="s6">'hex'</span><span class="s3">]  </span><span class="s5"># default: 'utf8'</span>
    <span class="s5"># used to hide input data from ValidationError repr</span>
    <span class="s1">hide_input_in_errors</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">validation_error_cause</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default: False</span>
    <span class="s1">coerce_numbers_to_str</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default: False</span>
    <span class="s1">regex_engine</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'rust-regex'</span><span class="s3">, </span><span class="s6">'python-re'</span><span class="s3">]  </span><span class="s5"># default: 'rust-regex'</span>
    <span class="s1">cache_strings</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">bool</span><span class="s3">, </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'all'</span><span class="s3">, </span><span class="s6">'keys'</span><span class="s3">, </span><span class="s6">'none'</span><span class="s3">]]  </span><span class="s5"># default: 'True'</span>
    <span class="s1">validate_by_alias</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default: True</span>
    <span class="s1">validate_by_name</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default: False</span>
    <span class="s1">serialize_by_alias</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default: False</span>


<span class="s1">IncExCall</span><span class="s3">: </span><span class="s1">TypeAlias </span><span class="s3">= </span><span class="s6">'set[int | str] | dict[int | str, IncExCall] | None'</span>


<span class="s2">class </span><span class="s1">SerializationInfo</span><span class="s3">(</span><span class="s1">Protocol</span><span class="s3">):</span>
    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">include</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; IncExCall</span><span class="s3">: ...</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">exclude</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; IncExCall</span><span class="s3">: ...</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">context</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Any </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Current serialization context.&quot;&quot;&quot;</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">mode</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">: ...</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">by_alias</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">: ...</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">exclude_unset</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">: ...</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">exclude_defaults</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">: ...</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">exclude_none</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">: ...</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">serialize_as_any</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">: ...</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">round_trip</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">: ...</span>

    <span class="s2">def </span><span class="s1">mode_is_json</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">: ...</span>

    <span class="s2">def </span><span class="s1">__str__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">: ...</span>

    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">: ...</span>


<span class="s2">class </span><span class="s1">FieldSerializationInfo</span><span class="s3">(</span><span class="s1">SerializationInfo</span><span class="s3">, </span><span class="s1">Protocol</span><span class="s3">):</span>
    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">field_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">: ...</span>


<span class="s2">class </span><span class="s1">ValidationInfo</span><span class="s3">(</span><span class="s1">Protocol</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Argument passed to validation functions. 
    &quot;&quot;&quot;</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">context</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Any </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Current validation context.&quot;&quot;&quot;</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">config</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; CoreConfig </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;The CoreConfig that applies to this validation.&quot;&quot;&quot;</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">mode</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Literal</span><span class="s3">[</span><span class="s6">'python'</span><span class="s3">, </span><span class="s6">'json'</span><span class="s3">]:</span>
        <span class="s0">&quot;&quot;&quot;The type of input data we are currently validating&quot;&quot;&quot;</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">data</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]:</span>
        <span class="s0">&quot;&quot;&quot;The data being validated for this model.&quot;&quot;&quot;</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">field_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; str </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        The name of the current field being validated if this validator is 
        attached to a model field. 
        &quot;&quot;&quot;</span>
        <span class="s3">...</span>


<span class="s1">ExpectedSerializationTypes </span><span class="s3">= </span><span class="s1">Literal</span><span class="s3">[</span>
    <span class="s6">'none'</span><span class="s3">,</span>
    <span class="s6">'int'</span><span class="s3">,</span>
    <span class="s6">'bool'</span><span class="s3">,</span>
    <span class="s6">'float'</span><span class="s3">,</span>
    <span class="s6">'str'</span><span class="s3">,</span>
    <span class="s6">'bytes'</span><span class="s3">,</span>
    <span class="s6">'bytearray'</span><span class="s3">,</span>
    <span class="s6">'list'</span><span class="s3">,</span>
    <span class="s6">'tuple'</span><span class="s3">,</span>
    <span class="s6">'set'</span><span class="s3">,</span>
    <span class="s6">'frozenset'</span><span class="s3">,</span>
    <span class="s6">'generator'</span><span class="s3">,</span>
    <span class="s6">'dict'</span><span class="s3">,</span>
    <span class="s6">'datetime'</span><span class="s3">,</span>
    <span class="s6">'date'</span><span class="s3">,</span>
    <span class="s6">'time'</span><span class="s3">,</span>
    <span class="s6">'timedelta'</span><span class="s3">,</span>
    <span class="s6">'url'</span><span class="s3">,</span>
    <span class="s6">'multi-host-url'</span><span class="s3">,</span>
    <span class="s6">'json'</span><span class="s3">,</span>
    <span class="s6">'uuid'</span><span class="s3">,</span>
    <span class="s6">'any'</span><span class="s3">,</span>
<span class="s3">]</span>


<span class="s2">class </span><span class="s1">SimpleSerSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">ExpectedSerializationTypes</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">simple_ser_schema</span><span class="s3">(</span><span class="s1">type</span><span class="s3">: </span><span class="s1">ExpectedSerializationTypes</span><span class="s3">) </span><span class="s1">-&gt; SimpleSerSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema for serialization with a custom type. 
 
    Args: 
        type: The type to use for serialization 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">SimpleSerSchema</span><span class="s3">(</span><span class="s1">type</span><span class="s3">=</span><span class="s1">type</span><span class="s3">)</span>


<span class="s5"># (input_value: Any, /) -&gt; Any</span>
<span class="s1">GeneralPlainNoInfoSerializerFunction </span><span class="s3">= </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Any</span><span class="s3">], </span><span class="s1">Any</span><span class="s3">]</span>
<span class="s5"># (input_value: Any, info: FieldSerializationInfo, /) -&gt; Any</span>
<span class="s1">GeneralPlainInfoSerializerFunction </span><span class="s3">= </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">SerializationInfo</span><span class="s3">], </span><span class="s1">Any</span><span class="s3">]</span>
<span class="s5"># (model: Any, input_value: Any, /) -&gt; Any</span>
<span class="s1">FieldPlainNoInfoSerializerFunction </span><span class="s3">= </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">], </span><span class="s1">Any</span><span class="s3">]</span>
<span class="s5"># (model: Any, input_value: Any, info: FieldSerializationInfo, /) -&gt; Any</span>
<span class="s1">FieldPlainInfoSerializerFunction </span><span class="s3">= </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">FieldSerializationInfo</span><span class="s3">], </span><span class="s1">Any</span><span class="s3">]</span>
<span class="s1">SerializerFunction </span><span class="s3">= </span><span class="s1">Union</span><span class="s3">[</span>
    <span class="s1">GeneralPlainNoInfoSerializerFunction</span><span class="s3">,</span>
    <span class="s1">GeneralPlainInfoSerializerFunction</span><span class="s3">,</span>
    <span class="s1">FieldPlainNoInfoSerializerFunction</span><span class="s3">,</span>
    <span class="s1">FieldPlainInfoSerializerFunction</span><span class="s3">,</span>
<span class="s3">]</span>

<span class="s1">WhenUsed </span><span class="s3">= </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'always'</span><span class="s3">, </span><span class="s6">'unless-none'</span><span class="s3">, </span><span class="s6">'json'</span><span class="s3">, </span><span class="s6">'json-unless-none'</span><span class="s3">]</span>
<span class="s6">&quot;&quot;&quot; 
Values have the following meanings: 
 
* `'always'` means always use 
* `'unless-none'` means use unless the value is `None` 
* `'json'` means use when serializing to JSON 
* `'json-unless-none'` means use when serializing to JSON and the value is not `None` 
&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">PlainSerializerFunctionSerSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'function-plain'</span><span class="s3">]]</span>
    <span class="s1">function</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">SerializerFunction</span><span class="s3">]</span>
    <span class="s1">is_field_serializer</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default False</span>
    <span class="s1">info_arg</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default False</span>
    <span class="s1">return_schema</span><span class="s3">: </span><span class="s1">CoreSchema  </span><span class="s5"># if omitted, AnySchema is used</span>
    <span class="s1">when_used</span><span class="s3">: </span><span class="s1">WhenUsed  </span><span class="s5"># default: 'always'</span>


<span class="s2">def </span><span class="s1">plain_serializer_function_ser_schema</span><span class="s3">(</span>
    <span class="s1">function</span><span class="s3">: </span><span class="s1">SerializerFunction</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">is_field_serializer</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">info_arg</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">return_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">when_used</span><span class="s3">: </span><span class="s1">WhenUsed </span><span class="s3">= </span><span class="s6">'always'</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; PlainSerializerFunctionSerSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema for serialization with a function, can be either a &quot;general&quot; or &quot;field&quot; function. 
 
    Args: 
        function: The function to use for serialization 
        is_field_serializer: Whether the serializer is for a field, e.g. takes `model` as the first argument, 
            and `info` includes `field_name` 
        info_arg: Whether the function takes an `info` argument 
        return_schema: Schema to use for serializing return value 
        when_used: When the function should be called 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">when_used </span><span class="s3">== </span><span class="s6">'always'</span><span class="s3">:</span>
        <span class="s5"># just to avoid extra elements in schema, and to use the actual default defined in rust</span>
        <span class="s1">when_used </span><span class="s3">= </span><span class="s2">None  </span><span class="s5"># type: ignore</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'function-plain'</span><span class="s3">,</span>
        <span class="s1">function</span><span class="s3">=</span><span class="s1">function</span><span class="s3">,</span>
        <span class="s1">is_field_serializer</span><span class="s3">=</span><span class="s1">is_field_serializer</span><span class="s3">,</span>
        <span class="s1">info_arg</span><span class="s3">=</span><span class="s1">info_arg</span><span class="s3">,</span>
        <span class="s1">return_schema</span><span class="s3">=</span><span class="s1">return_schema</span><span class="s3">,</span>
        <span class="s1">when_used</span><span class="s3">=</span><span class="s1">when_used</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">SerializerFunctionWrapHandler</span><span class="s3">(</span><span class="s1">Protocol</span><span class="s3">):  </span><span class="s5"># pragma: no cover</span>
    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">input_value</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">index_key</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, /) </span><span class="s1">-&gt; Any</span><span class="s3">: ...</span>


<span class="s5"># (input_value: Any, serializer: SerializerFunctionWrapHandler, /) -&gt; Any</span>
<span class="s1">GeneralWrapNoInfoSerializerFunction </span><span class="s3">= </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">SerializerFunctionWrapHandler</span><span class="s3">], </span><span class="s1">Any</span><span class="s3">]</span>
<span class="s5"># (input_value: Any, serializer: SerializerFunctionWrapHandler, info: SerializationInfo, /) -&gt; Any</span>
<span class="s1">GeneralWrapInfoSerializerFunction </span><span class="s3">= </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">SerializerFunctionWrapHandler</span><span class="s3">, </span><span class="s1">SerializationInfo</span><span class="s3">], </span><span class="s1">Any</span><span class="s3">]</span>
<span class="s5"># (model: Any, input_value: Any, serializer: SerializerFunctionWrapHandler, /) -&gt; Any</span>
<span class="s1">FieldWrapNoInfoSerializerFunction </span><span class="s3">= </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">SerializerFunctionWrapHandler</span><span class="s3">], </span><span class="s1">Any</span><span class="s3">]</span>
<span class="s5"># (model: Any, input_value: Any, serializer: SerializerFunctionWrapHandler, info: FieldSerializationInfo, /) -&gt; Any</span>
<span class="s1">FieldWrapInfoSerializerFunction </span><span class="s3">= </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">SerializerFunctionWrapHandler</span><span class="s3">, </span><span class="s1">FieldSerializationInfo</span><span class="s3">], </span><span class="s1">Any</span><span class="s3">]</span>
<span class="s1">WrapSerializerFunction </span><span class="s3">= </span><span class="s1">Union</span><span class="s3">[</span>
    <span class="s1">GeneralWrapNoInfoSerializerFunction</span><span class="s3">,</span>
    <span class="s1">GeneralWrapInfoSerializerFunction</span><span class="s3">,</span>
    <span class="s1">FieldWrapNoInfoSerializerFunction</span><span class="s3">,</span>
    <span class="s1">FieldWrapInfoSerializerFunction</span><span class="s3">,</span>
<span class="s3">]</span>


<span class="s2">class </span><span class="s1">WrapSerializerFunctionSerSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'function-wrap'</span><span class="s3">]]</span>
    <span class="s1">function</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">WrapSerializerFunction</span><span class="s3">]</span>
    <span class="s1">is_field_serializer</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default False</span>
    <span class="s1">info_arg</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default False</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema  </span><span class="s5"># if omitted, the schema on which this serializer is defined is used</span>
    <span class="s1">return_schema</span><span class="s3">: </span><span class="s1">CoreSchema  </span><span class="s5"># if omitted, AnySchema is used</span>
    <span class="s1">when_used</span><span class="s3">: </span><span class="s1">WhenUsed  </span><span class="s5"># default: 'always'</span>


<span class="s2">def </span><span class="s1">wrap_serializer_function_ser_schema</span><span class="s3">(</span>
    <span class="s1">function</span><span class="s3">: </span><span class="s1">WrapSerializerFunction</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">is_field_serializer</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">info_arg</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">return_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">when_used</span><span class="s3">: </span><span class="s1">WhenUsed </span><span class="s3">= </span><span class="s6">'always'</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; WrapSerializerFunctionSerSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema for serialization with a wrap function, can be either a &quot;general&quot; or &quot;field&quot; function. 
 
    Args: 
        function: The function to use for serialization 
        is_field_serializer: Whether the serializer is for a field, e.g. takes `model` as the first argument, 
            and `info` includes `field_name` 
        info_arg: Whether the function takes an `info` argument 
        schema: The schema to use for the inner serialization 
        return_schema: Schema to use for serializing return value 
        when_used: When the function should be called 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">when_used </span><span class="s3">== </span><span class="s6">'always'</span><span class="s3">:</span>
        <span class="s5"># just to avoid extra elements in schema, and to use the actual default defined in rust</span>
        <span class="s1">when_used </span><span class="s3">= </span><span class="s2">None  </span><span class="s5"># type: ignore</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'function-wrap'</span><span class="s3">,</span>
        <span class="s1">function</span><span class="s3">=</span><span class="s1">function</span><span class="s3">,</span>
        <span class="s1">is_field_serializer</span><span class="s3">=</span><span class="s1">is_field_serializer</span><span class="s3">,</span>
        <span class="s1">info_arg</span><span class="s3">=</span><span class="s1">info_arg</span><span class="s3">,</span>
        <span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">,</span>
        <span class="s1">return_schema</span><span class="s3">=</span><span class="s1">return_schema</span><span class="s3">,</span>
        <span class="s1">when_used</span><span class="s3">=</span><span class="s1">when_used</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">FormatSerSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'format'</span><span class="s3">]]</span>
    <span class="s1">formatting_string</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]</span>
    <span class="s1">when_used</span><span class="s3">: </span><span class="s1">WhenUsed  </span><span class="s5"># default: 'json-unless-none'</span>


<span class="s2">def </span><span class="s1">format_ser_schema</span><span class="s3">(</span><span class="s1">formatting_string</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, *, </span><span class="s1">when_used</span><span class="s3">: </span><span class="s1">WhenUsed </span><span class="s3">= </span><span class="s6">'json-unless-none'</span><span class="s3">) </span><span class="s1">-&gt; FormatSerSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema for serialization using python's `format` method. 
 
    Args: 
        formatting_string: String defining the format to use 
        when_used: Same meaning as for [general_function_plain_ser_schema], but with a different default 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">when_used </span><span class="s3">== </span><span class="s6">'json-unless-none'</span><span class="s3">:</span>
        <span class="s5"># just to avoid extra elements in schema, and to use the actual default defined in rust</span>
        <span class="s1">when_used </span><span class="s3">= </span><span class="s2">None  </span><span class="s5"># type: ignore</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span><span class="s1">type</span><span class="s3">=</span><span class="s6">'format'</span><span class="s3">, </span><span class="s1">formatting_string</span><span class="s3">=</span><span class="s1">formatting_string</span><span class="s3">, </span><span class="s1">when_used</span><span class="s3">=</span><span class="s1">when_used</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">ToStringSerSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'to-string'</span><span class="s3">]]</span>
    <span class="s1">when_used</span><span class="s3">: </span><span class="s1">WhenUsed  </span><span class="s5"># default: 'json-unless-none'</span>


<span class="s2">def </span><span class="s1">to_string_ser_schema</span><span class="s3">(*, </span><span class="s1">when_used</span><span class="s3">: </span><span class="s1">WhenUsed </span><span class="s3">= </span><span class="s6">'json-unless-none'</span><span class="s3">) </span><span class="s1">-&gt; ToStringSerSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema for serialization using python's `str()` / `__str__` method. 
 
    Args: 
        when_used: Same meaning as for [general_function_plain_ser_schema], but with a different default 
    &quot;&quot;&quot;</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">type</span><span class="s3">=</span><span class="s6">'to-string'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">when_used </span><span class="s3">!= </span><span class="s6">'json-unless-none'</span><span class="s3">:</span>
        <span class="s5"># just to avoid extra elements in schema, and to use the actual default defined in rust</span>
        <span class="s1">s</span><span class="s3">[</span><span class="s6">'when_used'</span><span class="s3">] = </span><span class="s1">when_used</span>
    <span class="s2">return </span><span class="s1">s  </span><span class="s5"># type: ignore</span>


<span class="s2">class </span><span class="s1">ModelSerSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'model'</span><span class="s3">]]</span>
    <span class="s1">cls</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">type</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]]</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">model_ser_schema</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">], </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">) </span><span class="s1">-&gt; ModelSerSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema for serialization using a model. 
 
    Args: 
        cls: The expected class type, used to generate warnings if the wrong type is passed 
        schema: Internal schema to use to serialize the model dict 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">ModelSerSchema</span><span class="s3">(</span><span class="s1">type</span><span class="s3">=</span><span class="s6">'model'</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">=</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">)</span>


<span class="s1">SerSchema </span><span class="s3">= </span><span class="s1">Union</span><span class="s3">[</span>
    <span class="s1">SimpleSerSchema</span><span class="s3">,</span>
    <span class="s1">PlainSerializerFunctionSerSchema</span><span class="s3">,</span>
    <span class="s1">WrapSerializerFunctionSerSchema</span><span class="s3">,</span>
    <span class="s1">FormatSerSchema</span><span class="s3">,</span>
    <span class="s1">ToStringSerSchema</span><span class="s3">,</span>
    <span class="s1">ModelSerSchema</span><span class="s3">,</span>
<span class="s3">]</span>


<span class="s2">class </span><span class="s1">InvalidSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'invalid'</span><span class="s3">]]</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s5"># note, we never plan to use this, but include it for type checking purposes to match</span>
    <span class="s5"># all other CoreSchema union members</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">invalid_schema</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">) </span><span class="s1">-&gt; InvalidSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns an invalid schema, used to indicate that a schema is invalid. 
 
        Returns a schema that matches any value, e.g.: 
 
    Args: 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
    &quot;&quot;&quot;</span>

    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span><span class="s1">type</span><span class="s3">=</span><span class="s6">'invalid'</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">ComputedField</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'computed-field'</span><span class="s3">]]</span>
    <span class="s1">property_name</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]</span>
    <span class="s1">return_schema</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]</span>
    <span class="s1">alias</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">computed_field</span><span class="s3">(</span>
    <span class="s1">property_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">return_schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">, *, </span><span class="s1">alias</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
<span class="s3">) </span><span class="s1">-&gt; ComputedField</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    ComputedFields are properties of a model or dataclass that are included in serialization. 
 
    Args: 
        property_name: The name of the property on the model or dataclass 
        return_schema: The schema used for the type returned by the computed field 
        alias: The name to use in the serialized output 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'computed-field'</span><span class="s3">, </span><span class="s1">property_name</span><span class="s3">=</span><span class="s1">property_name</span><span class="s3">, </span><span class="s1">return_schema</span><span class="s3">=</span><span class="s1">return_schema</span><span class="s3">, </span><span class="s1">alias</span><span class="s3">=</span><span class="s1">alias</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">AnySchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'any'</span><span class="s3">]]</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">any_schema</span><span class="s3">(</span>
    <span class="s3">*, </span><span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
<span class="s3">) </span><span class="s1">-&gt; AnySchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches any value, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.any_schema() 
    v = SchemaValidator(schema) 
    assert v.validate_python(1) == 1 
    ``` 
 
    Args: 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span><span class="s1">type</span><span class="s3">=</span><span class="s6">'any'</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">NoneSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'none'</span><span class="s3">]]</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">none_schema</span><span class="s3">(</span>
    <span class="s3">*, </span><span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
<span class="s3">) </span><span class="s1">-&gt; NoneSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a None value, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.none_schema() 
    v = SchemaValidator(schema) 
    assert v.validate_python(None) is None 
    ``` 
 
    Args: 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span><span class="s1">type</span><span class="s3">=</span><span class="s6">'none'</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">BoolSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'bool'</span><span class="s3">]]</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">bool_schema</span><span class="s3">(</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; BoolSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a bool value, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.bool_schema() 
    v = SchemaValidator(schema) 
    assert v.validate_python('True') is True 
    ``` 
 
    Args: 
        strict: Whether the value should be a bool or a value that can be converted to a bool 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span><span class="s1">type</span><span class="s3">=</span><span class="s6">'bool'</span><span class="s3">, </span><span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">IntSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'int'</span><span class="s3">]]</span>
    <span class="s1">multiple_of</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">le</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">ge</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">lt</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">gt</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">int_schema</span><span class="s3">(</span>
    <span class="s3">*,</span>
    <span class="s1">multiple_of</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">le</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ge</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">lt</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">gt</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; IntSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a int value, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.int_schema(multiple_of=2, le=6, ge=2) 
    v = SchemaValidator(schema) 
    assert v.validate_python('4') == 4 
    ``` 
 
    Args: 
        multiple_of: The value must be a multiple of this number 
        le: The value must be less than or equal to this number 
        ge: The value must be greater than or equal to this number 
        lt: The value must be strictly less than this number 
        gt: The value must be strictly greater than this number 
        strict: Whether the value should be a int or a value that can be converted to a int 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'int'</span><span class="s3">,</span>
        <span class="s1">multiple_of</span><span class="s3">=</span><span class="s1">multiple_of</span><span class="s3">,</span>
        <span class="s1">le</span><span class="s3">=</span><span class="s1">le</span><span class="s3">,</span>
        <span class="s1">ge</span><span class="s3">=</span><span class="s1">ge</span><span class="s3">,</span>
        <span class="s1">lt</span><span class="s3">=</span><span class="s1">lt</span><span class="s3">,</span>
        <span class="s1">gt</span><span class="s3">=</span><span class="s1">gt</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">FloatSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'float'</span><span class="s3">]]</span>
    <span class="s1">allow_inf_nan</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># whether 'NaN', '+inf', '-inf' should be forbidden. default: True</span>
    <span class="s1">multiple_of</span><span class="s3">: </span><span class="s1">float</span>
    <span class="s1">le</span><span class="s3">: </span><span class="s1">float</span>
    <span class="s1">ge</span><span class="s3">: </span><span class="s1">float</span>
    <span class="s1">lt</span><span class="s3">: </span><span class="s1">float</span>
    <span class="s1">gt</span><span class="s3">: </span><span class="s1">float</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">float_schema</span><span class="s3">(</span>
    <span class="s3">*,</span>
    <span class="s1">allow_inf_nan</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">multiple_of</span><span class="s3">: </span><span class="s1">float </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">le</span><span class="s3">: </span><span class="s1">float </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ge</span><span class="s3">: </span><span class="s1">float </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">lt</span><span class="s3">: </span><span class="s1">float </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">gt</span><span class="s3">: </span><span class="s1">float </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; FloatSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a float value, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.float_schema(le=0.8, ge=0.2) 
    v = SchemaValidator(schema) 
    assert v.validate_python('0.5') == 0.5 
    ``` 
 
    Args: 
        allow_inf_nan: Whether to allow inf and nan values 
        multiple_of: The value must be a multiple of this number 
        le: The value must be less than or equal to this number 
        ge: The value must be greater than or equal to this number 
        lt: The value must be strictly less than this number 
        gt: The value must be strictly greater than this number 
        strict: Whether the value should be a float or a value that can be converted to a float 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'float'</span><span class="s3">,</span>
        <span class="s1">allow_inf_nan</span><span class="s3">=</span><span class="s1">allow_inf_nan</span><span class="s3">,</span>
        <span class="s1">multiple_of</span><span class="s3">=</span><span class="s1">multiple_of</span><span class="s3">,</span>
        <span class="s1">le</span><span class="s3">=</span><span class="s1">le</span><span class="s3">,</span>
        <span class="s1">ge</span><span class="s3">=</span><span class="s1">ge</span><span class="s3">,</span>
        <span class="s1">lt</span><span class="s3">=</span><span class="s1">lt</span><span class="s3">,</span>
        <span class="s1">gt</span><span class="s3">=</span><span class="s1">gt</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">DecimalSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'decimal'</span><span class="s3">]]</span>
    <span class="s1">allow_inf_nan</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># whether 'NaN', '+inf', '-inf' should be forbidden. default: False</span>
    <span class="s1">multiple_of</span><span class="s3">: </span><span class="s1">Decimal</span>
    <span class="s1">le</span><span class="s3">: </span><span class="s1">Decimal</span>
    <span class="s1">ge</span><span class="s3">: </span><span class="s1">Decimal</span>
    <span class="s1">lt</span><span class="s3">: </span><span class="s1">Decimal</span>
    <span class="s1">gt</span><span class="s3">: </span><span class="s1">Decimal</span>
    <span class="s1">max_digits</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">decimal_places</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">decimal_schema</span><span class="s3">(</span>
    <span class="s3">*,</span>
    <span class="s1">allow_inf_nan</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">multiple_of</span><span class="s3">: </span><span class="s1">Decimal </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">le</span><span class="s3">: </span><span class="s1">Decimal </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ge</span><span class="s3">: </span><span class="s1">Decimal </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">lt</span><span class="s3">: </span><span class="s1">Decimal </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">gt</span><span class="s3">: </span><span class="s1">Decimal </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">max_digits</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">decimal_places</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; DecimalSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a decimal value, e.g.: 
 
    ```py 
    from decimal import Decimal 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.decimal_schema(le=0.8, ge=0.2) 
    v = SchemaValidator(schema) 
    assert v.validate_python('0.5') == Decimal('0.5') 
    ``` 
 
    Args: 
        allow_inf_nan: Whether to allow inf and nan values 
        multiple_of: The value must be a multiple of this number 
        le: The value must be less than or equal to this number 
        ge: The value must be greater than or equal to this number 
        lt: The value must be strictly less than this number 
        gt: The value must be strictly greater than this number 
        max_digits: The maximum number of decimal digits allowed 
        decimal_places: The maximum number of decimal places allowed 
        strict: Whether the value should be a float or a value that can be converted to a float 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'decimal'</span><span class="s3">,</span>
        <span class="s1">gt</span><span class="s3">=</span><span class="s1">gt</span><span class="s3">,</span>
        <span class="s1">ge</span><span class="s3">=</span><span class="s1">ge</span><span class="s3">,</span>
        <span class="s1">lt</span><span class="s3">=</span><span class="s1">lt</span><span class="s3">,</span>
        <span class="s1">le</span><span class="s3">=</span><span class="s1">le</span><span class="s3">,</span>
        <span class="s1">max_digits</span><span class="s3">=</span><span class="s1">max_digits</span><span class="s3">,</span>
        <span class="s1">decimal_places</span><span class="s3">=</span><span class="s1">decimal_places</span><span class="s3">,</span>
        <span class="s1">multiple_of</span><span class="s3">=</span><span class="s1">multiple_of</span><span class="s3">,</span>
        <span class="s1">allow_inf_nan</span><span class="s3">=</span><span class="s1">allow_inf_nan</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">ComplexSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'complex'</span><span class="s3">]]</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">complex_schema</span><span class="s3">(</span>
    <span class="s3">*,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ComplexSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a complex value, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.complex_schema() 
    v = SchemaValidator(schema) 
    assert v.validate_python('1+2j') == complex(1, 2) 
    assert v.validate_python(complex(1, 2)) == complex(1, 2) 
    ``` 
 
    Args: 
        strict: Whether the value should be a complex object instance or a value that can be converted to a complex object 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'complex'</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">StringSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'str'</span><span class="s3">]]</span>
    <span class="s1">pattern</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Pattern</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]]</span>
    <span class="s1">max_length</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">min_length</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">strip_whitespace</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">to_lower</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">to_upper</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">regex_engine</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'rust-regex'</span><span class="s3">, </span><span class="s6">'python-re'</span><span class="s3">]  </span><span class="s5"># default: 'rust-regex'</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">coerce_numbers_to_str</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">str_schema</span><span class="s3">(</span>
    <span class="s3">*,</span>
    <span class="s1">pattern</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s1">Pattern</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">max_length</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">min_length</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">strip_whitespace</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">to_lower</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">to_upper</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">regex_engine</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'rust-regex'</span><span class="s3">, </span><span class="s6">'python-re'</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">coerce_numbers_to_str</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; StringSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a string value, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.str_schema(max_length=10, min_length=2) 
    v = SchemaValidator(schema) 
    assert v.validate_python('hello') == 'hello' 
    ``` 
 
    Args: 
        pattern: A regex pattern that the value must match 
        max_length: The value must be at most this length 
        min_length: The value must be at least this length 
        strip_whitespace: Whether to strip whitespace from the value 
        to_lower: Whether to convert the value to lowercase 
        to_upper: Whether to convert the value to uppercase 
        regex_engine: The regex engine to use for pattern validation. Default is 'rust-regex'. 
            - `rust-regex` uses the [`regex`](https://docs.rs/regex) Rust 
              crate, which is non-backtracking and therefore more DDoS 
              resistant, but does not support all regex features. 
            - `python-re` use the [`re`](https://docs.python.org/3/library/re.html) module, 
              which supports all regex features, but may be slower. 
        strict: Whether the value should be a string or a value that can be converted to a string 
        coerce_numbers_to_str: Whether to enable coercion of any `Number` type to `str` (not applicable in `strict` mode). 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'str'</span><span class="s3">,</span>
        <span class="s1">pattern</span><span class="s3">=</span><span class="s1">pattern</span><span class="s3">,</span>
        <span class="s1">max_length</span><span class="s3">=</span><span class="s1">max_length</span><span class="s3">,</span>
        <span class="s1">min_length</span><span class="s3">=</span><span class="s1">min_length</span><span class="s3">,</span>
        <span class="s1">strip_whitespace</span><span class="s3">=</span><span class="s1">strip_whitespace</span><span class="s3">,</span>
        <span class="s1">to_lower</span><span class="s3">=</span><span class="s1">to_lower</span><span class="s3">,</span>
        <span class="s1">to_upper</span><span class="s3">=</span><span class="s1">to_upper</span><span class="s3">,</span>
        <span class="s1">regex_engine</span><span class="s3">=</span><span class="s1">regex_engine</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">coerce_numbers_to_str</span><span class="s3">=</span><span class="s1">coerce_numbers_to_str</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">BytesSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'bytes'</span><span class="s3">]]</span>
    <span class="s1">max_length</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">min_length</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">bytes_schema</span><span class="s3">(</span>
    <span class="s3">*,</span>
    <span class="s1">max_length</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">min_length</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; BytesSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a bytes value, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.bytes_schema(max_length=10, min_length=2) 
    v = SchemaValidator(schema) 
    assert v.validate_python(b'hello') == b'hello' 
    ``` 
 
    Args: 
        max_length: The value must be at most this length 
        min_length: The value must be at least this length 
        strict: Whether the value should be a bytes or a value that can be converted to a bytes 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'bytes'</span><span class="s3">,</span>
        <span class="s1">max_length</span><span class="s3">=</span><span class="s1">max_length</span><span class="s3">,</span>
        <span class="s1">min_length</span><span class="s3">=</span><span class="s1">min_length</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">DateSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'date'</span><span class="s3">]]</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">le</span><span class="s3">: </span><span class="s1">date</span>
    <span class="s1">ge</span><span class="s3">: </span><span class="s1">date</span>
    <span class="s1">lt</span><span class="s3">: </span><span class="s1">date</span>
    <span class="s1">gt</span><span class="s3">: </span><span class="s1">date</span>
    <span class="s1">now_op</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'past'</span><span class="s3">, </span><span class="s6">'future'</span><span class="s3">]</span>
    <span class="s5"># defaults to current local utc offset from `time.localtime().tm_gmtoff`</span>
    <span class="s5"># value is restricted to -86_400 &lt; offset &lt; 86_400 by bounds in generate_self_schema.py</span>
    <span class="s1">now_utc_offset</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">date_schema</span><span class="s3">(</span>
    <span class="s3">*,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">le</span><span class="s3">: </span><span class="s1">date </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ge</span><span class="s3">: </span><span class="s1">date </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">lt</span><span class="s3">: </span><span class="s1">date </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">gt</span><span class="s3">: </span><span class="s1">date </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">now_op</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'past'</span><span class="s3">, </span><span class="s6">'future'</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">now_utc_offset</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; DateSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a date value, e.g.: 
 
    ```py 
    from datetime import date 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.date_schema(le=date(2020, 1, 1), ge=date(2019, 1, 1)) 
    v = SchemaValidator(schema) 
    assert v.validate_python(date(2019, 6, 1)) == date(2019, 6, 1) 
    ``` 
 
    Args: 
        strict: Whether the value should be a date or a value that can be converted to a date 
        le: The value must be less than or equal to this date 
        ge: The value must be greater than or equal to this date 
        lt: The value must be strictly less than this date 
        gt: The value must be strictly greater than this date 
        now_op: The value must be in the past or future relative to the current date 
        now_utc_offset: The value must be in the past or future relative to the current date with this utc offset 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'date'</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">le</span><span class="s3">=</span><span class="s1">le</span><span class="s3">,</span>
        <span class="s1">ge</span><span class="s3">=</span><span class="s1">ge</span><span class="s3">,</span>
        <span class="s1">lt</span><span class="s3">=</span><span class="s1">lt</span><span class="s3">,</span>
        <span class="s1">gt</span><span class="s3">=</span><span class="s1">gt</span><span class="s3">,</span>
        <span class="s1">now_op</span><span class="s3">=</span><span class="s1">now_op</span><span class="s3">,</span>
        <span class="s1">now_utc_offset</span><span class="s3">=</span><span class="s1">now_utc_offset</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">TimeSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'time'</span><span class="s3">]]</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">le</span><span class="s3">: </span><span class="s1">time</span>
    <span class="s1">ge</span><span class="s3">: </span><span class="s1">time</span>
    <span class="s1">lt</span><span class="s3">: </span><span class="s1">time</span>
    <span class="s1">gt</span><span class="s3">: </span><span class="s1">time</span>
    <span class="s1">tz_constraint</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'aware'</span><span class="s3">, </span><span class="s6">'naive'</span><span class="s3">], </span><span class="s1">int</span><span class="s3">]</span>
    <span class="s1">microseconds_precision</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'truncate'</span><span class="s3">, </span><span class="s6">'error'</span><span class="s3">]</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">time_schema</span><span class="s3">(</span>
    <span class="s3">*,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">le</span><span class="s3">: </span><span class="s1">time </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ge</span><span class="s3">: </span><span class="s1">time </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">lt</span><span class="s3">: </span><span class="s1">time </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">gt</span><span class="s3">: </span><span class="s1">time </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">tz_constraint</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'aware'</span><span class="s3">, </span><span class="s6">'naive'</span><span class="s3">] | </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">microseconds_precision</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'truncate'</span><span class="s3">, </span><span class="s6">'error'</span><span class="s3">] = </span><span class="s6">'truncate'</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; TimeSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a time value, e.g.: 
 
    ```py 
    from datetime import time 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.time_schema(le=time(12, 0, 0), ge=time(6, 0, 0)) 
    v = SchemaValidator(schema) 
    assert v.validate_python(time(9, 0, 0)) == time(9, 0, 0) 
    ``` 
 
    Args: 
        strict: Whether the value should be a time or a value that can be converted to a time 
        le: The value must be less than or equal to this time 
        ge: The value must be greater than or equal to this time 
        lt: The value must be strictly less than this time 
        gt: The value must be strictly greater than this time 
        tz_constraint: The value must be timezone aware or naive, or an int to indicate required tz offset 
        microseconds_precision: The behavior when seconds have more than 6 digits or microseconds is too large 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'time'</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">le</span><span class="s3">=</span><span class="s1">le</span><span class="s3">,</span>
        <span class="s1">ge</span><span class="s3">=</span><span class="s1">ge</span><span class="s3">,</span>
        <span class="s1">lt</span><span class="s3">=</span><span class="s1">lt</span><span class="s3">,</span>
        <span class="s1">gt</span><span class="s3">=</span><span class="s1">gt</span><span class="s3">,</span>
        <span class="s1">tz_constraint</span><span class="s3">=</span><span class="s1">tz_constraint</span><span class="s3">,</span>
        <span class="s1">microseconds_precision</span><span class="s3">=</span><span class="s1">microseconds_precision</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">DatetimeSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'datetime'</span><span class="s3">]]</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">le</span><span class="s3">: </span><span class="s1">datetime</span>
    <span class="s1">ge</span><span class="s3">: </span><span class="s1">datetime</span>
    <span class="s1">lt</span><span class="s3">: </span><span class="s1">datetime</span>
    <span class="s1">gt</span><span class="s3">: </span><span class="s1">datetime</span>
    <span class="s1">now_op</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'past'</span><span class="s3">, </span><span class="s6">'future'</span><span class="s3">]</span>
    <span class="s1">tz_constraint</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'aware'</span><span class="s3">, </span><span class="s6">'naive'</span><span class="s3">], </span><span class="s1">int</span><span class="s3">]</span>
    <span class="s5"># defaults to current local utc offset from `time.localtime().tm_gmtoff`</span>
    <span class="s5"># value is restricted to -86_400 &lt; offset &lt; 86_400 by bounds in generate_self_schema.py</span>
    <span class="s1">now_utc_offset</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">microseconds_precision</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'truncate'</span><span class="s3">, </span><span class="s6">'error'</span><span class="s3">]  </span><span class="s5"># default: 'truncate'</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">datetime_schema</span><span class="s3">(</span>
    <span class="s3">*,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">le</span><span class="s3">: </span><span class="s1">datetime </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ge</span><span class="s3">: </span><span class="s1">datetime </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">lt</span><span class="s3">: </span><span class="s1">datetime </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">gt</span><span class="s3">: </span><span class="s1">datetime </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">now_op</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'past'</span><span class="s3">, </span><span class="s6">'future'</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">tz_constraint</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'aware'</span><span class="s3">, </span><span class="s6">'naive'</span><span class="s3">] | </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">now_utc_offset</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">microseconds_precision</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'truncate'</span><span class="s3">, </span><span class="s6">'error'</span><span class="s3">] = </span><span class="s6">'truncate'</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; DatetimeSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a datetime value, e.g.: 
 
    ```py 
    from datetime import datetime 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.datetime_schema() 
    v = SchemaValidator(schema) 
    now = datetime.now() 
    assert v.validate_python(str(now)) == now 
    ``` 
 
    Args: 
        strict: Whether the value should be a datetime or a value that can be converted to a datetime 
        le: The value must be less than or equal to this datetime 
        ge: The value must be greater than or equal to this datetime 
        lt: The value must be strictly less than this datetime 
        gt: The value must be strictly greater than this datetime 
        now_op: The value must be in the past or future relative to the current datetime 
        tz_constraint: The value must be timezone aware or naive, or an int to indicate required tz offset 
            TODO: use of a tzinfo where offset changes based on the datetime is not yet supported 
        now_utc_offset: The value must be in the past or future relative to the current datetime with this utc offset 
        microseconds_precision: The behavior when seconds have more than 6 digits or microseconds is too large 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'datetime'</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">le</span><span class="s3">=</span><span class="s1">le</span><span class="s3">,</span>
        <span class="s1">ge</span><span class="s3">=</span><span class="s1">ge</span><span class="s3">,</span>
        <span class="s1">lt</span><span class="s3">=</span><span class="s1">lt</span><span class="s3">,</span>
        <span class="s1">gt</span><span class="s3">=</span><span class="s1">gt</span><span class="s3">,</span>
        <span class="s1">now_op</span><span class="s3">=</span><span class="s1">now_op</span><span class="s3">,</span>
        <span class="s1">tz_constraint</span><span class="s3">=</span><span class="s1">tz_constraint</span><span class="s3">,</span>
        <span class="s1">now_utc_offset</span><span class="s3">=</span><span class="s1">now_utc_offset</span><span class="s3">,</span>
        <span class="s1">microseconds_precision</span><span class="s3">=</span><span class="s1">microseconds_precision</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">TimedeltaSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'timedelta'</span><span class="s3">]]</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">le</span><span class="s3">: </span><span class="s1">timedelta</span>
    <span class="s1">ge</span><span class="s3">: </span><span class="s1">timedelta</span>
    <span class="s1">lt</span><span class="s3">: </span><span class="s1">timedelta</span>
    <span class="s1">gt</span><span class="s3">: </span><span class="s1">timedelta</span>
    <span class="s1">microseconds_precision</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'truncate'</span><span class="s3">, </span><span class="s6">'error'</span><span class="s3">]</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">timedelta_schema</span><span class="s3">(</span>
    <span class="s3">*,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">le</span><span class="s3">: </span><span class="s1">timedelta </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ge</span><span class="s3">: </span><span class="s1">timedelta </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">lt</span><span class="s3">: </span><span class="s1">timedelta </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">gt</span><span class="s3">: </span><span class="s1">timedelta </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">microseconds_precision</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'truncate'</span><span class="s3">, </span><span class="s6">'error'</span><span class="s3">] = </span><span class="s6">'truncate'</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; TimedeltaSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a timedelta value, e.g.: 
 
    ```py 
    from datetime import timedelta 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.timedelta_schema(le=timedelta(days=1), ge=timedelta(days=0)) 
    v = SchemaValidator(schema) 
    assert v.validate_python(timedelta(hours=12)) == timedelta(hours=12) 
    ``` 
 
    Args: 
        strict: Whether the value should be a timedelta or a value that can be converted to a timedelta 
        le: The value must be less than or equal to this timedelta 
        ge: The value must be greater than or equal to this timedelta 
        lt: The value must be strictly less than this timedelta 
        gt: The value must be strictly greater than this timedelta 
        microseconds_precision: The behavior when seconds have more than 6 digits or microseconds is too large 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'timedelta'</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">le</span><span class="s3">=</span><span class="s1">le</span><span class="s3">,</span>
        <span class="s1">ge</span><span class="s3">=</span><span class="s1">ge</span><span class="s3">,</span>
        <span class="s1">lt</span><span class="s3">=</span><span class="s1">lt</span><span class="s3">,</span>
        <span class="s1">gt</span><span class="s3">=</span><span class="s1">gt</span><span class="s3">,</span>
        <span class="s1">microseconds_precision</span><span class="s3">=</span><span class="s1">microseconds_precision</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">LiteralSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'literal'</span><span class="s3">]]</span>
    <span class="s1">expected</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]]</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">literal_schema</span><span class="s3">(</span>
    <span class="s1">expected</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">],</span>
    <span class="s3">*,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; LiteralSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a literal value, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.literal_schema(['hello', 'world']) 
    v = SchemaValidator(schema) 
    assert v.validate_python('hello') == 'hello' 
    ``` 
 
    Args: 
        expected: The value must be one of these values 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span><span class="s1">type</span><span class="s3">=</span><span class="s6">'literal'</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">=</span><span class="s1">expected</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">EnumSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'enum'</span><span class="s3">]]</span>
    <span class="s1">cls</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">members</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]]</span>
    <span class="s1">sub_type</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'str'</span><span class="s3">, </span><span class="s6">'int'</span><span class="s3">, </span><span class="s6">'float'</span><span class="s3">]</span>
    <span class="s1">missing</span><span class="s3">: </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Any</span><span class="s3">], </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">enum_schema</span><span class="s3">(</span>
    <span class="s1">cls</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s1">members</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">],</span>
    <span class="s3">*,</span>
    <span class="s1">sub_type</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'str'</span><span class="s3">, </span><span class="s6">'int'</span><span class="s3">, </span><span class="s6">'float'</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">missing</span><span class="s3">: </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Any</span><span class="s3">], </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; EnumSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches an enum value, e.g.: 
 
    ```py 
    from enum import Enum 
    from pydantic_core import SchemaValidator, core_schema 
 
    class Color(Enum): 
        RED = 1 
        GREEN = 2 
        BLUE = 3 
 
    schema = core_schema.enum_schema(Color, list(Color.__members__.values())) 
    v = SchemaValidator(schema) 
    assert v.validate_python(2) is Color.GREEN 
    ``` 
 
    Args: 
        cls: The enum class 
        members: The members of the enum, generally `list(MyEnum.__members__.values())` 
        sub_type: The type of the enum, either 'str' or 'int' or None for plain enums 
        missing: A function to use when the value is not found in the enum, from `_missing_` 
        strict: Whether to use strict mode, defaults to False 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'enum'</span><span class="s3">,</span>
        <span class="s1">cls</span><span class="s3">=</span><span class="s1">cls</span><span class="s3">,</span>
        <span class="s1">members</span><span class="s3">=</span><span class="s1">members</span><span class="s3">,</span>
        <span class="s1">sub_type</span><span class="s3">=</span><span class="s1">sub_type</span><span class="s3">,</span>
        <span class="s1">missing</span><span class="s3">=</span><span class="s1">missing</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s5"># must match input/parse_json.rs::JsonType::try_from</span>
<span class="s1">JsonType </span><span class="s3">= </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'null'</span><span class="s3">, </span><span class="s6">'bool'</span><span class="s3">, </span><span class="s6">'int'</span><span class="s3">, </span><span class="s6">'float'</span><span class="s3">, </span><span class="s6">'str'</span><span class="s3">, </span><span class="s6">'list'</span><span class="s3">, </span><span class="s6">'dict'</span><span class="s3">]</span>


<span class="s2">class </span><span class="s1">IsInstanceSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'is-instance'</span><span class="s3">]]</span>
    <span class="s1">cls</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">cls_repr</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">is_instance_schema</span><span class="s3">(</span>
    <span class="s1">cls</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">cls_repr</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; IsInstanceSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that checks if a value is an instance of a class, equivalent to python's `isinstance` method, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    class A: 
        pass 
 
    schema = core_schema.is_instance_schema(cls=A) 
    v = SchemaValidator(schema) 
    v.validate_python(A()) 
    ``` 
 
    Args: 
        cls: The value must be an instance of this class 
        cls_repr: If provided this string is used in the validator name instead of `repr(cls)` 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'is-instance'</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">=</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">cls_repr</span><span class="s3">=</span><span class="s1">cls_repr</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">IsSubclassSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'is-subclass'</span><span class="s3">]]</span>
    <span class="s1">cls</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">type</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]]</span>
    <span class="s1">cls_repr</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">is_subclass_schema</span><span class="s3">(</span>
    <span class="s1">cls</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">],</span>
    <span class="s3">*,</span>
    <span class="s1">cls_repr</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; IsInstanceSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that checks if a value is a subtype of a class, equivalent to python's `issubclass` method, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    class A: 
        pass 
 
    class B(A): 
        pass 
 
    schema = core_schema.is_subclass_schema(cls=A) 
    v = SchemaValidator(schema) 
    v.validate_python(B) 
    ``` 
 
    Args: 
        cls: The value must be a subclass of this class 
        cls_repr: If provided this string is used in the validator name instead of `repr(cls)` 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'is-subclass'</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">=</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">cls_repr</span><span class="s3">=</span><span class="s1">cls_repr</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">CallableSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'callable'</span><span class="s3">]]</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">callable_schema</span><span class="s3">(</span>
    <span class="s3">*, </span><span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
<span class="s3">) </span><span class="s1">-&gt; CallableSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that checks if a value is callable, equivalent to python's `callable` method, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.callable_schema() 
    v = SchemaValidator(schema) 
    v.validate_python(min) 
    ``` 
 
    Args: 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span><span class="s1">type</span><span class="s3">=</span><span class="s6">'callable'</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">UuidSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'uuid'</span><span class="s3">]]</span>
    <span class="s1">version</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">7</span><span class="s3">]</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">uuid_schema</span><span class="s3">(</span>
    <span class="s3">*,</span>
    <span class="s1">version</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">, </span><span class="s4">7</span><span class="s3">, </span><span class="s4">8</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; UuidSchema</span><span class="s3">:</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'uuid'</span><span class="s3">, </span><span class="s1">version</span><span class="s3">=</span><span class="s1">version</span><span class="s3">, </span><span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">IncExSeqSerSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'include-exclude-sequence'</span><span class="s3">]]</span>
    <span class="s1">include</span><span class="s3">: </span><span class="s1">set</span><span class="s3">[</span><span class="s1">int</span><span class="s3">]</span>
    <span class="s1">exclude</span><span class="s3">: </span><span class="s1">set</span><span class="s3">[</span><span class="s1">int</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">filter_seq_schema</span><span class="s3">(*, </span><span class="s1">include</span><span class="s3">: </span><span class="s1">set</span><span class="s3">[</span><span class="s1">int</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s1">exclude</span><span class="s3">: </span><span class="s1">set</span><span class="s3">[</span><span class="s1">int</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">) </span><span class="s1">-&gt; IncExSeqSerSchema</span><span class="s3">:</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span><span class="s1">type</span><span class="s3">=</span><span class="s6">'include-exclude-sequence'</span><span class="s3">, </span><span class="s1">include</span><span class="s3">=</span><span class="s1">include</span><span class="s3">, </span><span class="s1">exclude</span><span class="s3">=</span><span class="s1">exclude</span><span class="s3">)</span>


<span class="s1">IncExSeqOrElseSerSchema </span><span class="s3">= </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">IncExSeqSerSchema</span><span class="s3">, </span><span class="s1">SerSchema</span><span class="s3">]</span>


<span class="s2">class </span><span class="s1">ListSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'list'</span><span class="s3">]]</span>
    <span class="s1">items_schema</span><span class="s3">: </span><span class="s1">CoreSchema</span>
    <span class="s1">min_length</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">max_length</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">fail_fast</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">IncExSeqOrElseSerSchema</span>


<span class="s2">def </span><span class="s1">list_schema</span><span class="s3">(</span>
    <span class="s1">items_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">min_length</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">max_length</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">fail_fast</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">IncExSeqOrElseSerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ListSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a list value, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.list_schema(core_schema.int_schema(), min_length=0, max_length=10) 
    v = SchemaValidator(schema) 
    assert v.validate_python(['4']) == [4] 
    ``` 
 
    Args: 
        items_schema: The value must be a list of items that match this schema 
        min_length: The value must be a list with at least this many items 
        max_length: The value must be a list with at most this many items 
        fail_fast: Stop validation on the first error 
        strict: The value must be a list with exactly this many items 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'list'</span><span class="s3">,</span>
        <span class="s1">items_schema</span><span class="s3">=</span><span class="s1">items_schema</span><span class="s3">,</span>
        <span class="s1">min_length</span><span class="s3">=</span><span class="s1">min_length</span><span class="s3">,</span>
        <span class="s1">max_length</span><span class="s3">=</span><span class="s1">max_length</span><span class="s3">,</span>
        <span class="s1">fail_fast</span><span class="s3">=</span><span class="s1">fail_fast</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s5"># @deprecated('tuple_positional_schema is deprecated. Use pydantic_core.core_schema.tuple_schema instead.')</span>
<span class="s2">def </span><span class="s1">tuple_positional_schema</span><span class="s3">(</span>
    <span class="s1">items_schema</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">],</span>
    <span class="s3">*,</span>
    <span class="s1">extras_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">IncExSeqOrElseSerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; TupleSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a tuple of schemas, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.tuple_positional_schema( 
        [core_schema.int_schema(), core_schema.str_schema()] 
    ) 
    v = SchemaValidator(schema) 
    assert v.validate_python((1, 'hello')) == (1, 'hello') 
    ``` 
 
    Args: 
        items_schema: The value must be a tuple with items that match these schemas 
        extras_schema: The value must be a tuple with items that match this schema 
            This was inspired by JSON schema's `prefixItems` and `items` fields. 
            In python's `typing.Tuple`, you can't specify a type for &quot;extra&quot; items -- they must all be the same type 
            if the length is variable. So this field won't be set from a `typing.Tuple` annotation on a pydantic model. 
        strict: The value must be a tuple with exactly this many items 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">extras_schema </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">variadic_item_index </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">items_schema</span><span class="s3">)</span>
        <span class="s1">items_schema </span><span class="s3">= </span><span class="s1">items_schema </span><span class="s3">+ [</span><span class="s1">extras_schema</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">variadic_item_index </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s2">return </span><span class="s1">tuple_schema</span><span class="s3">(</span>
        <span class="s1">items_schema</span><span class="s3">=</span><span class="s1">items_schema</span><span class="s3">,</span>
        <span class="s1">variadic_item_index</span><span class="s3">=</span><span class="s1">variadic_item_index</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s5"># @deprecated('tuple_variable_schema is deprecated. Use pydantic_core.core_schema.tuple_schema instead.')</span>
<span class="s2">def </span><span class="s1">tuple_variable_schema</span><span class="s3">(</span>
    <span class="s1">items_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">min_length</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">max_length</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">IncExSeqOrElseSerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; TupleSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a tuple of a given schema, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.tuple_variable_schema( 
        items_schema=core_schema.int_schema(), min_length=0, max_length=10 
    ) 
    v = SchemaValidator(schema) 
    assert v.validate_python(('1', 2, 3)) == (1, 2, 3) 
    ``` 
 
    Args: 
        items_schema: The value must be a tuple with items that match this schema 
        min_length: The value must be a tuple with at least this many items 
        max_length: The value must be a tuple with at most this many items 
        strict: The value must be a tuple with exactly this many items 
        ref: Optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">tuple_schema</span><span class="s3">(</span>
        <span class="s1">items_schema</span><span class="s3">=[</span><span class="s1">items_schema </span><span class="s2">or </span><span class="s1">any_schema</span><span class="s3">()],</span>
        <span class="s1">variadic_item_index</span><span class="s3">=</span><span class="s4">0</span><span class="s3">,</span>
        <span class="s1">min_length</span><span class="s3">=</span><span class="s1">min_length</span><span class="s3">,</span>
        <span class="s1">max_length</span><span class="s3">=</span><span class="s1">max_length</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">TupleSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'tuple'</span><span class="s3">]]</span>
    <span class="s1">items_schema</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]]</span>
    <span class="s1">variadic_item_index</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">min_length</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">max_length</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">fail_fast</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">IncExSeqOrElseSerSchema</span>


<span class="s2">def </span><span class="s1">tuple_schema</span><span class="s3">(</span>
    <span class="s1">items_schema</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">],</span>
    <span class="s3">*,</span>
    <span class="s1">variadic_item_index</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">min_length</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">max_length</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">fail_fast</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">IncExSeqOrElseSerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; TupleSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a tuple of schemas, with an optional variadic item, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.tuple_schema( 
        [core_schema.int_schema(), core_schema.str_schema(), core_schema.float_schema()], 
        variadic_item_index=1, 
    ) 
    v = SchemaValidator(schema) 
    assert v.validate_python((1, 'hello', 'world', 1.5)) == (1, 'hello', 'world', 1.5) 
    ``` 
 
    Args: 
        items_schema: The value must be a tuple with items that match these schemas 
        variadic_item_index: The index of the schema in `items_schema` to be treated as variadic (following PEP 646) 
        min_length: The value must be a tuple with at least this many items 
        max_length: The value must be a tuple with at most this many items 
        fail_fast: Stop validation on the first error 
        strict: The value must be a tuple with exactly this many items 
        ref: Optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'tuple'</span><span class="s3">,</span>
        <span class="s1">items_schema</span><span class="s3">=</span><span class="s1">items_schema</span><span class="s3">,</span>
        <span class="s1">variadic_item_index</span><span class="s3">=</span><span class="s1">variadic_item_index</span><span class="s3">,</span>
        <span class="s1">min_length</span><span class="s3">=</span><span class="s1">min_length</span><span class="s3">,</span>
        <span class="s1">max_length</span><span class="s3">=</span><span class="s1">max_length</span><span class="s3">,</span>
        <span class="s1">fail_fast</span><span class="s3">=</span><span class="s1">fail_fast</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">SetSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'set'</span><span class="s3">]]</span>
    <span class="s1">items_schema</span><span class="s3">: </span><span class="s1">CoreSchema</span>
    <span class="s1">min_length</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">max_length</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">fail_fast</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">set_schema</span><span class="s3">(</span>
    <span class="s1">items_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">min_length</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">max_length</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">fail_fast</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; SetSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a set of a given schema, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.set_schema( 
        items_schema=core_schema.int_schema(), min_length=0, max_length=10 
    ) 
    v = SchemaValidator(schema) 
    assert v.validate_python({1, '2', 3}) == {1, 2, 3} 
    ``` 
 
    Args: 
        items_schema: The value must be a set with items that match this schema 
        min_length: The value must be a set with at least this many items 
        max_length: The value must be a set with at most this many items 
        fail_fast: Stop validation on the first error 
        strict: The value must be a set with exactly this many items 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'set'</span><span class="s3">,</span>
        <span class="s1">items_schema</span><span class="s3">=</span><span class="s1">items_schema</span><span class="s3">,</span>
        <span class="s1">min_length</span><span class="s3">=</span><span class="s1">min_length</span><span class="s3">,</span>
        <span class="s1">max_length</span><span class="s3">=</span><span class="s1">max_length</span><span class="s3">,</span>
        <span class="s1">fail_fast</span><span class="s3">=</span><span class="s1">fail_fast</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">FrozenSetSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'frozenset'</span><span class="s3">]]</span>
    <span class="s1">items_schema</span><span class="s3">: </span><span class="s1">CoreSchema</span>
    <span class="s1">min_length</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">max_length</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">fail_fast</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">frozenset_schema</span><span class="s3">(</span>
    <span class="s1">items_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">min_length</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">max_length</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">fail_fast</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; FrozenSetSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a frozenset of a given schema, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.frozenset_schema( 
        items_schema=core_schema.int_schema(), min_length=0, max_length=10 
    ) 
    v = SchemaValidator(schema) 
    assert v.validate_python(frozenset(range(3))) == frozenset({0, 1, 2}) 
    ``` 
 
    Args: 
        items_schema: The value must be a frozenset with items that match this schema 
        min_length: The value must be a frozenset with at least this many items 
        max_length: The value must be a frozenset with at most this many items 
        fail_fast: Stop validation on the first error 
        strict: The value must be a frozenset with exactly this many items 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'frozenset'</span><span class="s3">,</span>
        <span class="s1">items_schema</span><span class="s3">=</span><span class="s1">items_schema</span><span class="s3">,</span>
        <span class="s1">min_length</span><span class="s3">=</span><span class="s1">min_length</span><span class="s3">,</span>
        <span class="s1">max_length</span><span class="s3">=</span><span class="s1">max_length</span><span class="s3">,</span>
        <span class="s1">fail_fast</span><span class="s3">=</span><span class="s1">fail_fast</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">GeneratorSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'generator'</span><span class="s3">]]</span>
    <span class="s1">items_schema</span><span class="s3">: </span><span class="s1">CoreSchema</span>
    <span class="s1">min_length</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">max_length</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">IncExSeqOrElseSerSchema</span>


<span class="s2">def </span><span class="s1">generator_schema</span><span class="s3">(</span>
    <span class="s1">items_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">min_length</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">max_length</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">IncExSeqOrElseSerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; GeneratorSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a generator value, e.g.: 
 
    ```py 
    from typing import Iterator 
    from pydantic_core import SchemaValidator, core_schema 
 
    def gen() -&gt; Iterator[int]: 
        yield 1 
 
    schema = core_schema.generator_schema(items_schema=core_schema.int_schema()) 
    v = SchemaValidator(schema) 
    v.validate_python(gen()) 
    ``` 
 
    Unlike other types, validated generators do not raise ValidationErrors eagerly, 
    but instead will raise a ValidationError when a violating value is actually read from the generator. 
    This is to ensure that &quot;validated&quot; generators retain the benefit of lazy evaluation. 
 
    Args: 
        items_schema: The value must be a generator with items that match this schema 
        min_length: The value must be a generator that yields at least this many items 
        max_length: The value must be a generator that yields at most this many items 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'generator'</span><span class="s3">,</span>
        <span class="s1">items_schema</span><span class="s3">=</span><span class="s1">items_schema</span><span class="s3">,</span>
        <span class="s1">min_length</span><span class="s3">=</span><span class="s1">min_length</span><span class="s3">,</span>
        <span class="s1">max_length</span><span class="s3">=</span><span class="s1">max_length</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s1">IncExDict </span><span class="s3">= </span><span class="s1">set</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">str</span><span class="s3">]]</span>


<span class="s2">class </span><span class="s1">IncExDictSerSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'include-exclude-dict'</span><span class="s3">]]</span>
    <span class="s1">include</span><span class="s3">: </span><span class="s1">IncExDict</span>
    <span class="s1">exclude</span><span class="s3">: </span><span class="s1">IncExDict</span>


<span class="s2">def </span><span class="s1">filter_dict_schema</span><span class="s3">(*, </span><span class="s1">include</span><span class="s3">: </span><span class="s1">IncExDict </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s1">exclude</span><span class="s3">: </span><span class="s1">IncExDict </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">) </span><span class="s1">-&gt; IncExDictSerSchema</span><span class="s3">:</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span><span class="s1">type</span><span class="s3">=</span><span class="s6">'include-exclude-dict'</span><span class="s3">, </span><span class="s1">include</span><span class="s3">=</span><span class="s1">include</span><span class="s3">, </span><span class="s1">exclude</span><span class="s3">=</span><span class="s1">exclude</span><span class="s3">)</span>


<span class="s1">IncExDictOrElseSerSchema </span><span class="s3">= </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">IncExDictSerSchema</span><span class="s3">, </span><span class="s1">SerSchema</span><span class="s3">]</span>


<span class="s2">class </span><span class="s1">DictSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'dict'</span><span class="s3">]]</span>
    <span class="s1">keys_schema</span><span class="s3">: </span><span class="s1">CoreSchema  </span><span class="s5"># default: AnySchema</span>
    <span class="s1">values_schema</span><span class="s3">: </span><span class="s1">CoreSchema  </span><span class="s5"># default: AnySchema</span>
    <span class="s1">min_length</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">max_length</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">IncExDictOrElseSerSchema</span>


<span class="s2">def </span><span class="s1">dict_schema</span><span class="s3">(</span>
    <span class="s1">keys_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">values_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">min_length</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">max_length</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; DictSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a dict value, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.dict_schema( 
        keys_schema=core_schema.str_schema(), values_schema=core_schema.int_schema() 
    ) 
    v = SchemaValidator(schema) 
    assert v.validate_python({'a': '1', 'b': 2}) == {'a': 1, 'b': 2} 
    ``` 
 
    Args: 
        keys_schema: The value must be a dict with keys that match this schema 
        values_schema: The value must be a dict with values that match this schema 
        min_length: The value must be a dict with at least this many items 
        max_length: The value must be a dict with at most this many items 
        strict: Whether the keys and values should be validated with strict mode 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'dict'</span><span class="s3">,</span>
        <span class="s1">keys_schema</span><span class="s3">=</span><span class="s1">keys_schema</span><span class="s3">,</span>
        <span class="s1">values_schema</span><span class="s3">=</span><span class="s1">values_schema</span><span class="s3">,</span>
        <span class="s1">min_length</span><span class="s3">=</span><span class="s1">min_length</span><span class="s3">,</span>
        <span class="s1">max_length</span><span class="s3">=</span><span class="s1">max_length</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s5"># (input_value: Any, /) -&gt; Any</span>
<span class="s1">NoInfoValidatorFunction </span><span class="s3">= </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Any</span><span class="s3">], </span><span class="s1">Any</span><span class="s3">]</span>


<span class="s2">class </span><span class="s1">NoInfoValidatorFunctionSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'no-info'</span><span class="s3">]</span>
    <span class="s1">function</span><span class="s3">: </span><span class="s1">NoInfoValidatorFunction</span>


<span class="s5"># (input_value: Any, info: ValidationInfo, /) -&gt; Any</span>
<span class="s1">WithInfoValidatorFunction </span><span class="s3">= </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">ValidationInfo</span><span class="s3">], </span><span class="s1">Any</span><span class="s3">]</span>


<span class="s2">class </span><span class="s1">WithInfoValidatorFunctionSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'with-info'</span><span class="s3">]]</span>
    <span class="s1">function</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">WithInfoValidatorFunction</span><span class="s3">]</span>
    <span class="s1">field_name</span><span class="s3">: </span><span class="s1">str</span>


<span class="s1">ValidationFunction </span><span class="s3">= </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">NoInfoValidatorFunctionSchema</span><span class="s3">, </span><span class="s1">WithInfoValidatorFunctionSchema</span><span class="s3">]</span>


<span class="s2">class </span><span class="s1">_ValidatorFunctionSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">function</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">ValidationFunction</span><span class="s3">]</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">class </span><span class="s1">BeforeValidatorFunctionSchema</span><span class="s3">(</span><span class="s1">_ValidatorFunctionSchema</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'function-before'</span><span class="s3">]]</span>
    <span class="s1">json_schema_input_schema</span><span class="s3">: </span><span class="s1">CoreSchema</span>


<span class="s2">def </span><span class="s1">no_info_before_validator_function</span><span class="s3">(</span>
    <span class="s1">function</span><span class="s3">: </span><span class="s1">NoInfoValidatorFunction</span><span class="s3">,</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">json_schema_input_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; BeforeValidatorFunctionSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that calls a validator function before validating, no `info` argument is provided, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    def fn(v: bytes) -&gt; str: 
        return v.decode() + 'world' 
 
    func_schema = core_schema.no_info_before_validator_function( 
        function=fn, schema=core_schema.str_schema() 
    ) 
    schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)}) 
 
    v = SchemaValidator(schema) 
    assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'} 
    ``` 
 
    Args: 
        function: The validator function to call 
        schema: The schema to validate the output of the validator function 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'function-before'</span><span class="s3">,</span>
        <span class="s1">function</span><span class="s3">={</span><span class="s6">'type'</span><span class="s3">: </span><span class="s6">'no-info'</span><span class="s3">, </span><span class="s6">'function'</span><span class="s3">: </span><span class="s1">function</span><span class="s3">},</span>
        <span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">json_schema_input_schema</span><span class="s3">=</span><span class="s1">json_schema_input_schema</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">with_info_before_validator_function</span><span class="s3">(</span>
    <span class="s1">function</span><span class="s3">: </span><span class="s1">WithInfoValidatorFunction</span><span class="s3">,</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">field_name</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">json_schema_input_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; BeforeValidatorFunctionSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that calls a validator function before validation, the function is called with 
    an `info` argument, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    def fn(v: bytes, info: core_schema.ValidationInfo) -&gt; str: 
        assert info.data is not None 
        assert info.field_name is not None 
        return v.decode() + 'world' 
 
    func_schema = core_schema.with_info_before_validator_function( 
        function=fn, schema=core_schema.str_schema(), field_name='a' 
    ) 
    schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)}) 
 
    v = SchemaValidator(schema) 
    assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'} 
    ``` 
 
    Args: 
        function: The validator function to call 
        field_name: The name of the field 
        schema: The schema to validate the output of the validator function 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'function-before'</span><span class="s3">,</span>
        <span class="s1">function</span><span class="s3">=</span><span class="s1">_dict_not_none</span><span class="s3">(</span><span class="s1">type</span><span class="s3">=</span><span class="s6">'with-info'</span><span class="s3">, </span><span class="s1">function</span><span class="s3">=</span><span class="s1">function</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">=</span><span class="s1">field_name</span><span class="s3">),</span>
        <span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">json_schema_input_schema</span><span class="s3">=</span><span class="s1">json_schema_input_schema</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">AfterValidatorFunctionSchema</span><span class="s3">(</span><span class="s1">_ValidatorFunctionSchema</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'function-after'</span><span class="s3">]]</span>


<span class="s2">def </span><span class="s1">no_info_after_validator_function</span><span class="s3">(</span>
    <span class="s1">function</span><span class="s3">: </span><span class="s1">NoInfoValidatorFunction</span><span class="s3">,</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">json_schema_input_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; AfterValidatorFunctionSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that calls a validator function after validating, no `info` argument is provided, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    def fn(v: str) -&gt; str: 
        return v + 'world' 
 
    func_schema = core_schema.no_info_after_validator_function(fn, core_schema.str_schema()) 
    schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)}) 
 
    v = SchemaValidator(schema) 
    assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'} 
    ``` 
 
    Args: 
        function: The validator function to call after the schema is validated 
        schema: The schema to validate before the validator function 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'function-after'</span><span class="s3">,</span>
        <span class="s1">function</span><span class="s3">={</span><span class="s6">'type'</span><span class="s3">: </span><span class="s6">'no-info'</span><span class="s3">, </span><span class="s6">'function'</span><span class="s3">: </span><span class="s1">function</span><span class="s3">},</span>
        <span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">json_schema_input_schema</span><span class="s3">=</span><span class="s1">json_schema_input_schema</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">with_info_after_validator_function</span><span class="s3">(</span>
    <span class="s1">function</span><span class="s3">: </span><span class="s1">WithInfoValidatorFunction</span><span class="s3">,</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">field_name</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; AfterValidatorFunctionSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that calls a validator function after validation, the function is called with 
    an `info` argument, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    def fn(v: str, info: core_schema.ValidationInfo) -&gt; str: 
        assert info.data is not None 
        assert info.field_name is not None 
        return v + 'world' 
 
    func_schema = core_schema.with_info_after_validator_function( 
        function=fn, schema=core_schema.str_schema(), field_name='a' 
    ) 
    schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)}) 
 
    v = SchemaValidator(schema) 
    assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'} 
    ``` 
 
    Args: 
        function: The validator function to call after the schema is validated 
        schema: The schema to validate before the validator function 
        field_name: The name of the field this validators is applied to, if any 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'function-after'</span><span class="s3">,</span>
        <span class="s1">function</span><span class="s3">=</span><span class="s1">_dict_not_none</span><span class="s3">(</span><span class="s1">type</span><span class="s3">=</span><span class="s6">'with-info'</span><span class="s3">, </span><span class="s1">function</span><span class="s3">=</span><span class="s1">function</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">=</span><span class="s1">field_name</span><span class="s3">),</span>
        <span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">ValidatorFunctionWrapHandler</span><span class="s3">(</span><span class="s1">Protocol</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">input_value</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">outer_location</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, /) </span><span class="s1">-&gt; Any</span><span class="s3">:  </span><span class="s5"># pragma: no cover</span>
        <span class="s3">...</span>


<span class="s5"># (input_value: Any, validator: ValidatorFunctionWrapHandler, /) -&gt; Any</span>
<span class="s1">NoInfoWrapValidatorFunction </span><span class="s3">= </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">ValidatorFunctionWrapHandler</span><span class="s3">], </span><span class="s1">Any</span><span class="s3">]</span>


<span class="s2">class </span><span class="s1">NoInfoWrapValidatorFunctionSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'no-info'</span><span class="s3">]</span>
    <span class="s1">function</span><span class="s3">: </span><span class="s1">NoInfoWrapValidatorFunction</span>


<span class="s5"># (input_value: Any, validator: ValidatorFunctionWrapHandler, info: ValidationInfo, /) -&gt; Any</span>
<span class="s1">WithInfoWrapValidatorFunction </span><span class="s3">= </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">ValidatorFunctionWrapHandler</span><span class="s3">, </span><span class="s1">ValidationInfo</span><span class="s3">], </span><span class="s1">Any</span><span class="s3">]</span>


<span class="s2">class </span><span class="s1">WithInfoWrapValidatorFunctionSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'with-info'</span><span class="s3">]]</span>
    <span class="s1">function</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">WithInfoWrapValidatorFunction</span><span class="s3">]</span>
    <span class="s1">field_name</span><span class="s3">: </span><span class="s1">str</span>


<span class="s1">WrapValidatorFunction </span><span class="s3">= </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">NoInfoWrapValidatorFunctionSchema</span><span class="s3">, </span><span class="s1">WithInfoWrapValidatorFunctionSchema</span><span class="s3">]</span>


<span class="s2">class </span><span class="s1">WrapValidatorFunctionSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'function-wrap'</span><span class="s3">]]</span>
    <span class="s1">function</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">WrapValidatorFunction</span><span class="s3">]</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">json_schema_input_schema</span><span class="s3">: </span><span class="s1">CoreSchema</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">no_info_wrap_validator_function</span><span class="s3">(</span>
    <span class="s1">function</span><span class="s3">: </span><span class="s1">NoInfoWrapValidatorFunction</span><span class="s3">,</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">json_schema_input_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; WrapValidatorFunctionSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema which calls a function with a `validator` callable argument which can 
    optionally be used to call inner validation with the function logic, this is much like the 
    &quot;onion&quot; implementation of middleware in many popular web frameworks, no `info` argument is passed, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    def fn( 
        v: str, 
        validator: core_schema.ValidatorFunctionWrapHandler, 
    ) -&gt; str: 
        return validator(input_value=v) + 'world' 
 
    schema = core_schema.no_info_wrap_validator_function( 
        function=fn, schema=core_schema.str_schema() 
    ) 
    v = SchemaValidator(schema) 
    assert v.validate_python('hello ') == 'hello world' 
    ``` 
 
    Args: 
        function: The validator function to call 
        schema: The schema to validate the output of the validator function 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'function-wrap'</span><span class="s3">,</span>
        <span class="s1">function</span><span class="s3">={</span><span class="s6">'type'</span><span class="s3">: </span><span class="s6">'no-info'</span><span class="s3">, </span><span class="s6">'function'</span><span class="s3">: </span><span class="s1">function</span><span class="s3">},</span>
        <span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">,</span>
        <span class="s1">json_schema_input_schema</span><span class="s3">=</span><span class="s1">json_schema_input_schema</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">with_info_wrap_validator_function</span><span class="s3">(</span>
    <span class="s1">function</span><span class="s3">: </span><span class="s1">WithInfoWrapValidatorFunction</span><span class="s3">,</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">field_name</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">json_schema_input_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; WrapValidatorFunctionSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema which calls a function with a `validator` callable argument which can 
    optionally be used to call inner validation with the function logic, this is much like the 
    &quot;onion&quot; implementation of middleware in many popular web frameworks, an `info` argument is also passed, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    def fn( 
        v: str, 
        validator: core_schema.ValidatorFunctionWrapHandler, 
        info: core_schema.ValidationInfo, 
    ) -&gt; str: 
        return validator(input_value=v) + 'world' 
 
    schema = core_schema.with_info_wrap_validator_function( 
        function=fn, schema=core_schema.str_schema() 
    ) 
    v = SchemaValidator(schema) 
    assert v.validate_python('hello ') == 'hello world' 
    ``` 
 
    Args: 
        function: The validator function to call 
        schema: The schema to validate the output of the validator function 
        field_name: The name of the field this validators is applied to, if any 
        json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'function-wrap'</span><span class="s3">,</span>
        <span class="s1">function</span><span class="s3">=</span><span class="s1">_dict_not_none</span><span class="s3">(</span><span class="s1">type</span><span class="s3">=</span><span class="s6">'with-info'</span><span class="s3">, </span><span class="s1">function</span><span class="s3">=</span><span class="s1">function</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">=</span><span class="s1">field_name</span><span class="s3">),</span>
        <span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">,</span>
        <span class="s1">json_schema_input_schema</span><span class="s3">=</span><span class="s1">json_schema_input_schema</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">PlainValidatorFunctionSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'function-plain'</span><span class="s3">]]</span>
    <span class="s1">function</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">ValidationFunction</span><span class="s3">]</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">json_schema_input_schema</span><span class="s3">: </span><span class="s1">CoreSchema</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">no_info_plain_validator_function</span><span class="s3">(</span>
    <span class="s1">function</span><span class="s3">: </span><span class="s1">NoInfoValidatorFunction</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">json_schema_input_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; PlainValidatorFunctionSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that uses the provided function for validation, no `info` argument is passed, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    def fn(v: str) -&gt; str: 
        assert 'hello' in v 
        return v + 'world' 
 
    schema = core_schema.no_info_plain_validator_function(function=fn) 
    v = SchemaValidator(schema) 
    assert v.validate_python('hello ') == 'hello world' 
    ``` 
 
    Args: 
        function: The validator function to call 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'function-plain'</span><span class="s3">,</span>
        <span class="s1">function</span><span class="s3">={</span><span class="s6">'type'</span><span class="s3">: </span><span class="s6">'no-info'</span><span class="s3">, </span><span class="s6">'function'</span><span class="s3">: </span><span class="s1">function</span><span class="s3">},</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">json_schema_input_schema</span><span class="s3">=</span><span class="s1">json_schema_input_schema</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">with_info_plain_validator_function</span><span class="s3">(</span>
    <span class="s1">function</span><span class="s3">: </span><span class="s1">WithInfoValidatorFunction</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">field_name</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">json_schema_input_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; PlainValidatorFunctionSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that uses the provided function for validation, an `info` argument is passed, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    def fn(v: str, info: core_schema.ValidationInfo) -&gt; str: 
        assert 'hello' in v 
        return v + 'world' 
 
    schema = core_schema.with_info_plain_validator_function(function=fn) 
    v = SchemaValidator(schema) 
    assert v.validate_python('hello ') == 'hello world' 
    ``` 
 
    Args: 
        function: The validator function to call 
        field_name: The name of the field this validators is applied to, if any 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'function-plain'</span><span class="s3">,</span>
        <span class="s1">function</span><span class="s3">=</span><span class="s1">_dict_not_none</span><span class="s3">(</span><span class="s1">type</span><span class="s3">=</span><span class="s6">'with-info'</span><span class="s3">, </span><span class="s1">function</span><span class="s3">=</span><span class="s1">function</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">=</span><span class="s1">field_name</span><span class="s3">),</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">json_schema_input_schema</span><span class="s3">=</span><span class="s1">json_schema_input_schema</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">WithDefaultSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'default'</span><span class="s3">]]</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]</span>
    <span class="s1">default</span><span class="s3">: </span><span class="s1">Any</span>
    <span class="s1">default_factory</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">Callable</span><span class="s3">[[], </span><span class="s1">Any</span><span class="s3">], </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]], </span><span class="s1">Any</span><span class="s3">]]</span>
    <span class="s1">default_factory_takes_data</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">on_error</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'raise'</span><span class="s3">, </span><span class="s6">'omit'</span><span class="s3">, </span><span class="s6">'default'</span><span class="s3">]  </span><span class="s5"># default: 'raise'</span>
    <span class="s1">validate_default</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default: False</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">with_default_schema</span><span class="s3">(</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">default</span><span class="s3">: </span><span class="s1">Any </span><span class="s3">= </span><span class="s1">PydanticUndefined</span><span class="s3">,</span>
    <span class="s1">default_factory</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">Callable</span><span class="s3">[[], </span><span class="s1">Any</span><span class="s3">], </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]], </span><span class="s1">Any</span><span class="s3">], </span><span class="s2">None</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">default_factory_takes_data</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">on_error</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'raise'</span><span class="s3">, </span><span class="s6">'omit'</span><span class="s3">, </span><span class="s6">'default'</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">validate_default</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; WithDefaultSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that adds a default value to the given schema, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.with_default_schema(core_schema.str_schema(), default='hello') 
    wrapper_schema = core_schema.typed_dict_schema( 
        {'a': core_schema.typed_dict_field(schema)} 
    ) 
    v = SchemaValidator(wrapper_schema) 
    assert v.validate_python({}) == v.validate_python({'a': 'hello'}) 
    ``` 
 
    Args: 
        schema: The schema to add a default value to 
        default: The default value to use 
        default_factory: A callable that returns the default value to use 
        default_factory_takes_data: Whether the default factory takes a validated data argument 
        on_error: What to do if the schema validation fails. One of 'raise', 'omit', 'default' 
        validate_default: Whether the default value should be validated 
        strict: Whether the underlying schema should be validated with strict mode 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'default'</span><span class="s3">,</span>
        <span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">,</span>
        <span class="s1">default_factory</span><span class="s3">=</span><span class="s1">default_factory</span><span class="s3">,</span>
        <span class="s1">default_factory_takes_data</span><span class="s3">=</span><span class="s1">default_factory_takes_data</span><span class="s3">,</span>
        <span class="s1">on_error</span><span class="s3">=</span><span class="s1">on_error</span><span class="s3">,</span>
        <span class="s1">validate_default</span><span class="s3">=</span><span class="s1">validate_default</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">if </span><span class="s1">default </span><span class="s2">is not </span><span class="s1">PydanticUndefined</span><span class="s3">:</span>
        <span class="s1">s</span><span class="s3">[</span><span class="s6">'default'</span><span class="s3">] = </span><span class="s1">default</span>
    <span class="s2">return </span><span class="s1">s</span>


<span class="s2">class </span><span class="s1">NullableSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'nullable'</span><span class="s3">]]</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">nullable_schema</span><span class="s3">(</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; NullableSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a nullable value, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.nullable_schema(core_schema.str_schema()) 
    v = SchemaValidator(schema) 
    assert v.validate_python(None) is None 
    ``` 
 
    Args: 
        schema: The schema to wrap 
        strict: Whether the underlying schema should be validated with strict mode 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'nullable'</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">UnionSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'union'</span><span class="s3">]]</span>
    <span class="s1">choices</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">, </span><span class="s1">str</span><span class="s3">]]]]</span>
    <span class="s5"># default true, whether to automatically collapse unions with one element to the inner validator</span>
    <span class="s1">auto_collapse</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">custom_error_type</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">custom_error_message</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">custom_error_context</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">, </span><span class="s1">float</span><span class="s3">]]</span>
    <span class="s1">mode</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'smart'</span><span class="s3">, </span><span class="s6">'left_to_right'</span><span class="s3">]  </span><span class="s5"># default: 'smart'</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">union_schema</span><span class="s3">(</span>
    <span class="s1">choices</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">, </span><span class="s1">str</span><span class="s3">]],</span>
    <span class="s3">*,</span>
    <span class="s1">auto_collapse</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">custom_error_type</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">custom_error_message</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">custom_error_context</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">str </span><span class="s3">| </span><span class="s1">int</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">mode</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'smart'</span><span class="s3">, </span><span class="s6">'left_to_right'</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; UnionSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a union value, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.union_schema([core_schema.str_schema(), core_schema.int_schema()]) 
    v = SchemaValidator(schema) 
    assert v.validate_python('hello') == 'hello' 
    assert v.validate_python(1) == 1 
    ``` 
 
    Args: 
        choices: The schemas to match. If a tuple, the second item is used as the label for the case. 
        auto_collapse: whether to automatically collapse unions with one element to the inner validator, default true 
        custom_error_type: The custom error type to use if the validation fails 
        custom_error_message: The custom error message to use if the validation fails 
        custom_error_context: The custom error context to use if the validation fails 
        mode: How to select which choice to return 
            * `smart` (default) will try to return the choice which is the closest match to the input value 
            * `left_to_right` will return the first choice in `choices` which succeeds validation 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'union'</span><span class="s3">,</span>
        <span class="s1">choices</span><span class="s3">=</span><span class="s1">choices</span><span class="s3">,</span>
        <span class="s1">auto_collapse</span><span class="s3">=</span><span class="s1">auto_collapse</span><span class="s3">,</span>
        <span class="s1">custom_error_type</span><span class="s3">=</span><span class="s1">custom_error_type</span><span class="s3">,</span>
        <span class="s1">custom_error_message</span><span class="s3">=</span><span class="s1">custom_error_message</span><span class="s3">,</span>
        <span class="s1">custom_error_context</span><span class="s3">=</span><span class="s1">custom_error_context</span><span class="s3">,</span>
        <span class="s1">mode</span><span class="s3">=</span><span class="s1">mode</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">TaggedUnionSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'tagged-union'</span><span class="s3">]]</span>
    <span class="s1">choices</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">dict</span><span class="s3">[</span><span class="s1">Hashable</span><span class="s3">, </span><span class="s1">CoreSchema</span><span class="s3">]]</span>
    <span class="s1">discriminator</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">list</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">]], </span><span class="s1">list</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">]]], </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Any</span><span class="s3">], </span><span class="s1">Hashable</span><span class="s3">]]]</span>
    <span class="s1">custom_error_type</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">custom_error_message</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">custom_error_context</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">, </span><span class="s1">float</span><span class="s3">]]</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">from_attributes</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default: True</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">tagged_union_schema</span><span class="s3">(</span>
    <span class="s1">choices</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">CoreSchema</span><span class="s3">],</span>
    <span class="s1">discriminator</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s1">list</span><span class="s3">[</span><span class="s1">str </span><span class="s3">| </span><span class="s1">int</span><span class="s3">] | </span><span class="s1">list</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">str </span><span class="s3">| </span><span class="s1">int</span><span class="s3">]] | </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Any</span><span class="s3">], </span><span class="s1">Any</span><span class="s3">],</span>
    <span class="s3">*,</span>
    <span class="s1">custom_error_type</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">custom_error_message</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">custom_error_context</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">int </span><span class="s3">| </span><span class="s1">str </span><span class="s3">| </span><span class="s1">float</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">from_attributes</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; TaggedUnionSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a tagged union value, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    apple_schema = core_schema.typed_dict_schema( 
        { 
            'foo': core_schema.typed_dict_field(core_schema.str_schema()), 
            'bar': core_schema.typed_dict_field(core_schema.int_schema()), 
        } 
    ) 
    banana_schema = core_schema.typed_dict_schema( 
        { 
            'foo': core_schema.typed_dict_field(core_schema.str_schema()), 
            'spam': core_schema.typed_dict_field( 
                core_schema.list_schema(items_schema=core_schema.int_schema()) 
            ), 
        } 
    ) 
    schema = core_schema.tagged_union_schema( 
        choices={ 
            'apple': apple_schema, 
            'banana': banana_schema, 
        }, 
        discriminator='foo', 
    ) 
    v = SchemaValidator(schema) 
    assert v.validate_python({'foo': 'apple', 'bar': '123'}) == {'foo': 'apple', 'bar': 123} 
    assert v.validate_python({'foo': 'banana', 'spam': [1, 2, 3]}) == { 
        'foo': 'banana', 
        'spam': [1, 2, 3], 
    } 
    ``` 
 
    Args: 
        choices: The schemas to match 
            When retrieving a schema from `choices` using the discriminator value, if the value is a str, 
            it should be fed back into the `choices` map until a schema is obtained 
            (This approach is to prevent multiple ownership of a single schema in Rust) 
        discriminator: The discriminator to use to determine the schema to use 
            * If `discriminator` is a str, it is the name of the attribute to use as the discriminator 
            * If `discriminator` is a list of int/str, it should be used as a &quot;path&quot; to access the discriminator 
            * If `discriminator` is a list of lists, each inner list is a path, and the first path that exists is used 
            * If `discriminator` is a callable, it should return the discriminator when called on the value to validate; 
              the callable can return `None` to indicate that there is no matching discriminator present on the input 
        custom_error_type: The custom error type to use if the validation fails 
        custom_error_message: The custom error message to use if the validation fails 
        custom_error_context: The custom error context to use if the validation fails 
        strict: Whether the underlying schemas should be validated with strict mode 
        from_attributes: Whether to use the attributes of the object to retrieve the discriminator value 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'tagged-union'</span><span class="s3">,</span>
        <span class="s1">choices</span><span class="s3">=</span><span class="s1">choices</span><span class="s3">,</span>
        <span class="s1">discriminator</span><span class="s3">=</span><span class="s1">discriminator</span><span class="s3">,</span>
        <span class="s1">custom_error_type</span><span class="s3">=</span><span class="s1">custom_error_type</span><span class="s3">,</span>
        <span class="s1">custom_error_message</span><span class="s3">=</span><span class="s1">custom_error_message</span><span class="s3">,</span>
        <span class="s1">custom_error_context</span><span class="s3">=</span><span class="s1">custom_error_context</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">from_attributes</span><span class="s3">=</span><span class="s1">from_attributes</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">ChainSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'chain'</span><span class="s3">]]</span>
    <span class="s1">steps</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]]</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">chain_schema</span><span class="s3">(</span>
    <span class="s1">steps</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">],</span>
    <span class="s3">*,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ChainSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that chains the provided validation schemas, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    def fn(v: str, info: core_schema.ValidationInfo) -&gt; str: 
        assert 'hello' in v 
        return v + ' world' 
 
    fn_schema = core_schema.with_info_plain_validator_function(function=fn) 
    schema = core_schema.chain_schema( 
        [fn_schema, fn_schema, fn_schema, core_schema.str_schema()] 
    ) 
    v = SchemaValidator(schema) 
    assert v.validate_python('hello') == 'hello world world world' 
    ``` 
 
    Args: 
        steps: The schemas to chain 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span><span class="s1">type</span><span class="s3">=</span><span class="s6">'chain'</span><span class="s3">, </span><span class="s1">steps</span><span class="s3">=</span><span class="s1">steps</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">LaxOrStrictSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'lax-or-strict'</span><span class="s3">]]</span>
    <span class="s1">lax_schema</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]</span>
    <span class="s1">strict_schema</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">lax_or_strict_schema</span><span class="s3">(</span>
    <span class="s1">lax_schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s1">strict_schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; LaxOrStrictSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that uses the lax or strict schema, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    def fn(v: str, info: core_schema.ValidationInfo) -&gt; str: 
        assert 'hello' in v 
        return v + ' world' 
 
    lax_schema = core_schema.int_schema(strict=False) 
    strict_schema = core_schema.int_schema(strict=True) 
 
    schema = core_schema.lax_or_strict_schema( 
        lax_schema=lax_schema, strict_schema=strict_schema, strict=True 
    ) 
    v = SchemaValidator(schema) 
    assert v.validate_python(123) == 123 
 
    schema = core_schema.lax_or_strict_schema( 
        lax_schema=lax_schema, strict_schema=strict_schema, strict=False 
    ) 
    v = SchemaValidator(schema) 
    assert v.validate_python('123') == 123 
    ``` 
 
    Args: 
        lax_schema: The lax schema to use 
        strict_schema: The strict schema to use 
        strict: Whether the strict schema should be used 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'lax-or-strict'</span><span class="s3">,</span>
        <span class="s1">lax_schema</span><span class="s3">=</span><span class="s1">lax_schema</span><span class="s3">,</span>
        <span class="s1">strict_schema</span><span class="s3">=</span><span class="s1">strict_schema</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">JsonOrPythonSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'json-or-python'</span><span class="s3">]]</span>
    <span class="s1">json_schema</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]</span>
    <span class="s1">python_schema</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">json_or_python_schema</span><span class="s3">(</span>
    <span class="s1">json_schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s1">python_schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; JsonOrPythonSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that uses the Json or Python schema depending on the input: 
 
    ```py 
    from pydantic_core import SchemaValidator, ValidationError, core_schema 
 
    v = SchemaValidator( 
        core_schema.json_or_python_schema( 
            json_schema=core_schema.int_schema(), 
            python_schema=core_schema.int_schema(strict=True), 
        ) 
    ) 
 
    assert v.validate_json('&quot;123&quot;') == 123 
 
    try: 
        v.validate_python('123') 
    except ValidationError: 
        pass 
    else: 
        raise AssertionError('Validation should have failed') 
    ``` 
 
    Args: 
        json_schema: The schema to use for Json inputs 
        python_schema: The schema to use for Python inputs 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'json-or-python'</span><span class="s3">,</span>
        <span class="s1">json_schema</span><span class="s3">=</span><span class="s1">json_schema</span><span class="s3">,</span>
        <span class="s1">python_schema</span><span class="s3">=</span><span class="s1">python_schema</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">TypedDictField</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'typed-dict-field'</span><span class="s3">]]</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]</span>
    <span class="s1">required</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">validation_alias</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">list</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">]], </span><span class="s1">list</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">]]]]</span>
    <span class="s1">serialization_alias</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">serialization_exclude</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default: False</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">typed_dict_field</span><span class="s3">(</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">required</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">validation_alias</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s1">list</span><span class="s3">[</span><span class="s1">str </span><span class="s3">| </span><span class="s1">int</span><span class="s3">] | </span><span class="s1">list</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">str </span><span class="s3">| </span><span class="s1">int</span><span class="s3">]] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization_alias</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization_exclude</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; TypedDictField</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a typed dict field, e.g.: 
 
    ```py 
    from pydantic_core import core_schema 
 
    field = core_schema.typed_dict_field(schema=core_schema.int_schema(), required=True) 
    ``` 
 
    Args: 
        schema: The schema to use for the field 
        required: Whether the field is required, otherwise uses the value from `total` on the typed dict 
        validation_alias: The alias(es) to use to find the field in the validation data 
        serialization_alias: The alias to use as a key when serializing 
        serialization_exclude: Whether to exclude the field when serializing 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'typed-dict-field'</span><span class="s3">,</span>
        <span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">,</span>
        <span class="s1">required</span><span class="s3">=</span><span class="s1">required</span><span class="s3">,</span>
        <span class="s1">validation_alias</span><span class="s3">=</span><span class="s1">validation_alias</span><span class="s3">,</span>
        <span class="s1">serialization_alias</span><span class="s3">=</span><span class="s1">serialization_alias</span><span class="s3">,</span>
        <span class="s1">serialization_exclude</span><span class="s3">=</span><span class="s1">serialization_exclude</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">TypedDictSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'typed-dict'</span><span class="s3">]]</span>
    <span class="s1">fields</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">TypedDictField</span><span class="s3">]]</span>
    <span class="s1">cls</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">cls_name</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">computed_fields</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">ComputedField</span><span class="s3">]</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">extras_schema</span><span class="s3">: </span><span class="s1">CoreSchema</span>
    <span class="s5"># all these values can be set via config, equivalent fields have `typed_dict_` prefix</span>
    <span class="s1">extra_behavior</span><span class="s3">: </span><span class="s1">ExtraBehavior</span>
    <span class="s1">total</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default: True</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>
    <span class="s1">config</span><span class="s3">: </span><span class="s1">CoreConfig</span>


<span class="s2">def </span><span class="s1">typed_dict_schema</span><span class="s3">(</span>
    <span class="s1">fields</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">TypedDictField</span><span class="s3">],</span>
    <span class="s3">*,</span>
    <span class="s1">cls</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">cls_name</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">computed_fields</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">ComputedField</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">extras_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">extra_behavior</span><span class="s3">: </span><span class="s1">ExtraBehavior </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">total</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">config</span><span class="s3">: </span><span class="s1">CoreConfig </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; TypedDictSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a typed dict, e.g.: 
 
    ```py 
    from typing_extensions import TypedDict 
 
    from pydantic_core import SchemaValidator, core_schema 
 
    class MyTypedDict(TypedDict): 
        a: str 
 
    wrapper_schema = core_schema.typed_dict_schema( 
        {'a': core_schema.typed_dict_field(core_schema.str_schema())}, cls=MyTypedDict 
    ) 
    v = SchemaValidator(wrapper_schema) 
    assert v.validate_python({'a': 'hello'}) == {'a': 'hello'} 
    ``` 
 
    Args: 
        fields: The fields to use for the typed dict 
        cls: The class to use for the typed dict 
        cls_name: The name to use in error locations. Falls back to `cls.__name__`, or the validator name if no class 
            is provided. 
        computed_fields: Computed fields to use when serializing the model, only applies when directly inside a model 
        strict: Whether the typed dict is strict 
        extras_schema: The extra validator to use for the typed dict 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        extra_behavior: The extra behavior to use for the typed dict 
        total: Whether the typed dict is total, otherwise uses `typed_dict_total` from config 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'typed-dict'</span><span class="s3">,</span>
        <span class="s1">fields</span><span class="s3">=</span><span class="s1">fields</span><span class="s3">,</span>
        <span class="s1">cls</span><span class="s3">=</span><span class="s1">cls</span><span class="s3">,</span>
        <span class="s1">cls_name</span><span class="s3">=</span><span class="s1">cls_name</span><span class="s3">,</span>
        <span class="s1">computed_fields</span><span class="s3">=</span><span class="s1">computed_fields</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">extras_schema</span><span class="s3">=</span><span class="s1">extras_schema</span><span class="s3">,</span>
        <span class="s1">extra_behavior</span><span class="s3">=</span><span class="s1">extra_behavior</span><span class="s3">,</span>
        <span class="s1">total</span><span class="s3">=</span><span class="s1">total</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
        <span class="s1">config</span><span class="s3">=</span><span class="s1">config</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">ModelField</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'model-field'</span><span class="s3">]]</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]</span>
    <span class="s1">validation_alias</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">list</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">]], </span><span class="s1">list</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">]]]]</span>
    <span class="s1">serialization_alias</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">serialization_exclude</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default: False</span>
    <span class="s1">frozen</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">model_field</span><span class="s3">(</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">validation_alias</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s1">list</span><span class="s3">[</span><span class="s1">str </span><span class="s3">| </span><span class="s1">int</span><span class="s3">] | </span><span class="s1">list</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">str </span><span class="s3">| </span><span class="s1">int</span><span class="s3">]] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization_alias</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization_exclude</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">frozen</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ModelField</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema for a model field, e.g.: 
 
    ```py 
    from pydantic_core import core_schema 
 
    field = core_schema.model_field(schema=core_schema.int_schema()) 
    ``` 
 
    Args: 
        schema: The schema to use for the field 
        validation_alias: The alias(es) to use to find the field in the validation data 
        serialization_alias: The alias to use as a key when serializing 
        serialization_exclude: Whether to exclude the field when serializing 
        frozen: Whether the field is frozen 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'model-field'</span><span class="s3">,</span>
        <span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">,</span>
        <span class="s1">validation_alias</span><span class="s3">=</span><span class="s1">validation_alias</span><span class="s3">,</span>
        <span class="s1">serialization_alias</span><span class="s3">=</span><span class="s1">serialization_alias</span><span class="s3">,</span>
        <span class="s1">serialization_exclude</span><span class="s3">=</span><span class="s1">serialization_exclude</span><span class="s3">,</span>
        <span class="s1">frozen</span><span class="s3">=</span><span class="s1">frozen</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">ModelFieldsSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'model-fields'</span><span class="s3">]]</span>
    <span class="s1">fields</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">ModelField</span><span class="s3">]]</span>
    <span class="s1">model_name</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">computed_fields</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">ComputedField</span><span class="s3">]</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">extras_schema</span><span class="s3">: </span><span class="s1">CoreSchema</span>
    <span class="s1">extras_keys_schema</span><span class="s3">: </span><span class="s1">CoreSchema</span>
    <span class="s1">extra_behavior</span><span class="s3">: </span><span class="s1">ExtraBehavior</span>
    <span class="s1">from_attributes</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">model_fields_schema</span><span class="s3">(</span>
    <span class="s1">fields</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">ModelField</span><span class="s3">],</span>
    <span class="s3">*,</span>
    <span class="s1">model_name</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">computed_fields</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">ComputedField</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">extras_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">extras_keys_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">extra_behavior</span><span class="s3">: </span><span class="s1">ExtraBehavior </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">from_attributes</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ModelFieldsSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches the fields of a Pydantic model, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    wrapper_schema = core_schema.model_fields_schema( 
        {'a': core_schema.model_field(core_schema.str_schema())} 
    ) 
    v = SchemaValidator(wrapper_schema) 
    print(v.validate_python({'a': 'hello'})) 
    #&gt; ({'a': 'hello'}, None, {'a'}) 
    ``` 
 
    Args: 
        fields: The fields of the model 
        model_name: The name of the model, used for error messages, defaults to &quot;Model&quot; 
        computed_fields: Computed fields to use when serializing the model, only applies when directly inside a model 
        strict: Whether the model is strict 
        extras_schema: The schema to use when validating extra input data 
        extras_keys_schema: The schema to use when validating the keys of extra input data 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        extra_behavior: The extra behavior to use for the model fields 
        from_attributes: Whether the model fields should be populated from attributes 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'model-fields'</span><span class="s3">,</span>
        <span class="s1">fields</span><span class="s3">=</span><span class="s1">fields</span><span class="s3">,</span>
        <span class="s1">model_name</span><span class="s3">=</span><span class="s1">model_name</span><span class="s3">,</span>
        <span class="s1">computed_fields</span><span class="s3">=</span><span class="s1">computed_fields</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">extras_schema</span><span class="s3">=</span><span class="s1">extras_schema</span><span class="s3">,</span>
        <span class="s1">extras_keys_schema</span><span class="s3">=</span><span class="s1">extras_keys_schema</span><span class="s3">,</span>
        <span class="s1">extra_behavior</span><span class="s3">=</span><span class="s1">extra_behavior</span><span class="s3">,</span>
        <span class="s1">from_attributes</span><span class="s3">=</span><span class="s1">from_attributes</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">ModelSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'model'</span><span class="s3">]]</span>
    <span class="s1">cls</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">type</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]]</span>
    <span class="s1">generic_origin</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]</span>
    <span class="s1">custom_init</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">root_model</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">post_init</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">revalidate_instances</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'always'</span><span class="s3">, </span><span class="s6">'never'</span><span class="s3">, </span><span class="s6">'subclass-instances'</span><span class="s3">]  </span><span class="s5"># default: 'never'</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">frozen</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">extra_behavior</span><span class="s3">: </span><span class="s1">ExtraBehavior</span>
    <span class="s1">config</span><span class="s3">: </span><span class="s1">CoreConfig</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">model_schema</span><span class="s3">(</span>
    <span class="s1">cls</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">],</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">generic_origin</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">custom_init</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">root_model</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">post_init</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">revalidate_instances</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'always'</span><span class="s3">, </span><span class="s6">'never'</span><span class="s3">, </span><span class="s6">'subclass-instances'</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">frozen</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">extra_behavior</span><span class="s3">: </span><span class="s1">ExtraBehavior </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">config</span><span class="s3">: </span><span class="s1">CoreConfig </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ModelSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    A model schema generally contains a typed-dict schema. 
    It will run the typed dict validator, then create a new class 
    and set the dict and fields set returned from the typed dict validator 
    to `__dict__` and `__pydantic_fields_set__` respectively. 
 
    Example: 
 
    ```py 
    from pydantic_core import CoreConfig, SchemaValidator, core_schema 
 
    class MyModel: 
        __slots__ = ( 
            '__dict__', 
            '__pydantic_fields_set__', 
            '__pydantic_extra__', 
            '__pydantic_private__', 
        ) 
 
    schema = core_schema.model_schema( 
        cls=MyModel, 
        config=CoreConfig(str_max_length=5), 
        schema=core_schema.model_fields_schema( 
            fields={'a': core_schema.model_field(core_schema.str_schema())}, 
        ), 
    ) 
    v = SchemaValidator(schema) 
    assert v.isinstance_python({'a': 'hello'}) is True 
    assert v.isinstance_python({'a': 'too long'}) is False 
    ``` 
 
    Args: 
        cls: The class to use for the model 
        schema: The schema to use for the model 
        generic_origin: The origin type used for this model, if it's a parametrized generic. Ex, 
            if this model schema represents `SomeModel[int]`, generic_origin is `SomeModel` 
        custom_init: Whether the model has a custom init method 
        root_model: Whether the model is a `RootModel` 
        post_init: The call after init to use for the model 
        revalidate_instances: whether instances of models and dataclasses (including subclass instances) 
            should re-validate defaults to config.revalidate_instances, else 'never' 
        strict: Whether the model is strict 
        frozen: Whether the model is frozen 
        extra_behavior: The extra behavior to use for the model, used in serialization 
        config: The config to use for the model 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'model'</span><span class="s3">,</span>
        <span class="s1">cls</span><span class="s3">=</span><span class="s1">cls</span><span class="s3">,</span>
        <span class="s1">generic_origin</span><span class="s3">=</span><span class="s1">generic_origin</span><span class="s3">,</span>
        <span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">,</span>
        <span class="s1">custom_init</span><span class="s3">=</span><span class="s1">custom_init</span><span class="s3">,</span>
        <span class="s1">root_model</span><span class="s3">=</span><span class="s1">root_model</span><span class="s3">,</span>
        <span class="s1">post_init</span><span class="s3">=</span><span class="s1">post_init</span><span class="s3">,</span>
        <span class="s1">revalidate_instances</span><span class="s3">=</span><span class="s1">revalidate_instances</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">frozen</span><span class="s3">=</span><span class="s1">frozen</span><span class="s3">,</span>
        <span class="s1">extra_behavior</span><span class="s3">=</span><span class="s1">extra_behavior</span><span class="s3">,</span>
        <span class="s1">config</span><span class="s3">=</span><span class="s1">config</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">DataclassField</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'dataclass-field'</span><span class="s3">]]</span>
    <span class="s1">name</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]</span>
    <span class="s1">kw_only</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default: True</span>
    <span class="s1">init</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default: True</span>
    <span class="s1">init_only</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default: False</span>
    <span class="s1">frozen</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default: False</span>
    <span class="s1">validation_alias</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">list</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">]], </span><span class="s1">list</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">]]]]</span>
    <span class="s1">serialization_alias</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">serialization_exclude</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default: False</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">dataclass_field</span><span class="s3">(</span>
    <span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">kw_only</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">init</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">init_only</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">validation_alias</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s1">list</span><span class="s3">[</span><span class="s1">str </span><span class="s3">| </span><span class="s1">int</span><span class="s3">] | </span><span class="s1">list</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">str </span><span class="s3">| </span><span class="s1">int</span><span class="s3">]] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization_alias</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization_exclude</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">frozen</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; DataclassField</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema for a dataclass field, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    field = core_schema.dataclass_field( 
        name='a', schema=core_schema.str_schema(), kw_only=False 
    ) 
    schema = core_schema.dataclass_args_schema('Foobar', [field]) 
    v = SchemaValidator(schema) 
    assert v.validate_python({'a': 'hello'}) == ({'a': 'hello'}, None) 
    ``` 
 
    Args: 
        name: The name to use for the argument parameter 
        schema: The schema to use for the argument parameter 
        kw_only: Whether the field can be set with a positional argument as well as a keyword argument 
        init: Whether the field should be validated during initialization 
        init_only: Whether the field should be omitted  from `__dict__` and passed to `__post_init__` 
        validation_alias: The alias(es) to use to find the field in the validation data 
        serialization_alias: The alias to use as a key when serializing 
        serialization_exclude: Whether to exclude the field when serializing 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        frozen: Whether the field is frozen 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'dataclass-field'</span><span class="s3">,</span>
        <span class="s1">name</span><span class="s3">=</span><span class="s1">name</span><span class="s3">,</span>
        <span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">,</span>
        <span class="s1">kw_only</span><span class="s3">=</span><span class="s1">kw_only</span><span class="s3">,</span>
        <span class="s1">init</span><span class="s3">=</span><span class="s1">init</span><span class="s3">,</span>
        <span class="s1">init_only</span><span class="s3">=</span><span class="s1">init_only</span><span class="s3">,</span>
        <span class="s1">validation_alias</span><span class="s3">=</span><span class="s1">validation_alias</span><span class="s3">,</span>
        <span class="s1">serialization_alias</span><span class="s3">=</span><span class="s1">serialization_alias</span><span class="s3">,</span>
        <span class="s1">serialization_exclude</span><span class="s3">=</span><span class="s1">serialization_exclude</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">frozen</span><span class="s3">=</span><span class="s1">frozen</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">DataclassArgsSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'dataclass-args'</span><span class="s3">]]</span>
    <span class="s1">dataclass_name</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]</span>
    <span class="s1">fields</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">DataclassField</span><span class="s3">]]</span>
    <span class="s1">computed_fields</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">ComputedField</span><span class="s3">]</span>
    <span class="s1">collect_init_only</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default: False</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>
    <span class="s1">extra_behavior</span><span class="s3">: </span><span class="s1">ExtraBehavior</span>


<span class="s2">def </span><span class="s1">dataclass_args_schema</span><span class="s3">(</span>
    <span class="s1">dataclass_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
    <span class="s1">fields</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">DataclassField</span><span class="s3">],</span>
    <span class="s3">*,</span>
    <span class="s1">computed_fields</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">ComputedField</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">collect_init_only</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">extra_behavior</span><span class="s3">: </span><span class="s1">ExtraBehavior </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; DataclassArgsSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema for validating dataclass arguments, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    field_a = core_schema.dataclass_field( 
        name='a', schema=core_schema.str_schema(), kw_only=False 
    ) 
    field_b = core_schema.dataclass_field( 
        name='b', schema=core_schema.bool_schema(), kw_only=False 
    ) 
    schema = core_schema.dataclass_args_schema('Foobar', [field_a, field_b]) 
    v = SchemaValidator(schema) 
    assert v.validate_python({'a': 'hello', 'b': True}) == ({'a': 'hello', 'b': True}, None) 
    ``` 
 
    Args: 
        dataclass_name: The name of the dataclass being validated 
        fields: The fields to use for the dataclass 
        computed_fields: Computed fields to use when serializing the dataclass 
        collect_init_only: Whether to collect init only fields into a dict to pass to `__post_init__` 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
        extra_behavior: How to handle extra fields 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'dataclass-args'</span><span class="s3">,</span>
        <span class="s1">dataclass_name</span><span class="s3">=</span><span class="s1">dataclass_name</span><span class="s3">,</span>
        <span class="s1">fields</span><span class="s3">=</span><span class="s1">fields</span><span class="s3">,</span>
        <span class="s1">computed_fields</span><span class="s3">=</span><span class="s1">computed_fields</span><span class="s3">,</span>
        <span class="s1">collect_init_only</span><span class="s3">=</span><span class="s1">collect_init_only</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
        <span class="s1">extra_behavior</span><span class="s3">=</span><span class="s1">extra_behavior</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">DataclassSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'dataclass'</span><span class="s3">]]</span>
    <span class="s1">cls</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">type</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]]</span>
    <span class="s1">generic_origin</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]</span>
    <span class="s1">fields</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]]</span>
    <span class="s1">cls_name</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">post_init</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default: False</span>
    <span class="s1">revalidate_instances</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'always'</span><span class="s3">, </span><span class="s6">'never'</span><span class="s3">, </span><span class="s6">'subclass-instances'</span><span class="s3">]  </span><span class="s5"># default: 'never'</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default: False</span>
    <span class="s1">frozen</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default False</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>
    <span class="s1">slots</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">config</span><span class="s3">: </span><span class="s1">CoreConfig</span>


<span class="s2">def </span><span class="s1">dataclass_schema</span><span class="s3">(</span>
    <span class="s1">cls</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">],</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s1">fields</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">str</span><span class="s3">],</span>
    <span class="s3">*,</span>
    <span class="s1">generic_origin</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">cls_name</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">post_init</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">revalidate_instances</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'always'</span><span class="s3">, </span><span class="s6">'never'</span><span class="s3">, </span><span class="s6">'subclass-instances'</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">frozen</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">slots</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">config</span><span class="s3">: </span><span class="s1">CoreConfig </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; DataclassSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema for a dataclass. As with `ModelSchema`, this schema can only be used as a field within 
    another schema, not as the root type. 
 
    Args: 
        cls: The dataclass type, used to perform subclass checks 
        schema: The schema to use for the dataclass fields 
        fields: Fields of the dataclass, this is used in serialization and in validation during re-validation 
            and while validating assignment 
        generic_origin: The origin type used for this dataclass, if it's a parametrized generic. Ex, 
            if this model schema represents `SomeDataclass[int]`, generic_origin is `SomeDataclass` 
        cls_name: The name to use in error locs, etc; this is useful for generics (default: `cls.__name__`) 
        post_init: Whether to call `__post_init__` after validation 
        revalidate_instances: whether instances of models and dataclasses (including subclass instances) 
            should re-validate defaults to config.revalidate_instances, else 'never' 
        strict: Whether to require an exact instance of `cls` 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
        frozen: Whether the dataclass is frozen 
        slots: Whether `slots=True` on the dataclass, means each field is assigned independently, rather than 
            simply setting `__dict__`, default false 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'dataclass'</span><span class="s3">,</span>
        <span class="s1">cls</span><span class="s3">=</span><span class="s1">cls</span><span class="s3">,</span>
        <span class="s1">generic_origin</span><span class="s3">=</span><span class="s1">generic_origin</span><span class="s3">,</span>
        <span class="s1">fields</span><span class="s3">=</span><span class="s1">fields</span><span class="s3">,</span>
        <span class="s1">cls_name</span><span class="s3">=</span><span class="s1">cls_name</span><span class="s3">,</span>
        <span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">,</span>
        <span class="s1">post_init</span><span class="s3">=</span><span class="s1">post_init</span><span class="s3">,</span>
        <span class="s1">revalidate_instances</span><span class="s3">=</span><span class="s1">revalidate_instances</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
        <span class="s1">frozen</span><span class="s3">=</span><span class="s1">frozen</span><span class="s3">,</span>
        <span class="s1">slots</span><span class="s3">=</span><span class="s1">slots</span><span class="s3">,</span>
        <span class="s1">config</span><span class="s3">=</span><span class="s1">config</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">ArgumentsParameter</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">name</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]</span>
    <span class="s1">mode</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'positional_only'</span><span class="s3">, </span><span class="s6">'positional_or_keyword'</span><span class="s3">, </span><span class="s6">'keyword_only'</span><span class="s3">]  </span><span class="s5"># default positional_or_keyword</span>
    <span class="s1">alias</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">list</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">]], </span><span class="s1">list</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">]]]]</span>


<span class="s2">def </span><span class="s1">arguments_parameter</span><span class="s3">(</span>
    <span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">mode</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'positional_only'</span><span class="s3">, </span><span class="s6">'positional_or_keyword'</span><span class="s3">, </span><span class="s6">'keyword_only'</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">alias</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s1">list</span><span class="s3">[</span><span class="s1">str </span><span class="s3">| </span><span class="s1">int</span><span class="s3">] | </span><span class="s1">list</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">str </span><span class="s3">| </span><span class="s1">int</span><span class="s3">]] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ArgumentsParameter</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches an argument parameter, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    param = core_schema.arguments_parameter( 
        name='a', schema=core_schema.str_schema(), mode='positional_only' 
    ) 
    schema = core_schema.arguments_schema([param]) 
    v = SchemaValidator(schema) 
    assert v.validate_python(('hello',)) == (('hello',), {}) 
    ``` 
 
    Args: 
        name: The name to use for the argument parameter 
        schema: The schema to use for the argument parameter 
        mode: The mode to use for the argument parameter 
        alias: The alias to use for the argument parameter 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span><span class="s1">name</span><span class="s3">=</span><span class="s1">name</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">alias</span><span class="s3">=</span><span class="s1">alias</span><span class="s3">)</span>


<span class="s1">VarKwargsMode</span><span class="s3">: </span><span class="s1">TypeAlias </span><span class="s3">= </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'uniform'</span><span class="s3">, </span><span class="s6">'unpacked-typed-dict'</span><span class="s3">]</span>


<span class="s2">class </span><span class="s1">ArgumentsSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'arguments'</span><span class="s3">]]</span>
    <span class="s1">arguments_schema</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">ArgumentsParameter</span><span class="s3">]]</span>
    <span class="s1">validate_by_name</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">validate_by_alias</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">var_args_schema</span><span class="s3">: </span><span class="s1">CoreSchema</span>
    <span class="s1">var_kwargs_mode</span><span class="s3">: </span><span class="s1">VarKwargsMode</span>
    <span class="s1">var_kwargs_schema</span><span class="s3">: </span><span class="s1">CoreSchema</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">arguments_schema</span><span class="s3">(</span>
    <span class="s1">arguments</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">ArgumentsParameter</span><span class="s3">],</span>
    <span class="s3">*,</span>
    <span class="s1">validate_by_name</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">validate_by_alias</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">var_args_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">var_kwargs_mode</span><span class="s3">: </span><span class="s1">VarKwargsMode </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">var_kwargs_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ArgumentsSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches an arguments schema, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    param_a = core_schema.arguments_parameter( 
        name='a', schema=core_schema.str_schema(), mode='positional_only' 
    ) 
    param_b = core_schema.arguments_parameter( 
        name='b', schema=core_schema.bool_schema(), mode='positional_only' 
    ) 
    schema = core_schema.arguments_schema([param_a, param_b]) 
    v = SchemaValidator(schema) 
    assert v.validate_python(('hello', True)) == (('hello', True), {}) 
    ``` 
 
    Args: 
        arguments: The arguments to use for the arguments schema 
        validate_by_name: Whether to populate by the parameter names, defaults to `False`. 
        validate_by_alias: Whether to populate by the parameter aliases, defaults to `True`. 
        var_args_schema: The variable args schema to use for the arguments schema 
        var_kwargs_mode: The validation mode to use for variadic keyword arguments. If `'uniform'`, every value of the 
            keyword arguments will be validated against the `var_kwargs_schema` schema. If `'unpacked-typed-dict'`, 
            the `var_kwargs_schema` argument must be a [`typed_dict_schema`][pydantic_core.core_schema.typed_dict_schema] 
        var_kwargs_schema: The variable kwargs schema to use for the arguments schema 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'arguments'</span><span class="s3">,</span>
        <span class="s1">arguments_schema</span><span class="s3">=</span><span class="s1">arguments</span><span class="s3">,</span>
        <span class="s1">validate_by_name</span><span class="s3">=</span><span class="s1">validate_by_name</span><span class="s3">,</span>
        <span class="s1">validate_by_alias</span><span class="s3">=</span><span class="s1">validate_by_alias</span><span class="s3">,</span>
        <span class="s1">var_args_schema</span><span class="s3">=</span><span class="s1">var_args_schema</span><span class="s3">,</span>
        <span class="s1">var_kwargs_mode</span><span class="s3">=</span><span class="s1">var_kwargs_mode</span><span class="s3">,</span>
        <span class="s1">var_kwargs_schema</span><span class="s3">=</span><span class="s1">var_kwargs_schema</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">ArgumentsV3Parameter</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">name</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]</span>
    <span class="s1">mode</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span>
        <span class="s6">'positional_only'</span><span class="s3">,</span>
        <span class="s6">'positional_or_keyword'</span><span class="s3">,</span>
        <span class="s6">'keyword_only'</span><span class="s3">,</span>
        <span class="s6">'var_args'</span><span class="s3">,</span>
        <span class="s6">'var_kwargs_uniform'</span><span class="s3">,</span>
        <span class="s6">'var_kwargs_unpacked_typed_dict'</span><span class="s3">,</span>
    <span class="s3">]  </span><span class="s5"># default positional_or_keyword</span>
    <span class="s1">alias</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">list</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">]], </span><span class="s1">list</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">]]]]</span>


<span class="s2">def </span><span class="s1">arguments_v3_parameter</span><span class="s3">(</span>
    <span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">mode</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span>
        <span class="s6">'positional_only'</span><span class="s3">,</span>
        <span class="s6">'positional_or_keyword'</span><span class="s3">,</span>
        <span class="s6">'keyword_only'</span><span class="s3">,</span>
        <span class="s6">'var_args'</span><span class="s3">,</span>
        <span class="s6">'var_kwargs_uniform'</span><span class="s3">,</span>
        <span class="s6">'var_kwargs_unpacked_typed_dict'</span><span class="s3">,</span>
    <span class="s3">]</span>
    <span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">alias</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s1">list</span><span class="s3">[</span><span class="s1">str </span><span class="s3">| </span><span class="s1">int</span><span class="s3">] | </span><span class="s1">list</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">str </span><span class="s3">| </span><span class="s1">int</span><span class="s3">]] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ArgumentsV3Parameter</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches an argument parameter, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    param = core_schema.arguments_v3_parameter( 
        name='a', schema=core_schema.str_schema(), mode='positional_only' 
    ) 
    schema = core_schema.arguments_v3_schema([param]) 
    v = SchemaValidator(schema) 
    assert v.validate_python({'a': 'hello'}) == (('hello',), {}) 
    ``` 
 
    Args: 
        name: The name to use for the argument parameter 
        schema: The schema to use for the argument parameter 
        mode: The mode to use for the argument parameter 
        alias: The alias to use for the argument parameter 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span><span class="s1">name</span><span class="s3">=</span><span class="s1">name</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">alias</span><span class="s3">=</span><span class="s1">alias</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">ArgumentsV3Schema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'arguments-v3'</span><span class="s3">]]</span>
    <span class="s1">arguments_schema</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">ArgumentsV3Parameter</span><span class="s3">]]</span>
    <span class="s1">validate_by_name</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">validate_by_alias</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">extra_behavior</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'forbid'</span><span class="s3">, </span><span class="s6">'ignore'</span><span class="s3">]  </span><span class="s5"># 'allow' doesn't make sense here.</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">arguments_v3_schema</span><span class="s3">(</span>
    <span class="s1">arguments</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">ArgumentsV3Parameter</span><span class="s3">],</span>
    <span class="s3">*,</span>
    <span class="s1">validate_by_name</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">validate_by_alias</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">extra_behavior</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'forbid'</span><span class="s3">, </span><span class="s6">'ignore'</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ArgumentsV3Schema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches an arguments schema, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    param_a = core_schema.arguments_v3_parameter( 
        name='a', schema=core_schema.str_schema(), mode='positional_only' 
    ) 
    param_b = core_schema.arguments_v3_parameter( 
        name='kwargs', schema=core_schema.bool_schema(), mode='var_kwargs_uniform' 
    ) 
    schema = core_schema.arguments_v3_schema([param_a, param_b]) 
    v = SchemaValidator(schema) 
    assert v.validate_python({'a': 'hi', 'kwargs': {'b': True}}) == (('hi',), {'b': True}) 
    ``` 
 
    This schema is currently not used by other Pydantic components. In V3, it will most likely 
    become the default arguments schema for the `'call'` schema. 
 
    Args: 
        arguments: The arguments to use for the arguments schema. 
        validate_by_name: Whether to populate by the parameter names, defaults to `False`. 
        validate_by_alias: Whether to populate by the parameter aliases, defaults to `True`. 
        extra_behavior: The extra behavior to use. 
        ref: optional unique identifier of the schema, used to reference the schema in other places. 
        metadata: Any other information you want to include with the schema, not used by pydantic-core. 
        serialization: Custom serialization schema. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'arguments-v3'</span><span class="s3">,</span>
        <span class="s1">arguments_schema</span><span class="s3">=</span><span class="s1">arguments</span><span class="s3">,</span>
        <span class="s1">validate_by_name</span><span class="s3">=</span><span class="s1">validate_by_name</span><span class="s3">,</span>
        <span class="s1">validate_by_alias</span><span class="s3">=</span><span class="s1">validate_by_alias</span><span class="s3">,</span>
        <span class="s1">extra_behavior</span><span class="s3">=</span><span class="s1">extra_behavior</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">CallSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'call'</span><span class="s3">]]</span>
    <span class="s1">arguments_schema</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]</span>
    <span class="s1">function</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Callable</span><span class="s3">[..., </span><span class="s1">Any</span><span class="s3">]]</span>
    <span class="s1">function_name</span><span class="s3">: </span><span class="s1">str  </span><span class="s5"># default function.__name__</span>
    <span class="s1">return_schema</span><span class="s3">: </span><span class="s1">CoreSchema</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">call_schema</span><span class="s3">(</span>
    <span class="s1">arguments</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s1">function</span><span class="s3">: </span><span class="s1">Callable</span><span class="s3">[..., </span><span class="s1">Any</span><span class="s3">],</span>
    <span class="s3">*,</span>
    <span class="s1">function_name</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">return_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; CallSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches an arguments schema, then calls a function, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    param_a = core_schema.arguments_parameter( 
        name='a', schema=core_schema.str_schema(), mode='positional_only' 
    ) 
    param_b = core_schema.arguments_parameter( 
        name='b', schema=core_schema.bool_schema(), mode='positional_only' 
    ) 
    args_schema = core_schema.arguments_schema([param_a, param_b]) 
 
    schema = core_schema.call_schema( 
        arguments=args_schema, 
        function=lambda a, b: a + str(not b), 
        return_schema=core_schema.str_schema(), 
    ) 
    v = SchemaValidator(schema) 
    assert v.validate_python((('hello', True))) == 'helloFalse' 
    ``` 
 
    Args: 
        arguments: The arguments to use for the arguments schema 
        function: The function to use for the call schema 
        function_name: The function name to use for the call schema, if not provided `function.__name__` is used 
        return_schema: The return schema to use for the call schema 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'call'</span><span class="s3">,</span>
        <span class="s1">arguments_schema</span><span class="s3">=</span><span class="s1">arguments</span><span class="s3">,</span>
        <span class="s1">function</span><span class="s3">=</span><span class="s1">function</span><span class="s3">,</span>
        <span class="s1">function_name</span><span class="s3">=</span><span class="s1">function_name</span><span class="s3">,</span>
        <span class="s1">return_schema</span><span class="s3">=</span><span class="s1">return_schema</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">CustomErrorSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'custom-error'</span><span class="s3">]]</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]</span>
    <span class="s1">custom_error_type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]</span>
    <span class="s1">custom_error_message</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">custom_error_context</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">, </span><span class="s1">float</span><span class="s3">]]</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">custom_error_schema</span><span class="s3">(</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s1">custom_error_type</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">custom_error_message</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">custom_error_context</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; CustomErrorSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a custom error value, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.custom_error_schema( 
        schema=core_schema.int_schema(), 
        custom_error_type='MyError', 
        custom_error_message='Error msg', 
    ) 
    v = SchemaValidator(schema) 
    v.validate_python(1) 
    ``` 
 
    Args: 
        schema: The schema to use for the custom error schema 
        custom_error_type: The custom error type to use for the custom error schema 
        custom_error_message: The custom error message to use for the custom error schema 
        custom_error_context: The custom error context to use for the custom error schema 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'custom-error'</span><span class="s3">,</span>
        <span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">,</span>
        <span class="s1">custom_error_type</span><span class="s3">=</span><span class="s1">custom_error_type</span><span class="s3">,</span>
        <span class="s1">custom_error_message</span><span class="s3">=</span><span class="s1">custom_error_message</span><span class="s3">,</span>
        <span class="s1">custom_error_context</span><span class="s3">=</span><span class="s1">custom_error_context</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">JsonSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'json'</span><span class="s3">]]</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">json_schema</span><span class="s3">(</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; JsonSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a JSON value, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    dict_schema = core_schema.model_fields_schema( 
        { 
            'field_a': core_schema.model_field(core_schema.str_schema()), 
            'field_b': core_schema.model_field(core_schema.bool_schema()), 
        }, 
    ) 
 
    class MyModel: 
        __slots__ = ( 
            '__dict__', 
            '__pydantic_fields_set__', 
            '__pydantic_extra__', 
            '__pydantic_private__', 
        ) 
        field_a: str 
        field_b: bool 
 
    json_schema = core_schema.json_schema(schema=dict_schema) 
    schema = core_schema.model_schema(cls=MyModel, schema=json_schema) 
    v = SchemaValidator(schema) 
    m = v.validate_python('{&quot;field_a&quot;: &quot;hello&quot;, &quot;field_b&quot;: true}') 
    assert isinstance(m, MyModel) 
    ``` 
 
    Args: 
        schema: The schema to use for the JSON schema 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span><span class="s1">type</span><span class="s3">=</span><span class="s6">'json'</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">UrlSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'url'</span><span class="s3">]]</span>
    <span class="s1">max_length</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">allowed_schemes</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]</span>
    <span class="s1">host_required</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default False</span>
    <span class="s1">default_host</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">default_port</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">default_path</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">url_schema</span><span class="s3">(</span>
    <span class="s3">*,</span>
    <span class="s1">max_length</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">allowed_schemes</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">host_required</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">default_host</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">default_port</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">default_path</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; UrlSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a URL value, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.url_schema() 
    v = SchemaValidator(schema) 
    print(v.validate_python('https://example.com')) 
    #&gt; https://example.com/ 
    ``` 
 
    Args: 
        max_length: The maximum length of the URL 
        allowed_schemes: The allowed URL schemes 
        host_required: Whether the URL must have a host 
        default_host: The default host to use if the URL does not have a host 
        default_port: The default port to use if the URL does not have a port 
        default_path: The default path to use if the URL does not have a path 
        strict: Whether to use strict URL parsing 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'url'</span><span class="s3">,</span>
        <span class="s1">max_length</span><span class="s3">=</span><span class="s1">max_length</span><span class="s3">,</span>
        <span class="s1">allowed_schemes</span><span class="s3">=</span><span class="s1">allowed_schemes</span><span class="s3">,</span>
        <span class="s1">host_required</span><span class="s3">=</span><span class="s1">host_required</span><span class="s3">,</span>
        <span class="s1">default_host</span><span class="s3">=</span><span class="s1">default_host</span><span class="s3">,</span>
        <span class="s1">default_port</span><span class="s3">=</span><span class="s1">default_port</span><span class="s3">,</span>
        <span class="s1">default_path</span><span class="s3">=</span><span class="s1">default_path</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">MultiHostUrlSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'multi-host-url'</span><span class="s3">]]</span>
    <span class="s1">max_length</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">allowed_schemes</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]</span>
    <span class="s1">host_required</span><span class="s3">: </span><span class="s1">bool  </span><span class="s5"># default False</span>
    <span class="s1">default_host</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">default_port</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">default_path</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">multi_host_url_schema</span><span class="s3">(</span>
    <span class="s3">*,</span>
    <span class="s1">max_length</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">allowed_schemes</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">host_required</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">default_host</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">default_port</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">default_path</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">strict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; MultiHostUrlSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that matches a URL value with possibly multiple hosts, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.multi_host_url_schema() 
    v = SchemaValidator(schema) 
    print(v.validate_python('redis://localhost,0.0.0.0,127.0.0.1')) 
    #&gt; redis://localhost,0.0.0.0,127.0.0.1 
    ``` 
 
    Args: 
        max_length: The maximum length of the URL 
        allowed_schemes: The allowed URL schemes 
        host_required: Whether the URL must have a host 
        default_host: The default host to use if the URL does not have a host 
        default_port: The default port to use if the URL does not have a port 
        default_path: The default path to use if the URL does not have a path 
        strict: Whether to use strict URL parsing 
        ref: optional unique identifier of the schema, used to reference the schema in other places 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'multi-host-url'</span><span class="s3">,</span>
        <span class="s1">max_length</span><span class="s3">=</span><span class="s1">max_length</span><span class="s3">,</span>
        <span class="s1">allowed_schemes</span><span class="s3">=</span><span class="s1">allowed_schemes</span><span class="s3">,</span>
        <span class="s1">host_required</span><span class="s3">=</span><span class="s1">host_required</span><span class="s3">,</span>
        <span class="s1">default_host</span><span class="s3">=</span><span class="s1">default_host</span><span class="s3">,</span>
        <span class="s1">default_port</span><span class="s3">=</span><span class="s1">default_port</span><span class="s3">,</span>
        <span class="s1">default_path</span><span class="s3">=</span><span class="s1">default_path</span><span class="s3">,</span>
        <span class="s1">strict</span><span class="s3">=</span><span class="s1">strict</span><span class="s3">,</span>
        <span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">DefinitionsSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'definitions'</span><span class="s3">]]</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]</span>
    <span class="s1">definitions</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]]</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">definitions_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">, </span><span class="s1">definitions</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">]) </span><span class="s1">-&gt; DefinitionsSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Build a schema that contains both an inner schema and a list of definitions which can be used 
    within the inner schema. 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema = core_schema.definitions_schema( 
        core_schema.list_schema(core_schema.definition_reference_schema('foobar')), 
        [core_schema.int_schema(ref='foobar')], 
    ) 
    v = SchemaValidator(schema) 
    assert v.validate_python([1, 2, '3']) == [1, 2, 3] 
    ``` 
 
    Args: 
        schema: The inner schema 
        definitions: List of definitions which can be referenced within inner schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">DefinitionsSchema</span><span class="s3">(</span><span class="s1">type</span><span class="s3">=</span><span class="s6">'definitions'</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">definitions</span><span class="s3">=</span><span class="s1">definitions</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">DefinitionReferenceSchema</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">type</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'definition-ref'</span><span class="s3">]]</span>
    <span class="s1">schema_ref</span><span class="s3">: </span><span class="s1">Required</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema</span>


<span class="s2">def </span><span class="s1">definition_reference_schema</span><span class="s3">(</span>
    <span class="s1">schema_ref</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization</span><span class="s3">: </span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; DefinitionReferenceSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a schema that points to a schema stored in &quot;definitions&quot;, this is useful for nested recursive 
    models and also when you want to define validators separately from the main schema, e.g.: 
 
    ```py 
    from pydantic_core import SchemaValidator, core_schema 
 
    schema_definition = core_schema.definition_reference_schema('list-schema') 
    schema = core_schema.definitions_schema( 
        schema=schema_definition, 
        definitions=[ 
            core_schema.list_schema(items_schema=schema_definition, ref='list-schema'), 
        ], 
    ) 
    v = SchemaValidator(schema) 
    assert v.validate_python([()]) == [[]] 
    ``` 
 
    Args: 
        schema_ref: The schema ref to use for the definition reference schema 
        metadata: Any other information you want to include with the schema, not used by pydantic-core 
        serialization: Custom serialization schema 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_dict_not_none</span><span class="s3">(</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s6">'definition-ref'</span><span class="s3">, </span><span class="s1">schema_ref</span><span class="s3">=</span><span class="s1">schema_ref</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">=</span><span class="s1">ref</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span>
    <span class="s3">)</span>


<span class="s1">MYPY </span><span class="s3">= </span><span class="s2">False</span>
<span class="s5"># See https://github.com/python/mypy/issues/14034 for details, in summary mypy is extremely slow to process this</span>
<span class="s5"># union which kills performance not just for pydantic, but even for code using pydantic</span>
<span class="s2">if not </span><span class="s1">MYPY</span><span class="s3">:</span>
    <span class="s1">CoreSchema </span><span class="s3">= </span><span class="s1">Union</span><span class="s3">[</span>
        <span class="s1">InvalidSchema</span><span class="s3">,</span>
        <span class="s1">AnySchema</span><span class="s3">,</span>
        <span class="s1">NoneSchema</span><span class="s3">,</span>
        <span class="s1">BoolSchema</span><span class="s3">,</span>
        <span class="s1">IntSchema</span><span class="s3">,</span>
        <span class="s1">FloatSchema</span><span class="s3">,</span>
        <span class="s1">DecimalSchema</span><span class="s3">,</span>
        <span class="s1">StringSchema</span><span class="s3">,</span>
        <span class="s1">BytesSchema</span><span class="s3">,</span>
        <span class="s1">DateSchema</span><span class="s3">,</span>
        <span class="s1">TimeSchema</span><span class="s3">,</span>
        <span class="s1">DatetimeSchema</span><span class="s3">,</span>
        <span class="s1">TimedeltaSchema</span><span class="s3">,</span>
        <span class="s1">LiteralSchema</span><span class="s3">,</span>
        <span class="s1">EnumSchema</span><span class="s3">,</span>
        <span class="s1">IsInstanceSchema</span><span class="s3">,</span>
        <span class="s1">IsSubclassSchema</span><span class="s3">,</span>
        <span class="s1">CallableSchema</span><span class="s3">,</span>
        <span class="s1">ListSchema</span><span class="s3">,</span>
        <span class="s1">TupleSchema</span><span class="s3">,</span>
        <span class="s1">SetSchema</span><span class="s3">,</span>
        <span class="s1">FrozenSetSchema</span><span class="s3">,</span>
        <span class="s1">GeneratorSchema</span><span class="s3">,</span>
        <span class="s1">DictSchema</span><span class="s3">,</span>
        <span class="s1">AfterValidatorFunctionSchema</span><span class="s3">,</span>
        <span class="s1">BeforeValidatorFunctionSchema</span><span class="s3">,</span>
        <span class="s1">WrapValidatorFunctionSchema</span><span class="s3">,</span>
        <span class="s1">PlainValidatorFunctionSchema</span><span class="s3">,</span>
        <span class="s1">WithDefaultSchema</span><span class="s3">,</span>
        <span class="s1">NullableSchema</span><span class="s3">,</span>
        <span class="s1">UnionSchema</span><span class="s3">,</span>
        <span class="s1">TaggedUnionSchema</span><span class="s3">,</span>
        <span class="s1">ChainSchema</span><span class="s3">,</span>
        <span class="s1">LaxOrStrictSchema</span><span class="s3">,</span>
        <span class="s1">JsonOrPythonSchema</span><span class="s3">,</span>
        <span class="s1">TypedDictSchema</span><span class="s3">,</span>
        <span class="s1">ModelFieldsSchema</span><span class="s3">,</span>
        <span class="s1">ModelSchema</span><span class="s3">,</span>
        <span class="s1">DataclassArgsSchema</span><span class="s3">,</span>
        <span class="s1">DataclassSchema</span><span class="s3">,</span>
        <span class="s1">ArgumentsSchema</span><span class="s3">,</span>
        <span class="s1">ArgumentsV3Schema</span><span class="s3">,</span>
        <span class="s1">CallSchema</span><span class="s3">,</span>
        <span class="s1">CustomErrorSchema</span><span class="s3">,</span>
        <span class="s1">JsonSchema</span><span class="s3">,</span>
        <span class="s1">UrlSchema</span><span class="s3">,</span>
        <span class="s1">MultiHostUrlSchema</span><span class="s3">,</span>
        <span class="s1">DefinitionsSchema</span><span class="s3">,</span>
        <span class="s1">DefinitionReferenceSchema</span><span class="s3">,</span>
        <span class="s1">UuidSchema</span><span class="s3">,</span>
        <span class="s1">ComplexSchema</span><span class="s3">,</span>
    <span class="s3">]</span>
<span class="s2">elif False</span><span class="s3">:</span>
    <span class="s1">CoreSchema</span><span class="s3">: </span><span class="s1">TypeAlias </span><span class="s3">= </span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>


<span class="s5"># to update this, call `pytest -k test_core_schema_type_literal` and copy the output</span>
<span class="s1">CoreSchemaType </span><span class="s3">= </span><span class="s1">Literal</span><span class="s3">[</span>
    <span class="s6">'invalid'</span><span class="s3">,</span>
    <span class="s6">'any'</span><span class="s3">,</span>
    <span class="s6">'none'</span><span class="s3">,</span>
    <span class="s6">'bool'</span><span class="s3">,</span>
    <span class="s6">'int'</span><span class="s3">,</span>
    <span class="s6">'float'</span><span class="s3">,</span>
    <span class="s6">'decimal'</span><span class="s3">,</span>
    <span class="s6">'str'</span><span class="s3">,</span>
    <span class="s6">'bytes'</span><span class="s3">,</span>
    <span class="s6">'date'</span><span class="s3">,</span>
    <span class="s6">'time'</span><span class="s3">,</span>
    <span class="s6">'datetime'</span><span class="s3">,</span>
    <span class="s6">'timedelta'</span><span class="s3">,</span>
    <span class="s6">'literal'</span><span class="s3">,</span>
    <span class="s6">'enum'</span><span class="s3">,</span>
    <span class="s6">'is-instance'</span><span class="s3">,</span>
    <span class="s6">'is-subclass'</span><span class="s3">,</span>
    <span class="s6">'callable'</span><span class="s3">,</span>
    <span class="s6">'list'</span><span class="s3">,</span>
    <span class="s6">'tuple'</span><span class="s3">,</span>
    <span class="s6">'set'</span><span class="s3">,</span>
    <span class="s6">'frozenset'</span><span class="s3">,</span>
    <span class="s6">'generator'</span><span class="s3">,</span>
    <span class="s6">'dict'</span><span class="s3">,</span>
    <span class="s6">'function-after'</span><span class="s3">,</span>
    <span class="s6">'function-before'</span><span class="s3">,</span>
    <span class="s6">'function-wrap'</span><span class="s3">,</span>
    <span class="s6">'function-plain'</span><span class="s3">,</span>
    <span class="s6">'default'</span><span class="s3">,</span>
    <span class="s6">'nullable'</span><span class="s3">,</span>
    <span class="s6">'union'</span><span class="s3">,</span>
    <span class="s6">'tagged-union'</span><span class="s3">,</span>
    <span class="s6">'chain'</span><span class="s3">,</span>
    <span class="s6">'lax-or-strict'</span><span class="s3">,</span>
    <span class="s6">'json-or-python'</span><span class="s3">,</span>
    <span class="s6">'typed-dict'</span><span class="s3">,</span>
    <span class="s6">'model-fields'</span><span class="s3">,</span>
    <span class="s6">'model'</span><span class="s3">,</span>
    <span class="s6">'dataclass-args'</span><span class="s3">,</span>
    <span class="s6">'dataclass'</span><span class="s3">,</span>
    <span class="s6">'arguments'</span><span class="s3">,</span>
    <span class="s6">'arguments-v3'</span><span class="s3">,</span>
    <span class="s6">'call'</span><span class="s3">,</span>
    <span class="s6">'custom-error'</span><span class="s3">,</span>
    <span class="s6">'json'</span><span class="s3">,</span>
    <span class="s6">'url'</span><span class="s3">,</span>
    <span class="s6">'multi-host-url'</span><span class="s3">,</span>
    <span class="s6">'definitions'</span><span class="s3">,</span>
    <span class="s6">'definition-ref'</span><span class="s3">,</span>
    <span class="s6">'uuid'</span><span class="s3">,</span>
    <span class="s6">'complex'</span><span class="s3">,</span>
<span class="s3">]</span>

<span class="s1">CoreSchemaFieldType </span><span class="s3">= </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'model-field'</span><span class="s3">, </span><span class="s6">'dataclass-field'</span><span class="s3">, </span><span class="s6">'typed-dict-field'</span><span class="s3">, </span><span class="s6">'computed-field'</span><span class="s3">]</span>


<span class="s5"># used in _pydantic_core.pyi::PydanticKnownError</span>
<span class="s5"># to update this, call `pytest -k test_all_errors` and copy the output</span>
<span class="s1">ErrorType </span><span class="s3">= </span><span class="s1">Literal</span><span class="s3">[</span>
    <span class="s6">'no_such_attribute'</span><span class="s3">,</span>
    <span class="s6">'json_invalid'</span><span class="s3">,</span>
    <span class="s6">'json_type'</span><span class="s3">,</span>
    <span class="s6">'needs_python_object'</span><span class="s3">,</span>
    <span class="s6">'recursion_loop'</span><span class="s3">,</span>
    <span class="s6">'missing'</span><span class="s3">,</span>
    <span class="s6">'frozen_field'</span><span class="s3">,</span>
    <span class="s6">'frozen_instance'</span><span class="s3">,</span>
    <span class="s6">'extra_forbidden'</span><span class="s3">,</span>
    <span class="s6">'invalid_key'</span><span class="s3">,</span>
    <span class="s6">'get_attribute_error'</span><span class="s3">,</span>
    <span class="s6">'model_type'</span><span class="s3">,</span>
    <span class="s6">'model_attributes_type'</span><span class="s3">,</span>
    <span class="s6">'dataclass_type'</span><span class="s3">,</span>
    <span class="s6">'dataclass_exact_type'</span><span class="s3">,</span>
    <span class="s6">'none_required'</span><span class="s3">,</span>
    <span class="s6">'greater_than'</span><span class="s3">,</span>
    <span class="s6">'greater_than_equal'</span><span class="s3">,</span>
    <span class="s6">'less_than'</span><span class="s3">,</span>
    <span class="s6">'less_than_equal'</span><span class="s3">,</span>
    <span class="s6">'multiple_of'</span><span class="s3">,</span>
    <span class="s6">'finite_number'</span><span class="s3">,</span>
    <span class="s6">'too_short'</span><span class="s3">,</span>
    <span class="s6">'too_long'</span><span class="s3">,</span>
    <span class="s6">'iterable_type'</span><span class="s3">,</span>
    <span class="s6">'iteration_error'</span><span class="s3">,</span>
    <span class="s6">'string_type'</span><span class="s3">,</span>
    <span class="s6">'string_sub_type'</span><span class="s3">,</span>
    <span class="s6">'string_unicode'</span><span class="s3">,</span>
    <span class="s6">'string_too_short'</span><span class="s3">,</span>
    <span class="s6">'string_too_long'</span><span class="s3">,</span>
    <span class="s6">'string_pattern_mismatch'</span><span class="s3">,</span>
    <span class="s6">'enum'</span><span class="s3">,</span>
    <span class="s6">'dict_type'</span><span class="s3">,</span>
    <span class="s6">'mapping_type'</span><span class="s3">,</span>
    <span class="s6">'list_type'</span><span class="s3">,</span>
    <span class="s6">'tuple_type'</span><span class="s3">,</span>
    <span class="s6">'set_type'</span><span class="s3">,</span>
    <span class="s6">'set_item_not_hashable'</span><span class="s3">,</span>
    <span class="s6">'bool_type'</span><span class="s3">,</span>
    <span class="s6">'bool_parsing'</span><span class="s3">,</span>
    <span class="s6">'int_type'</span><span class="s3">,</span>
    <span class="s6">'int_parsing'</span><span class="s3">,</span>
    <span class="s6">'int_parsing_size'</span><span class="s3">,</span>
    <span class="s6">'int_from_float'</span><span class="s3">,</span>
    <span class="s6">'float_type'</span><span class="s3">,</span>
    <span class="s6">'float_parsing'</span><span class="s3">,</span>
    <span class="s6">'bytes_type'</span><span class="s3">,</span>
    <span class="s6">'bytes_too_short'</span><span class="s3">,</span>
    <span class="s6">'bytes_too_long'</span><span class="s3">,</span>
    <span class="s6">'bytes_invalid_encoding'</span><span class="s3">,</span>
    <span class="s6">'value_error'</span><span class="s3">,</span>
    <span class="s6">'assertion_error'</span><span class="s3">,</span>
    <span class="s6">'literal_error'</span><span class="s3">,</span>
    <span class="s6">'date_type'</span><span class="s3">,</span>
    <span class="s6">'date_parsing'</span><span class="s3">,</span>
    <span class="s6">'date_from_datetime_parsing'</span><span class="s3">,</span>
    <span class="s6">'date_from_datetime_inexact'</span><span class="s3">,</span>
    <span class="s6">'date_past'</span><span class="s3">,</span>
    <span class="s6">'date_future'</span><span class="s3">,</span>
    <span class="s6">'time_type'</span><span class="s3">,</span>
    <span class="s6">'time_parsing'</span><span class="s3">,</span>
    <span class="s6">'datetime_type'</span><span class="s3">,</span>
    <span class="s6">'datetime_parsing'</span><span class="s3">,</span>
    <span class="s6">'datetime_object_invalid'</span><span class="s3">,</span>
    <span class="s6">'datetime_from_date_parsing'</span><span class="s3">,</span>
    <span class="s6">'datetime_past'</span><span class="s3">,</span>
    <span class="s6">'datetime_future'</span><span class="s3">,</span>
    <span class="s6">'timezone_naive'</span><span class="s3">,</span>
    <span class="s6">'timezone_aware'</span><span class="s3">,</span>
    <span class="s6">'timezone_offset'</span><span class="s3">,</span>
    <span class="s6">'time_delta_type'</span><span class="s3">,</span>
    <span class="s6">'time_delta_parsing'</span><span class="s3">,</span>
    <span class="s6">'frozen_set_type'</span><span class="s3">,</span>
    <span class="s6">'is_instance_of'</span><span class="s3">,</span>
    <span class="s6">'is_subclass_of'</span><span class="s3">,</span>
    <span class="s6">'callable_type'</span><span class="s3">,</span>
    <span class="s6">'union_tag_invalid'</span><span class="s3">,</span>
    <span class="s6">'union_tag_not_found'</span><span class="s3">,</span>
    <span class="s6">'arguments_type'</span><span class="s3">,</span>
    <span class="s6">'missing_argument'</span><span class="s3">,</span>
    <span class="s6">'unexpected_keyword_argument'</span><span class="s3">,</span>
    <span class="s6">'missing_keyword_only_argument'</span><span class="s3">,</span>
    <span class="s6">'unexpected_positional_argument'</span><span class="s3">,</span>
    <span class="s6">'missing_positional_only_argument'</span><span class="s3">,</span>
    <span class="s6">'multiple_argument_values'</span><span class="s3">,</span>
    <span class="s6">'url_type'</span><span class="s3">,</span>
    <span class="s6">'url_parsing'</span><span class="s3">,</span>
    <span class="s6">'url_syntax_violation'</span><span class="s3">,</span>
    <span class="s6">'url_too_long'</span><span class="s3">,</span>
    <span class="s6">'url_scheme'</span><span class="s3">,</span>
    <span class="s6">'uuid_type'</span><span class="s3">,</span>
    <span class="s6">'uuid_parsing'</span><span class="s3">,</span>
    <span class="s6">'uuid_version'</span><span class="s3">,</span>
    <span class="s6">'decimal_type'</span><span class="s3">,</span>
    <span class="s6">'decimal_parsing'</span><span class="s3">,</span>
    <span class="s6">'decimal_max_digits'</span><span class="s3">,</span>
    <span class="s6">'decimal_max_places'</span><span class="s3">,</span>
    <span class="s6">'decimal_whole_digits'</span><span class="s3">,</span>
    <span class="s6">'complex_type'</span><span class="s3">,</span>
    <span class="s6">'complex_str_parsing'</span><span class="s3">,</span>
<span class="s3">]</span>


<span class="s2">def </span><span class="s1">_dict_not_none</span><span class="s3">(**</span><span class="s1">kwargs</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
    <span class="s2">return </span><span class="s3">{</span><span class="s1">k</span><span class="s3">: </span><span class="s1">v </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">items</span><span class="s3">() </span><span class="s2">if </span><span class="s1">v </span><span class="s2">is not None</span><span class="s3">}</span>


<span class="s5">###############################################################################</span>
<span class="s5"># All this stuff is deprecated by #980 and will be removed eventually</span>
<span class="s5"># They're kept because some code external code will be using them</span>


<span class="s3">@</span><span class="s1">deprecated</span><span class="s3">(</span><span class="s6">'`field_before_validator_function` is deprecated, use `with_info_before_validator_function` instead.'</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">field_before_validator_function</span><span class="s3">(</span><span class="s1">function</span><span class="s3">: </span><span class="s1">WithInfoValidatorFunction</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
        <span class="s6">'`field_before_validator_function` is deprecated, use `with_info_before_validator_function` instead.'</span><span class="s3">,</span>
        <span class="s1">DeprecationWarning</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">return </span><span class="s1">with_info_before_validator_function</span><span class="s3">(</span><span class="s1">function</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">=</span><span class="s1">field_name</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">deprecated</span><span class="s3">(</span><span class="s6">'`general_before_validator_function` is deprecated, use `with_info_before_validator_function` instead.'</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">general_before_validator_function</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
        <span class="s6">'`general_before_validator_function` is deprecated, use `with_info_before_validator_function` instead.'</span><span class="s3">,</span>
        <span class="s1">DeprecationWarning</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">return </span><span class="s1">with_info_before_validator_function</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">deprecated</span><span class="s3">(</span><span class="s6">'`field_after_validator_function` is deprecated, use `with_info_after_validator_function` instead.'</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">field_after_validator_function</span><span class="s3">(</span><span class="s1">function</span><span class="s3">: </span><span class="s1">WithInfoValidatorFunction</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
        <span class="s6">'`field_after_validator_function` is deprecated, use `with_info_after_validator_function` instead.'</span><span class="s3">,</span>
        <span class="s1">DeprecationWarning</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">return </span><span class="s1">with_info_after_validator_function</span><span class="s3">(</span><span class="s1">function</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">=</span><span class="s1">field_name</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">deprecated</span><span class="s3">(</span><span class="s6">'`general_after_validator_function` is deprecated, use `with_info_after_validator_function` instead.'</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">general_after_validator_function</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
        <span class="s6">'`general_after_validator_function` is deprecated, use `with_info_after_validator_function` instead.'</span><span class="s3">,</span>
        <span class="s1">DeprecationWarning</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">return </span><span class="s1">with_info_after_validator_function</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">deprecated</span><span class="s3">(</span><span class="s6">'`field_wrap_validator_function` is deprecated, use `with_info_wrap_validator_function` instead.'</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">field_wrap_validator_function</span><span class="s3">(</span>
    <span class="s1">function</span><span class="s3">: </span><span class="s1">WithInfoWrapValidatorFunction</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">, **</span><span class="s1">kwargs</span>
<span class="s3">):</span>
    <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
        <span class="s6">'`field_wrap_validator_function` is deprecated, use `with_info_wrap_validator_function` instead.'</span><span class="s3">,</span>
        <span class="s1">DeprecationWarning</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">return </span><span class="s1">with_info_wrap_validator_function</span><span class="s3">(</span><span class="s1">function</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">=</span><span class="s1">field_name</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">deprecated</span><span class="s3">(</span><span class="s6">'`general_wrap_validator_function` is deprecated, use `with_info_wrap_validator_function` instead.'</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">general_wrap_validator_function</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
        <span class="s6">'`general_wrap_validator_function` is deprecated, use `with_info_wrap_validator_function` instead.'</span><span class="s3">,</span>
        <span class="s1">DeprecationWarning</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">return </span><span class="s1">with_info_wrap_validator_function</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">deprecated</span><span class="s3">(</span><span class="s6">'`field_plain_validator_function` is deprecated, use `with_info_plain_validator_function` instead.'</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">field_plain_validator_function</span><span class="s3">(</span><span class="s1">function</span><span class="s3">: </span><span class="s1">WithInfoValidatorFunction</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
        <span class="s6">'`field_plain_validator_function` is deprecated, use `with_info_plain_validator_function` instead.'</span><span class="s3">,</span>
        <span class="s1">DeprecationWarning</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">return </span><span class="s1">with_info_plain_validator_function</span><span class="s3">(</span><span class="s1">function</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">=</span><span class="s1">field_name</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">deprecated</span><span class="s3">(</span><span class="s6">'`general_plain_validator_function` is deprecated, use `with_info_plain_validator_function` instead.'</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">general_plain_validator_function</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
        <span class="s6">'`general_plain_validator_function` is deprecated, use `with_info_plain_validator_function` instead.'</span><span class="s3">,</span>
        <span class="s1">DeprecationWarning</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">return </span><span class="s1">with_info_plain_validator_function</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>


<span class="s1">_deprecated_import_lookup </span><span class="s3">= {</span>
    <span class="s6">'FieldValidationInfo'</span><span class="s3">: </span><span class="s1">ValidationInfo</span><span class="s3">,</span>
    <span class="s6">'FieldValidatorFunction'</span><span class="s3">: </span><span class="s1">WithInfoValidatorFunction</span><span class="s3">,</span>
    <span class="s6">'GeneralValidatorFunction'</span><span class="s3">: </span><span class="s1">WithInfoValidatorFunction</span><span class="s3">,</span>
    <span class="s6">'FieldWrapValidatorFunction'</span><span class="s3">: </span><span class="s1">WithInfoWrapValidatorFunction</span><span class="s3">,</span>
<span class="s3">}</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s1">FieldValidationInfo </span><span class="s3">= </span><span class="s1">ValidationInfo</span>


<span class="s2">def </span><span class="s1">__getattr__</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; object</span><span class="s3">:</span>
    <span class="s1">new_attr </span><span class="s3">= </span><span class="s1">_deprecated_import_lookup</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">new_attr </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">AttributeError</span><span class="s3">(</span><span class="s6">f&quot;module 'pydantic_core' has no attribute '</span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">}</span><span class="s6">'&quot;</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">import </span><span class="s1">warnings</span>

        <span class="s1">msg </span><span class="s3">= </span><span class="s6">f'`</span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">}</span><span class="s6">` is deprecated, use `</span><span class="s2">{</span><span class="s1">new_attr</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">}</span><span class="s6">` instead.'</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s4">1</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">new_attr</span>
</pre>
</body>
</html>