<html>
<head>
<title>_typing_extra.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #7a7e85;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_typing_extra.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Logic for interacting with type annotations, mostly extensions, shims and hacks to wrap Python's typing module.&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">types</span>
<span class="s2">import </span><span class="s1">typing</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Callable</span><span class="s3">, </span><span class="s1">cast</span>

<span class="s2">import </span><span class="s1">typing_extensions</span>
<span class="s2">from </span><span class="s1">typing_extensions </span><span class="s2">import </span><span class="s1">deprecated</span><span class="s3">, </span><span class="s1">get_args</span><span class="s3">, </span><span class="s1">get_origin</span>
<span class="s2">from </span><span class="s1">typing_inspection </span><span class="s2">import </span><span class="s1">typing_objects</span>
<span class="s2">from </span><span class="s1">typing_inspection</span><span class="s3">.</span><span class="s1">introspection </span><span class="s2">import </span><span class="s1">is_union_origin</span>

<span class="s2">from </span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">version </span><span class="s2">import </span><span class="s1">version_short</span>

<span class="s2">from </span><span class="s3">.</span><span class="s1">_namespace_utils </span><span class="s2">import </span><span class="s1">GlobalsNamespace</span><span class="s3">, </span><span class="s1">MappingNamespace</span><span class="s3">, </span><span class="s1">NsResolver</span><span class="s3">, </span><span class="s1">get_module_ns_of</span>

<span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&lt; (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">10</span><span class="s3">):</span>
    <span class="s1">NoneType </span><span class="s3">= </span><span class="s1">type</span><span class="s3">(</span><span class="s2">None</span><span class="s3">)</span>
    <span class="s1">EllipsisType </span><span class="s3">= </span><span class="s1">type</span><span class="s3">(</span><span class="s1">Ellipsis</span><span class="s3">)</span>
<span class="s2">else</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s1">types </span><span class="s2">import </span><span class="s1">EllipsisType </span><span class="s2">as </span><span class="s1">EllipsisType</span>
    <span class="s2">from </span><span class="s1">types </span><span class="s2">import </span><span class="s1">NoneType </span><span class="s2">as </span><span class="s1">NoneType</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s1">pydantic </span><span class="s2">import </span><span class="s1">BaseModel</span>

<span class="s5"># As per https://typing-extensions.readthedocs.io/en/latest/#runtime-use-of-types,</span>
<span class="s5"># always check for both `typing` and `typing_extensions` variants of a typing construct.</span>
<span class="s5"># (this is implemented differently than the suggested approach in the `typing_extensions`</span>
<span class="s5"># docs for performance).</span>


<span class="s1">_t_annotated </span><span class="s3">= </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">Annotated</span>
<span class="s1">_te_annotated </span><span class="s3">= </span><span class="s1">typing_extensions</span><span class="s3">.</span><span class="s1">Annotated</span>


<span class="s2">def </span><span class="s1">is_annotated</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, /) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Return whether the provided argument is a `Annotated` special form. 
 
    ```python {test=&quot;skip&quot; lint=&quot;skip&quot;} 
    is_annotated(Annotated[int, ...]) 
    #&gt; True 
    ``` 
    &quot;&quot;&quot;</span>
    <span class="s1">origin </span><span class="s3">= </span><span class="s1">get_origin</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">origin </span><span class="s2">is </span><span class="s1">_t_annotated </span><span class="s2">or </span><span class="s1">origin </span><span class="s2">is </span><span class="s1">_te_annotated</span>


<span class="s2">def </span><span class="s1">annotated_type</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, /) </span><span class="s1">-&gt; Any </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Return the type of the `Annotated` special form, or `None`.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">__origin__ </span><span class="s2">if </span><span class="s1">typing_objects</span><span class="s3">.</span><span class="s1">is_annotated</span><span class="s3">(</span><span class="s1">get_origin</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)) </span><span class="s2">else None</span>


<span class="s2">def </span><span class="s1">unpack_type</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, /) </span><span class="s1">-&gt; Any </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Return the type wrapped by the `Unpack` special form, or `None`.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">get_args</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)[</span><span class="s4">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">typing_objects</span><span class="s3">.</span><span class="s1">is_unpack</span><span class="s3">(</span><span class="s1">get_origin</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)) </span><span class="s2">else None</span>


<span class="s2">def </span><span class="s1">is_hashable</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, /) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Return whether the provided argument is the `Hashable` class. 
 
    ```python {test=&quot;skip&quot; lint=&quot;skip&quot;} 
    is_hashable(Hashable) 
    #&gt; True 
    ``` 
    &quot;&quot;&quot;</span>
    <span class="s5"># `get_origin` is documented as normalizing any typing-module aliases to `collections` classes,</span>
    <span class="s5"># hence the second check:</span>
    <span class="s2">return </span><span class="s1">tp </span><span class="s2">is </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">Hashable </span><span class="s2">or </span><span class="s1">get_origin</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">) </span><span class="s2">is </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">Hashable</span>


<span class="s2">def </span><span class="s1">is_callable</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, /) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Return whether the provided argument is a `Callable`, parametrized or not. 
 
    ```python {test=&quot;skip&quot; lint=&quot;skip&quot;} 
    is_callable(Callable[[int], str]) 
    #&gt; True 
    is_callable(typing.Callable) 
    #&gt; True 
    is_callable(collections.abc.Callable) 
    #&gt; True 
    ``` 
    &quot;&quot;&quot;</span>
    <span class="s5"># `get_origin` is documented as normalizing any typing-module aliases to `collections` classes,</span>
    <span class="s5"># hence the second check:</span>
    <span class="s2">return </span><span class="s1">tp </span><span class="s2">is </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">Callable </span><span class="s2">or </span><span class="s1">get_origin</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">) </span><span class="s2">is </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">Callable</span>


<span class="s1">_classvar_re </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s6">r'((\w+\.)?Annotated\[)?(\w+\.)?ClassVar\['</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">is_classvar_annotation</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, /) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Return whether the provided argument represents a class variable annotation. 
 
    Although not explicitly stated by the typing specification, `ClassVar` can be used 
    inside `Annotated` and as such, this function checks for this specific scenario. 
 
    Because this function is used to detect class variables before evaluating forward references 
    (or because evaluation failed), we also implement a naive regex match implementation. This is 
    required because class variables are inspected before fields are collected, so we try to be 
    as accurate as possible. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">typing_objects</span><span class="s3">.</span><span class="s1">is_classvar</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">):</span>
        <span class="s2">return True</span>

    <span class="s1">origin </span><span class="s3">= </span><span class="s1">get_origin</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">typing_objects</span><span class="s3">.</span><span class="s1">is_classvar</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">):</span>
        <span class="s2">return True</span>

    <span class="s2">if </span><span class="s1">typing_objects</span><span class="s3">.</span><span class="s1">is_annotated</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">):</span>
        <span class="s1">annotated_type </span><span class="s3">= </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">__origin__</span>
        <span class="s2">if </span><span class="s1">typing_objects</span><span class="s3">.</span><span class="s1">is_classvar</span><span class="s3">(</span><span class="s1">annotated_type</span><span class="s3">) </span><span class="s2">or </span><span class="s1">typing_objects</span><span class="s3">.</span><span class="s1">is_classvar</span><span class="s3">(</span><span class="s1">get_origin</span><span class="s3">(</span><span class="s1">annotated_type</span><span class="s3">)):</span>
            <span class="s2">return True</span>

    <span class="s1">str_ann</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">ForwardRef</span><span class="s3">):</span>
        <span class="s1">str_ann </span><span class="s3">= </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">__forward_arg__</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
        <span class="s1">str_ann </span><span class="s3">= </span><span class="s1">tp</span>

    <span class="s2">if </span><span class="s1">str_ann </span><span class="s2">is not None and </span><span class="s1">_classvar_re</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s1">str_ann</span><span class="s3">):</span>
        <span class="s5"># stdlib dataclasses do something similar, although a bit more advanced</span>
        <span class="s5"># (see `dataclass._is_type`).</span>
        <span class="s2">return True</span>

    <span class="s2">return False</span>


<span class="s1">_t_final </span><span class="s3">= </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">Final</span>
<span class="s1">_te_final </span><span class="s3">= </span><span class="s1">typing_extensions</span><span class="s3">.</span><span class="s1">Final</span>


<span class="s5"># TODO implement `is_finalvar_annotation` as Final can be wrapped with other special forms:</span>
<span class="s2">def </span><span class="s1">is_finalvar</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, /) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Return whether the provided argument is a `Final` special form, parametrized or not. 
 
    ```python {test=&quot;skip&quot; lint=&quot;skip&quot;} 
    is_finalvar(Final[int]) 
    #&gt; True 
    is_finalvar(Final) 
    #&gt; True 
    &quot;&quot;&quot;</span>
    <span class="s5"># Final is not necessarily parametrized:</span>
    <span class="s2">if </span><span class="s1">tp </span><span class="s2">is </span><span class="s1">_t_final </span><span class="s2">or </span><span class="s1">tp </span><span class="s2">is </span><span class="s1">_te_final</span><span class="s3">:</span>
        <span class="s2">return True</span>
    <span class="s1">origin </span><span class="s3">= </span><span class="s1">get_origin</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">origin </span><span class="s2">is </span><span class="s1">_t_final </span><span class="s2">or </span><span class="s1">origin </span><span class="s2">is </span><span class="s1">_te_final</span>


<span class="s1">_NONE_TYPES</span><span class="s3">: </span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, ...] = (</span><span class="s2">None</span><span class="s3">, </span><span class="s1">NoneType</span><span class="s3">, </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">None</span><span class="s3">], </span><span class="s1">typing_extensions</span><span class="s3">.</span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">None</span><span class="s3">])</span>


<span class="s2">def </span><span class="s1">is_none_type</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, /) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Return whether the argument represents the `None` type as part of an annotation. 
 
    ```python {test=&quot;skip&quot; lint=&quot;skip&quot;} 
    is_none_type(None) 
    #&gt; True 
    is_none_type(NoneType) 
    #&gt; True 
    is_none_type(Literal[None]) 
    #&gt; True 
    is_none_type(type[None]) 
    #&gt; False 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">tp </span><span class="s2">in </span><span class="s1">_NONE_TYPES</span>


<span class="s2">def </span><span class="s1">is_namedtuple</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, /) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Return whether the provided argument is a named tuple class. 
 
    The class can be created using `typing.NamedTuple` or `collections.namedtuple`. 
    Parametrized generic classes are *not* assumed to be named tuples. 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_utils </span><span class="s2">import </span><span class="s1">lenient_issubclass  </span><span class="s5"># circ. import</span>

    <span class="s2">return </span><span class="s1">lenient_issubclass</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">) </span><span class="s2">and </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s6">'_fields'</span><span class="s3">)</span>


<span class="s5"># TODO In 2.12, delete this export. It is currently defined only to not break</span>
<span class="s5"># pydantic-settings which relies on it:</span>
<span class="s1">origin_is_union </span><span class="s3">= </span><span class="s1">is_union_origin</span>


<span class="s2">def </span><span class="s1">is_generic_alias</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, /) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s2">return </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">GenericAlias</span><span class="s3">, </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">_GenericAlias</span><span class="s3">))  </span><span class="s5"># pyright: ignore[reportAttributeAccessIssue]</span>


<span class="s5"># TODO: Ideally, we should avoid relying on the private `typing` constructs:</span>

<span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&lt; (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">10</span><span class="s3">):</span>
    <span class="s1">WithArgsTypes</span><span class="s3">: </span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, ...] = (</span><span class="s1">typing</span><span class="s3">.</span><span class="s1">_GenericAlias</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">GenericAlias</span><span class="s3">)  </span><span class="s5"># pyright: ignore[reportAttributeAccessIssue]</span>
<span class="s2">else</span><span class="s3">:</span>
    <span class="s1">WithArgsTypes</span><span class="s3">: </span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, ...] = (</span><span class="s1">typing</span><span class="s3">.</span><span class="s1">_GenericAlias</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">GenericAlias</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UnionType</span><span class="s3">)  </span><span class="s5"># pyright: ignore[reportAttributeAccessIssue]</span>


<span class="s5"># Similarly, we shouldn't rely on this `_Final` class, which is even more private than `_GenericAlias`:</span>
<span class="s1">typing_base</span><span class="s3">: </span><span class="s1">Any </span><span class="s3">= </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">_Final  </span><span class="s5"># pyright: ignore[reportAttributeAccessIssue]</span>


<span class="s5">### Annotation evaluations functions:</span>


<span class="s2">def </span><span class="s1">parent_frame_namespace</span><span class="s3">(*, </span><span class="s1">parent_depth</span><span class="s3">: </span><span class="s1">int </span><span class="s3">= </span><span class="s4">2</span><span class="s3">, </span><span class="s1">force</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">) </span><span class="s1">-&gt; dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Fetch the local namespace of the parent frame where this function is called. 
 
    Using this function is mostly useful to resolve forward annotations pointing to members defined in a local namespace, 
    such as assignments inside a function. Using the standard library tools, it is currently not possible to resolve 
    such annotations: 
 
    ```python {lint=&quot;skip&quot; test=&quot;skip&quot;} 
    from typing import get_type_hints 
 
    def func() -&gt; None: 
        Alias = int 
 
        class C: 
            a: 'Alias' 
 
        # Raises a `NameError: 'Alias' is not defined` 
        get_type_hints(C) 
    ``` 
 
    Pydantic uses this function when a Pydantic model is being defined to fetch the parent frame locals. However, 
    this only allows us to fetch the parent frame namespace and not other parents (e.g. a model defined in a function, 
    itself defined in another function). Inspecting the next outer frames (using `f_back`) is not reliable enough 
    (see https://discuss.python.org/t/20659). 
 
    Because this function is mostly used to better resolve forward annotations, nothing is returned if the parent frame's 
    code object is defined at the module level. In this case, the locals of the frame will be the same as the module 
    globals where the class is defined (see `_namespace_utils.get_module_ns_of`). However, if you still want to fetch 
    the module globals (e.g. when rebuilding a model, where the frame where the rebuild call is performed might contain 
    members that you want to use for forward annotations evaluation), you can use the `force` parameter. 
 
    Args: 
        parent_depth: The depth at which to get the frame. Defaults to 2, meaning the parent frame where this function 
            is called will be used. 
        force: Whether to always return the frame locals, even if the frame's code object is defined at the module level. 
 
    Returns: 
        The locals of the namespace, or `None` if it was skipped as per the described logic. 
    &quot;&quot;&quot;</span>
    <span class="s1">frame </span><span class="s3">= </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">_getframe</span><span class="s3">(</span><span class="s1">parent_depth</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">frame</span><span class="s3">.</span><span class="s1">f_code</span><span class="s3">.</span><span class="s1">co_name</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s6">'&lt;generic parameters of'</span><span class="s3">):</span>
        <span class="s5"># As `parent_frame_namespace` is mostly called in `ModelMetaclass.__new__`,</span>
        <span class="s5"># the parent frame can be the annotation scope if the PEP 695 generic syntax is used.</span>
        <span class="s5"># (see https://docs.python.org/3/reference/executionmodel.html#annotation-scopes,</span>
        <span class="s5"># https://docs.python.org/3/reference/compound_stmts.html#generic-classes).</span>
        <span class="s5"># In this case, the code name is set to `&lt;generic parameters of MyClass&gt;`,</span>
        <span class="s5"># and we need to skip this frame as it is irrelevant.</span>
        <span class="s1">frame </span><span class="s3">= </span><span class="s1">cast</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">FrameType</span><span class="s3">, </span><span class="s1">frame</span><span class="s3">.</span><span class="s1">f_back</span><span class="s3">)  </span><span class="s5"># guaranteed to not be `None`</span>

    <span class="s5"># note, we don't copy frame.f_locals here (or during the last return call), because we don't expect the namespace to be</span>
    <span class="s5"># modified down the line if this becomes a problem, we could implement some sort of frozen mapping structure to enforce this.</span>
    <span class="s2">if </span><span class="s1">force</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">frame</span><span class="s3">.</span><span class="s1">f_locals</span>

    <span class="s5"># If either of the following conditions are true, the class is defined at the top module level.</span>
    <span class="s5"># To better understand why we need both of these checks, see</span>
    <span class="s5"># https://github.com/pydantic/pydantic/pull/10113#discussion_r1714981531.</span>
    <span class="s2">if </span><span class="s1">frame</span><span class="s3">.</span><span class="s1">f_back </span><span class="s2">is None or </span><span class="s1">frame</span><span class="s3">.</span><span class="s1">f_code</span><span class="s3">.</span><span class="s1">co_name </span><span class="s3">== </span><span class="s6">'&lt;module&gt;'</span><span class="s3">:</span>
        <span class="s2">return None</span>

    <span class="s2">return </span><span class="s1">frame</span><span class="s3">.</span><span class="s1">f_locals</span>


<span class="s2">def </span><span class="s1">_type_convert</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Convert `None` to `NoneType` and strings to `ForwardRef` instances. 
 
    This is a backport of the private `typing._type_convert` function. When 
    evaluating a type, `ForwardRef._evaluate` ends up being called, and is 
    responsible for making this conversion. However, we still have to apply 
    it for the first argument passed to our type evaluation functions, similarly 
    to the `typing.get_type_hints` function. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">arg </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">NoneType</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
        <span class="s5"># Like `typing.get_type_hints`, assume the arg can be in any context,</span>
        <span class="s5"># hence the proper `is_argument` and `is_class` args:</span>
        <span class="s2">return </span><span class="s1">_make_forward_ref</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">is_argument</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">is_class</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">arg</span>


<span class="s2">def </span><span class="s1">get_model_type_hints</span><span class="s3">(</span>
    <span class="s1">obj</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">BaseModel</span><span class="s3">],</span>
    <span class="s3">*,</span>
    <span class="s1">ns_resolver</span><span class="s3">: </span><span class="s1">NsResolver </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">]]:</span>
    <span class="s0">&quot;&quot;&quot;Collect annotations from a Pydantic model class, including those from parent classes. 
 
    Args: 
        obj: The Pydantic model to inspect. 
        ns_resolver: A namespace resolver instance to use. Defaults to an empty instance. 
 
    Returns: 
        A dictionary mapping annotation names to a two-tuple: the first element is the evaluated 
        type or the original annotation if a `NameError` occurred, the second element is a boolean 
        indicating if whether the evaluation succeeded. 
    &quot;&quot;&quot;</span>
    <span class="s1">hints</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">]] = {}</span>
    <span class="s1">ns_resolver </span><span class="s3">= </span><span class="s1">ns_resolver </span><span class="s2">or </span><span class="s1">NsResolver</span><span class="s3">()</span>

    <span class="s2">for </span><span class="s1">base </span><span class="s2">in </span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">__mro__</span><span class="s3">):</span>
        <span class="s1">ann</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s1">base</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s6">'__annotations__'</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">ann </span><span class="s2">or </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ann</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">GetSetDescriptorType</span><span class="s3">):</span>
            <span class="s2">continue</span>
        <span class="s2">with </span><span class="s1">ns_resolver</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">base</span><span class="s3">):</span>
            <span class="s1">globalns</span><span class="s3">, </span><span class="s1">localns </span><span class="s3">= </span><span class="s1">ns_resolver</span><span class="s3">.</span><span class="s1">types_namespace</span>
            <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">ann</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s2">if </span><span class="s1">name</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s6">'_'</span><span class="s3">):</span>
                    <span class="s5"># For private attributes, we only need the annotation to detect the `ClassVar` special form.</span>
                    <span class="s5"># For this reason, we still try to evaluate it, but we also catch any possible exception (on</span>
                    <span class="s5"># top of the `NameError`s caught in `try_eval_type`) that could happen so that users are free</span>
                    <span class="s5"># to use any kind of forward annotation for private fields (e.g. circular imports, new typing</span>
                    <span class="s5"># syntax, etc).</span>
                    <span class="s2">try</span><span class="s3">:</span>
                        <span class="s1">hints</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">try_eval_type</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">globalns</span><span class="s3">, </span><span class="s1">localns</span><span class="s3">)</span>
                    <span class="s2">except </span><span class="s1">Exception</span><span class="s3">:</span>
                        <span class="s1">hints</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = (</span><span class="s1">value</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">hints</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">try_eval_type</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">globalns</span><span class="s3">, </span><span class="s1">localns</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">hints</span>


<span class="s2">def </span><span class="s1">get_cls_type_hints</span><span class="s3">(</span>
    <span class="s1">obj</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">],</span>
    <span class="s3">*,</span>
    <span class="s1">ns_resolver</span><span class="s3">: </span><span class="s1">NsResolver </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]:</span>
    <span class="s0">&quot;&quot;&quot;Collect annotations from a class, including those from parent classes. 
 
    Args: 
        obj: The class to inspect. 
        ns_resolver: A namespace resolver instance to use. Defaults to an empty instance. 
    &quot;&quot;&quot;</span>
    <span class="s1">hints</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">]] = {}</span>
    <span class="s1">ns_resolver </span><span class="s3">= </span><span class="s1">ns_resolver </span><span class="s2">or </span><span class="s1">NsResolver</span><span class="s3">()</span>

    <span class="s2">for </span><span class="s1">base </span><span class="s2">in </span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">__mro__</span><span class="s3">):</span>
        <span class="s1">ann</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s1">base</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s6">'__annotations__'</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">ann </span><span class="s2">or </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ann</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">GetSetDescriptorType</span><span class="s3">):</span>
            <span class="s2">continue</span>
        <span class="s2">with </span><span class="s1">ns_resolver</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">base</span><span class="s3">):</span>
            <span class="s1">globalns</span><span class="s3">, </span><span class="s1">localns </span><span class="s3">= </span><span class="s1">ns_resolver</span><span class="s3">.</span><span class="s1">types_namespace</span>
            <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">ann</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s1">hints</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">eval_type</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">globalns</span><span class="s3">, </span><span class="s1">localns</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">hints</span>


<span class="s2">def </span><span class="s1">try_eval_type</span><span class="s3">(</span>
    <span class="s1">value</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s1">globalns</span><span class="s3">: </span><span class="s1">GlobalsNamespace </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">localns</span><span class="s3">: </span><span class="s1">MappingNamespace </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; tuple</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">]:</span>
    <span class="s0">&quot;&quot;&quot;Try evaluating the annotation using the provided namespaces. 
 
    Args: 
        value: The value to evaluate. If `None`, it will be replaced by `type[None]`. If an instance 
            of `str`, it will be converted to a `ForwardRef`. 
        localns: The global namespace to use during annotation evaluation. 
        globalns: The local namespace to use during annotation evaluation. 
 
    Returns: 
        A two-tuple containing the possibly evaluated type and a boolean indicating 
            whether the evaluation succeeded or not. 
    &quot;&quot;&quot;</span>
    <span class="s1">value </span><span class="s3">= </span><span class="s1">_type_convert</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">eval_type_backport</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">globalns</span><span class="s3">, </span><span class="s1">localns</span><span class="s3">), </span><span class="s2">True</span>
    <span class="s2">except </span><span class="s1">NameError</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">value</span><span class="s3">, </span><span class="s2">False</span>


<span class="s2">def </span><span class="s1">eval_type</span><span class="s3">(</span>
    <span class="s1">value</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s1">globalns</span><span class="s3">: </span><span class="s1">GlobalsNamespace </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">localns</span><span class="s3">: </span><span class="s1">MappingNamespace </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Evaluate the annotation using the provided namespaces. 
 
    Args: 
        value: The value to evaluate. If `None`, it will be replaced by `type[None]`. If an instance 
            of `str`, it will be converted to a `ForwardRef`. 
        localns: The global namespace to use during annotation evaluation. 
        globalns: The local namespace to use during annotation evaluation. 
    &quot;&quot;&quot;</span>
    <span class="s1">value </span><span class="s3">= </span><span class="s1">_type_convert</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">eval_type_backport</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">globalns</span><span class="s3">, </span><span class="s1">localns</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">deprecated</span><span class="s3">(</span>
    <span class="s6">'`eval_type_lenient` is deprecated, use `try_eval_type` instead.'</span><span class="s3">,</span>
    <span class="s1">category</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">eval_type_lenient</span><span class="s3">(</span>
    <span class="s1">value</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s1">globalns</span><span class="s3">: </span><span class="s1">GlobalsNamespace </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">localns</span><span class="s3">: </span><span class="s1">MappingNamespace </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
    <span class="s1">ev</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">try_eval_type</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">globalns</span><span class="s3">, </span><span class="s1">localns</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">ev</span>


<span class="s2">def </span><span class="s1">eval_type_backport</span><span class="s3">(</span>
    <span class="s1">value</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s1">globalns</span><span class="s3">: </span><span class="s1">GlobalsNamespace </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">localns</span><span class="s3">: </span><span class="s1">MappingNamespace </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">type_params</span><span class="s3">: </span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, ...] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;An enhanced version of `typing._eval_type` which will fall back to using the `eval_type_backport` 
    package if it's installed to let older Python versions use newer typing constructs. 
 
    Specifically, this transforms `X | Y` into `typing.Union[X, Y]` and `list[X]` into `typing.List[X]` 
    (as well as all the types made generic in PEP 585) if the original syntax is not supported in the 
    current Python version. 
 
    This function will also display a helpful error if the value passed fails to evaluate. 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_eval_type_backport</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">globalns</span><span class="s3">, </span><span class="s1">localns</span><span class="s3">, </span><span class="s1">type_params</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s6">'Unable to evaluate type annotation' </span><span class="s2">in </span><span class="s1">str</span><span class="s3">(</span><span class="s1">e</span><span class="s3">):</span>
            <span class="s2">raise</span>

        <span class="s5"># If it is a `TypeError` and value isn't a `ForwardRef`, it would have failed during annotation definition.</span>
        <span class="s5"># Thus we assert here for type checking purposes:</span>
        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">ForwardRef</span><span class="s3">)</span>

        <span class="s1">message </span><span class="s3">= </span><span class="s6">f'Unable to evaluate type annotation </span><span class="s2">{</span><span class="s1">value</span><span class="s3">.</span><span class="s1">__forward_arg__</span><span class="s2">!r}</span><span class="s6">.'</span>
        <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">11</span><span class="s3">):</span>
            <span class="s1">e</span><span class="s3">.</span><span class="s1">add_note</span><span class="s3">(</span><span class="s1">message</span><span class="s3">)</span>
            <span class="s2">raise</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s1">message</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>
    <span class="s2">except </span><span class="s1">RecursionError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s5"># TODO ideally recursion errors should be checked in `eval_type` above, but `eval_type_backport`</span>
        <span class="s5"># is used directly in some places.</span>
        <span class="s1">message </span><span class="s3">= (</span>
            <span class="s6">&quot;If you made use of an implicit recursive type alias (e.g. `MyType = list['MyType']), &quot;</span>
            <span class="s6">'consider using PEP 695 type aliases instead. For more details, refer to the documentation: '</span>
            <span class="s6">f'https://docs.pydantic.dev/</span><span class="s2">{</span><span class="s1">version_short</span><span class="s3">()</span><span class="s2">}</span><span class="s6">/concepts/types/#named-recursive-types'</span>
        <span class="s3">)</span>
        <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">11</span><span class="s3">):</span>
            <span class="s1">e</span><span class="s3">.</span><span class="s1">add_note</span><span class="s3">(</span><span class="s1">message</span><span class="s3">)</span>
            <span class="s2">raise</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">RecursionError</span><span class="s3">(</span><span class="s6">f'</span><span class="s2">{</span><span class="s1">e</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span><span class="s2">}\n{</span><span class="s1">message</span><span class="s2">}</span><span class="s6">'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_eval_type_backport</span><span class="s3">(</span>
    <span class="s1">value</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s1">globalns</span><span class="s3">: </span><span class="s1">GlobalsNamespace </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">localns</span><span class="s3">: </span><span class="s1">MappingNamespace </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">type_params</span><span class="s3">: </span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, ...] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_eval_type</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">globalns</span><span class="s3">, </span><span class="s1">localns</span><span class="s3">, </span><span class="s1">type_params</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s2">if not </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">ForwardRef</span><span class="s3">) </span><span class="s2">and </span><span class="s1">is_backport_fixable_error</span><span class="s3">(</span><span class="s1">e</span><span class="s3">)):</span>
            <span class="s2">raise</span>

        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">from </span><span class="s1">eval_type_backport </span><span class="s2">import </span><span class="s1">eval_type_backport</span>
        <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
                <span class="s6">f'Unable to evaluate type annotation </span><span class="s2">{</span><span class="s1">value</span><span class="s3">.</span><span class="s1">__forward_arg__</span><span class="s2">!r}</span><span class="s6">. If you are making use '</span>
                <span class="s6">'of the new typing syntax (unions using `|` since Python 3.10 or builtins subscripting '</span>
                <span class="s6">'since Python 3.9), you should either replace the use of new syntax with the existing '</span>
                <span class="s6">'`typing` constructs or install the `eval_type_backport` package.'</span>
            <span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>

        <span class="s2">return </span><span class="s1">eval_type_backport</span><span class="s3">(</span>
            <span class="s1">value</span><span class="s3">,</span>
            <span class="s1">globalns</span><span class="s3">,</span>
            <span class="s1">localns</span><span class="s3">,  </span><span class="s5"># pyright: ignore[reportArgumentType], waiting on a new `eval_type_backport` release.</span>
            <span class="s1">try_default</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s3">)</span>


<span class="s2">def </span><span class="s1">_eval_type</span><span class="s3">(</span>
    <span class="s1">value</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s1">globalns</span><span class="s3">: </span><span class="s1">GlobalsNamespace </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">localns</span><span class="s3">: </span><span class="s1">MappingNamespace </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">type_params</span><span class="s3">: </span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, ...] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
    <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">13</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">_eval_type</span><span class="s3">(  </span><span class="s5"># type: ignore</span>
            <span class="s1">value</span><span class="s3">, </span><span class="s1">globalns</span><span class="s3">, </span><span class="s1">localns</span><span class="s3">, </span><span class="s1">type_params</span><span class="s3">=</span><span class="s1">type_params</span>
        <span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">_eval_type</span><span class="s3">(  </span><span class="s5"># type: ignore</span>
            <span class="s1">value</span><span class="s3">, </span><span class="s1">globalns</span><span class="s3">, </span><span class="s1">localns</span>
        <span class="s3">)</span>


<span class="s2">def </span><span class="s1">is_backport_fixable_error</span><span class="s3">(</span><span class="s1">e</span><span class="s3">: </span><span class="s1">TypeError</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s1">msg </span><span class="s3">= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">e</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&lt; (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">10</span><span class="s3">) </span><span class="s2">and </span><span class="s1">msg</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s6">'unsupported operand type(s) for |: '</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">get_function_type_hints</span><span class="s3">(</span>
    <span class="s1">function</span><span class="s3">: </span><span class="s1">Callable</span><span class="s3">[..., </span><span class="s1">Any</span><span class="s3">],</span>
    <span class="s3">*,</span>
    <span class="s1">include_keys</span><span class="s3">: </span><span class="s1">set</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">globalns</span><span class="s3">: </span><span class="s1">GlobalsNamespace </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">localns</span><span class="s3">: </span><span class="s1">MappingNamespace </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]:</span>
    <span class="s0">&quot;&quot;&quot;Return type hints for a function. 
 
    This is similar to the `typing.get_type_hints` function, with a few differences: 
    - Support `functools.partial` by using the underlying `func` attribute. 
    - Do not wrap type annotation of a parameter with `Optional` if it has a default value of `None` 
      (related bug: https://github.com/python/cpython/issues/90353, only fixed in 3.11+). 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">function</span><span class="s3">, </span><span class="s1">partial</span><span class="s3">):</span>
            <span class="s1">annotations </span><span class="s3">= </span><span class="s1">function</span><span class="s3">.</span><span class="s1">func</span><span class="s3">.</span><span class="s1">__annotations__</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">annotations </span><span class="s3">= </span><span class="s1">function</span><span class="s3">.</span><span class="s1">__annotations__</span>
    <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
        <span class="s5"># Some functions (e.g. builtins) don't have annotations:</span>
        <span class="s2">return </span><span class="s3">{}</span>

    <span class="s2">if </span><span class="s1">globalns </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">globalns </span><span class="s3">= </span><span class="s1">get_module_ns_of</span><span class="s3">(</span><span class="s1">function</span><span class="s3">)</span>
    <span class="s1">type_params</span><span class="s3">: </span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, ...] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">localns </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s5"># If localns was specified, it is assumed to already contain type params. This is because</span>
        <span class="s5"># Pydantic has more advanced logic to do so (see `_namespace_utils.ns_for_function`).</span>
        <span class="s1">type_params </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">function</span><span class="s3">, </span><span class="s6">'__type_params__'</span><span class="s3">, ())</span>

    <span class="s1">type_hints </span><span class="s3">= {}</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">annotations</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s2">if </span><span class="s1">include_keys </span><span class="s2">is not None and </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">include_keys</span><span class="s3">:</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">value </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">value </span><span class="s3">= </span><span class="s1">NoneType</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
            <span class="s1">value </span><span class="s3">= </span><span class="s1">_make_forward_ref</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>

        <span class="s1">type_hints</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">eval_type_backport</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">globalns</span><span class="s3">, </span><span class="s1">localns</span><span class="s3">, </span><span class="s1">type_params</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">type_hints</span>


<span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&lt; (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">9</span><span class="s3">, </span><span class="s4">8</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s4">10</span><span class="s3">) &lt;= </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&lt; (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">10</span><span class="s3">, </span><span class="s4">1</span><span class="s3">):</span>

    <span class="s2">def </span><span class="s1">_make_forward_ref</span><span class="s3">(</span>
        <span class="s1">arg</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
        <span class="s1">is_argument</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">is_class</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; typing</span><span class="s3">.</span><span class="s1">ForwardRef</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Wrapper for ForwardRef that accounts for the `is_class` argument missing in older versions. 
        The `module` argument is omitted as it breaks &lt;3.9.8, =3.10.0 and isn't used in the calls below. 
 
        See https://github.com/python/cpython/pull/28560 for some background. 
        The backport happened on 3.9.8, see: 
        https://github.com/pydantic/pydantic/discussions/6244#discussioncomment-6275458, 
        and on 3.10.1 for the 3.10 branch, see: 
        https://github.com/pydantic/pydantic/issues/6912 
 
        Implemented as EAFP with memory. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">ForwardRef</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">is_argument</span><span class="s3">)</span>

<span class="s2">else</span><span class="s3">:</span>
    <span class="s1">_make_forward_ref </span><span class="s3">= </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">ForwardRef</span>


<span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">10</span><span class="s3">):</span>
    <span class="s1">get_type_hints </span><span class="s3">= </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">get_type_hints</span>

<span class="s2">else</span><span class="s3">:</span>
    <span class="s6">&quot;&quot;&quot; 
    For older versions of python, we have a custom implementation of `get_type_hints` which is a close as possible to 
    the implementation in CPython 3.10.8. 
    &quot;&quot;&quot;</span>

    <span class="s3">@</span><span class="s1">typing</span><span class="s3">.</span><span class="s1">no_type_check</span>
    <span class="s2">def </span><span class="s1">get_type_hints</span><span class="s3">(  </span><span class="s5"># noqa: C901</span>
        <span class="s1">obj</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
        <span class="s1">globalns</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">localns</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">include_extras</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]:  </span><span class="s5"># pragma: no cover</span>
        <span class="s0">&quot;&quot;&quot;Taken verbatim from python 3.10.8 unchanged, except: 
        * type annotations of the function definition above. 
        * prefixing `typing.` where appropriate 
        * Use `_make_forward_ref` instead of `typing.ForwardRef` to handle the `is_class` argument. 
 
        https://github.com/python/cpython/blob/aaaf5174241496afca7ce4d4584570190ff972fe/Lib/typing.py#L1773-L1875 
 
        DO NOT CHANGE THIS METHOD UNLESS ABSOLUTELY NECESSARY. 
        ====================================================== 
 
        Return type hints for an object. 
 
        This is often the same as obj.__annotations__, but it handles 
        forward references encoded as string literals, adds Optional[t] if a 
        default value equal to None is set and recursively replaces all 
        'Annotated[T, ...]' with 'T' (unless 'include_extras=True'). 
 
        The argument may be a module, class, method, or function. The annotations 
        are returned as a dictionary. For classes, annotations include also 
        inherited members. 
 
        TypeError is raised if the argument is not of a type that can contain 
        annotations, and an empty dictionary is returned if no annotations are 
        present. 
 
        BEWARE -- the behavior of globalns and localns is counterintuitive 
        (unless you are familiar with how eval() and exec() work).  The 
        search order is locals first, then globals. 
 
        - If no dict arguments are passed, an attempt is made to use the 
          globals from obj (or the respective module's globals for classes), 
          and these are also used as the locals.  If the object does not appear 
          to have globals, an empty dictionary is used.  For classes, the search 
          order is globals first then locals. 
 
        - If one dict argument is passed, it is used for both globals and 
          locals. 
 
        - If two dict arguments are passed, they specify globals and 
          locals, respectively. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s6">'__no_type_check__'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s3">{}</span>
        <span class="s5"># Classes require a special treatment.</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">type</span><span class="s3">):</span>
            <span class="s1">hints </span><span class="s3">= {}</span>
            <span class="s2">for </span><span class="s1">base </span><span class="s2">in </span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">__mro__</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">globalns </span><span class="s2">is None</span><span class="s3">:</span>
                    <span class="s1">base_globals </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">base</span><span class="s3">.</span><span class="s1">__module__</span><span class="s3">, </span><span class="s2">None</span><span class="s3">), </span><span class="s6">'__dict__'</span><span class="s3">, {})</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">base_globals </span><span class="s3">= </span><span class="s1">globalns</span>
                <span class="s1">ann </span><span class="s3">= </span><span class="s1">base</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s6">'__annotations__'</span><span class="s3">, {})</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ann</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">GetSetDescriptorType</span><span class="s3">):</span>
                    <span class="s1">ann </span><span class="s3">= {}</span>
                <span class="s1">base_locals </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">vars</span><span class="s3">(</span><span class="s1">base</span><span class="s3">)) </span><span class="s2">if </span><span class="s1">localns </span><span class="s2">is None else </span><span class="s1">localns</span>
                <span class="s2">if </span><span class="s1">localns </span><span class="s2">is None and </span><span class="s1">globalns </span><span class="s2">is None</span><span class="s3">:</span>
                    <span class="s5"># This is surprising, but required.  Before Python 3.10,</span>
                    <span class="s5"># get_type_hints only evaluated the globalns of</span>
                    <span class="s5"># a class.  To maintain backwards compatibility, we reverse</span>
                    <span class="s5"># the globalns and localns order so that eval() looks into</span>
                    <span class="s5"># *base_globals* first rather than *base_locals*.</span>
                    <span class="s5"># This only affects ForwardRefs.</span>
                    <span class="s1">base_globals</span><span class="s3">, </span><span class="s1">base_locals </span><span class="s3">= </span><span class="s1">base_locals</span><span class="s3">, </span><span class="s1">base_globals</span>
                <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">ann</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                    <span class="s2">if </span><span class="s1">value </span><span class="s2">is None</span><span class="s3">:</span>
                        <span class="s1">value </span><span class="s3">= </span><span class="s1">type</span><span class="s3">(</span><span class="s2">None</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
                        <span class="s1">value </span><span class="s3">= </span><span class="s1">_make_forward_ref</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">is_argument</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">is_class</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

                    <span class="s1">value </span><span class="s3">= </span><span class="s1">eval_type_backport</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">base_globals</span><span class="s3">, </span><span class="s1">base_locals</span><span class="s3">)</span>
                    <span class="s1">hints</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">value</span>
            <span class="s2">if not </span><span class="s1">include_extras </span><span class="s2">and </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">typing</span><span class="s3">, </span><span class="s6">'_strip_annotations'</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s3">{</span>
                    <span class="s1">k</span><span class="s3">: </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">_strip_annotations</span><span class="s3">(</span><span class="s1">t</span><span class="s3">)  </span><span class="s5"># type: ignore</span>
                    <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">t </span><span class="s2">in </span><span class="s1">hints</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
                <span class="s3">}</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">hints</span>

        <span class="s2">if </span><span class="s1">globalns </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ModuleType</span><span class="s3">):</span>
                <span class="s1">globalns </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">__dict__</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">nsobj </span><span class="s3">= </span><span class="s1">obj</span>
                <span class="s5"># Find globalns for the unwrapped object.</span>
                <span class="s2">while </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">nsobj</span><span class="s3">, </span><span class="s6">'__wrapped__'</span><span class="s3">):</span>
                    <span class="s1">nsobj </span><span class="s3">= </span><span class="s1">nsobj</span><span class="s3">.</span><span class="s1">__wrapped__</span>
                <span class="s1">globalns </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">nsobj</span><span class="s3">, </span><span class="s6">'__globals__'</span><span class="s3">, {})</span>
            <span class="s2">if </span><span class="s1">localns </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">localns </span><span class="s3">= </span><span class="s1">globalns</span>
        <span class="s2">elif </span><span class="s1">localns </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">localns </span><span class="s3">= </span><span class="s1">globalns</span>
        <span class="s1">hints </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s6">'__annotations__'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">hints </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s5"># Return empty annotations for something that _could_ have them.</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">_allowed_types</span><span class="s3">):  </span><span class="s5"># type: ignore</span>
                <span class="s2">return </span><span class="s3">{}</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s6">f'</span><span class="s2">{</span><span class="s1">obj</span><span class="s2">!r} </span><span class="s6">is not a module, class, method, or function.'</span><span class="s3">)</span>
        <span class="s1">defaults </span><span class="s3">= </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">_get_defaults</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)  </span><span class="s5"># type: ignore</span>
        <span class="s1">hints </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">hints</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">hints</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s1">value </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">value </span><span class="s3">= </span><span class="s1">type</span><span class="s3">(</span><span class="s2">None</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
                <span class="s5"># class-level forward refs were handled above, this must be either</span>
                <span class="s5"># a module-level annotation or a function argument annotation</span>

                <span class="s1">value </span><span class="s3">= </span><span class="s1">_make_forward_ref</span><span class="s3">(</span>
                    <span class="s1">value</span><span class="s3">,</span>
                    <span class="s1">is_argument</span><span class="s3">=</span><span class="s2">not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ModuleType</span><span class="s3">),</span>
                    <span class="s1">is_class</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                <span class="s3">)</span>
            <span class="s1">value </span><span class="s3">= </span><span class="s1">eval_type_backport</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">globalns</span><span class="s3">, </span><span class="s1">localns</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">defaults </span><span class="s2">and </span><span class="s1">defaults</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">value </span><span class="s3">= </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">value</span><span class="s3">]</span>
            <span class="s1">hints</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">value</span>
        <span class="s2">return </span><span class="s1">hints </span><span class="s2">if </span><span class="s1">include_extras </span><span class="s2">else </span><span class="s3">{</span><span class="s1">k</span><span class="s3">: </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">_strip_annotations</span><span class="s3">(</span><span class="s1">t</span><span class="s3">) </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">t </span><span class="s2">in </span><span class="s1">hints</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()}  </span><span class="s5"># type: ignore</span>
</pre>
</body>
</html>