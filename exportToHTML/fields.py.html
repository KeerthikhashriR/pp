<html>
<head>
<title>fields.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
fields.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">copy</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">Counter </span><span class="s0">as </span><span class="s1">CollectionCounter</span><span class="s2">, </span><span class="s1">defaultdict</span><span class="s2">, </span><span class="s1">deque</span>
<span class="s0">from </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc </span><span class="s0">import </span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">Hashable </span><span class="s0">as </span><span class="s1">CollectionsHashable</span><span class="s2">, </span><span class="s1">Iterable </span><span class="s0">as </span><span class="s1">CollectionsIterable</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">Counter</span><span class="s2">,</span>
    <span class="s1">DefaultDict</span><span class="s2">,</span>
    <span class="s1">Deque</span><span class="s2">,</span>
    <span class="s1">Dict</span><span class="s2">,</span>
    <span class="s1">ForwardRef</span><span class="s2">,</span>
    <span class="s1">FrozenSet</span><span class="s2">,</span>
    <span class="s1">Generator</span><span class="s2">,</span>
    <span class="s1">Iterable</span><span class="s2">,</span>
    <span class="s1">Iterator</span><span class="s2">,</span>
    <span class="s1">List</span><span class="s2">,</span>
    <span class="s1">Mapping</span><span class="s2">,</span>
    <span class="s1">Optional</span><span class="s2">,</span>
    <span class="s1">Pattern</span><span class="s2">,</span>
    <span class="s1">Sequence</span><span class="s2">,</span>
    <span class="s1">Set</span><span class="s2">,</span>
    <span class="s1">Tuple</span><span class="s2">,</span>
    <span class="s1">Type</span><span class="s2">,</span>
    <span class="s1">TypeVar</span><span class="s2">,</span>
    <span class="s1">Union</span><span class="s2">,</span>
<span class="s2">)</span>

<span class="s0">from </span><span class="s1">typing_extensions </span><span class="s0">import </span><span class="s1">Annotated</span><span class="s2">, </span><span class="s1">Final</span>

<span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1 </span><span class="s0">import </span><span class="s1">errors </span><span class="s0">as </span><span class="s1">errors_</span>
<span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">class_validators </span><span class="s0">import </span><span class="s1">Validator</span><span class="s2">, </span><span class="s1">make_generic_validator</span><span class="s2">, </span><span class="s1">prep_validators</span>
<span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">error_wrappers </span><span class="s0">import </span><span class="s1">ErrorWrapper</span>
<span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">errors </span><span class="s0">import </span><span class="s1">ConfigError</span><span class="s2">, </span><span class="s1">InvalidDiscriminator</span><span class="s2">, </span><span class="s1">MissingDiscriminator</span><span class="s2">, </span><span class="s1">NoneIsNotAllowedError</span>
<span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">types </span><span class="s0">import </span><span class="s1">Json</span><span class="s2">, </span><span class="s1">JsonWrapper</span>
<span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">typing </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">NoArgAnyCallable</span><span class="s2">,</span>
    <span class="s1">convert_generics</span><span class="s2">,</span>
    <span class="s1">display_as_type</span><span class="s2">,</span>
    <span class="s1">get_args</span><span class="s2">,</span>
    <span class="s1">get_origin</span><span class="s2">,</span>
    <span class="s1">is_finalvar</span><span class="s2">,</span>
    <span class="s1">is_literal_type</span><span class="s2">,</span>
    <span class="s1">is_new_type</span><span class="s2">,</span>
    <span class="s1">is_none_type</span><span class="s2">,</span>
    <span class="s1">is_typeddict</span><span class="s2">,</span>
    <span class="s1">is_typeddict_special</span><span class="s2">,</span>
    <span class="s1">is_union</span><span class="s2">,</span>
    <span class="s1">new_type_supertype</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">utils </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">PyObjectStr</span><span class="s2">,</span>
    <span class="s1">Representation</span><span class="s2">,</span>
    <span class="s1">ValueItems</span><span class="s2">,</span>
    <span class="s1">get_discriminator_alias_and_values</span><span class="s2">,</span>
    <span class="s1">get_unique_discriminator_alias</span><span class="s2">,</span>
    <span class="s1">lenient_isinstance</span><span class="s2">,</span>
    <span class="s1">lenient_issubclass</span><span class="s2">,</span>
    <span class="s1">sequence_like</span><span class="s2">,</span>
    <span class="s1">smart_deepcopy</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">validators </span><span class="s0">import </span><span class="s1">constant_validator</span><span class="s2">, </span><span class="s1">dict_validator</span><span class="s2">, </span><span class="s1">find_validators</span><span class="s2">, </span><span class="s1">validate_json</span>

<span class="s1">Required</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">= </span><span class="s1">Ellipsis</span>

<span class="s1">T </span><span class="s2">= </span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s3">'T'</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">UndefinedType</span><span class="s2">:</span>
    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s3">'PydanticUndefined'</span>

    <span class="s0">def </span><span class="s1">__copy__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">: </span><span class="s1">T</span><span class="s2">) </span><span class="s1">-&gt; T</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__reduce__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s3">'Undefined'</span>

    <span class="s0">def </span><span class="s1">__deepcopy__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">_</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">) </span><span class="s1">-&gt; T</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span>


<span class="s1">Undefined </span><span class="s2">= </span><span class="s1">UndefinedType</span><span class="s2">()</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">class_validators </span><span class="s0">import </span><span class="s1">ValidatorsList</span>
    <span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">config </span><span class="s0">import </span><span class="s1">BaseConfig</span>
    <span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">error_wrappers </span><span class="s0">import </span><span class="s1">ErrorList</span>
    <span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">types </span><span class="s0">import </span><span class="s1">ModelOrDc</span>
    <span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">typing </span><span class="s0">import </span><span class="s1">AbstractSetIntStr</span><span class="s2">, </span><span class="s1">MappingIntStrAny</span><span class="s2">, </span><span class="s1">ReprArgs</span>

    <span class="s1">ValidateReturn </span><span class="s2">= </span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">], </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">ErrorList</span><span class="s2">]]</span>
    <span class="s1">LocStr </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">Union</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, </span><span class="s1">str</span><span class="s2">], ...], </span><span class="s1">str</span><span class="s2">]</span>
    <span class="s1">BoolUndefined </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">bool</span><span class="s2">, </span><span class="s1">UndefinedType</span><span class="s2">]</span>


<span class="s0">class </span><span class="s1">FieldInfo</span><span class="s2">(</span><span class="s1">Representation</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Captures extra information about a field. 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s2">= (</span>
        <span class="s3">'default'</span><span class="s2">,</span>
        <span class="s3">'default_factory'</span><span class="s2">,</span>
        <span class="s3">'alias'</span><span class="s2">,</span>
        <span class="s3">'alias_priority'</span><span class="s2">,</span>
        <span class="s3">'title'</span><span class="s2">,</span>
        <span class="s3">'description'</span><span class="s2">,</span>
        <span class="s3">'exclude'</span><span class="s2">,</span>
        <span class="s3">'include'</span><span class="s2">,</span>
        <span class="s3">'const'</span><span class="s2">,</span>
        <span class="s3">'gt'</span><span class="s2">,</span>
        <span class="s3">'ge'</span><span class="s2">,</span>
        <span class="s3">'lt'</span><span class="s2">,</span>
        <span class="s3">'le'</span><span class="s2">,</span>
        <span class="s3">'multiple_of'</span><span class="s2">,</span>
        <span class="s3">'allow_inf_nan'</span><span class="s2">,</span>
        <span class="s3">'max_digits'</span><span class="s2">,</span>
        <span class="s3">'decimal_places'</span><span class="s2">,</span>
        <span class="s3">'min_items'</span><span class="s2">,</span>
        <span class="s3">'max_items'</span><span class="s2">,</span>
        <span class="s3">'unique_items'</span><span class="s2">,</span>
        <span class="s3">'min_length'</span><span class="s2">,</span>
        <span class="s3">'max_length'</span><span class="s2">,</span>
        <span class="s3">'allow_mutation'</span><span class="s2">,</span>
        <span class="s3">'repr'</span><span class="s2">,</span>
        <span class="s3">'regex'</span><span class="s2">,</span>
        <span class="s3">'discriminator'</span><span class="s2">,</span>
        <span class="s3">'extra'</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s5"># field constraints with the default value, it's also used in update_from_config below</span>
    <span class="s1">__field_constraints__ </span><span class="s2">= {</span>
        <span class="s3">'min_length'</span><span class="s2">: </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s3">'max_length'</span><span class="s2">: </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s3">'regex'</span><span class="s2">: </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s3">'gt'</span><span class="s2">: </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s3">'lt'</span><span class="s2">: </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s3">'ge'</span><span class="s2">: </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s3">'le'</span><span class="s2">: </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s3">'multiple_of'</span><span class="s2">: </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s3">'allow_inf_nan'</span><span class="s2">: </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s3">'max_digits'</span><span class="s2">: </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s3">'decimal_places'</span><span class="s2">: </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s3">'min_items'</span><span class="s2">: </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s3">'max_items'</span><span class="s2">: </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s3">'unique_items'</span><span class="s2">: </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s3">'allow_mutation'</span><span class="s2">: </span><span class="s0">True</span><span class="s2">,</span>
    <span class="s2">}</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">default</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">= </span><span class="s1">Undefined</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">default </span><span class="s2">= </span><span class="s1">default</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">default_factory </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'default_factory'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">alias </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'alias'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">alias_priority </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'alias_priority'</span><span class="s2">, </span><span class="s6">2 </span><span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">alias </span><span class="s0">is not None else None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">title </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'title'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">description </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'description'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">exclude </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'exclude'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">include </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'include'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">const </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'const'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">gt </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'gt'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">ge </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'ge'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">lt </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'lt'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">le </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'le'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">multiple_of </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'multiple_of'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">allow_inf_nan </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'allow_inf_nan'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">max_digits </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'max_digits'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">decimal_places </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'decimal_places'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">min_items </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'min_items'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">max_items </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'max_items'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">unique_items </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'unique_items'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">min_length </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'min_length'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">max_length </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'max_length'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">allow_mutation </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'allow_mutation'</span><span class="s2">, </span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">regex </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'regex'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">discriminator </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'discriminator'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">repr </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'repr'</span><span class="s2">, </span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">extra </span><span class="s2">= </span><span class="s1">kwargs</span>

    <span class="s0">def </span><span class="s1">__repr_args__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s3">'ReprArgs'</span><span class="s2">:</span>
        <span class="s1">field_defaults_to_hide</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] = {</span>
            <span class="s3">'repr'</span><span class="s2">: </span><span class="s0">True</span><span class="s2">,</span>
            <span class="s2">**</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__field_constraints__</span><span class="s2">,</span>
        <span class="s2">}</span>

        <span class="s1">attrs </span><span class="s2">= ((</span><span class="s1">s</span><span class="s2">, </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">s</span><span class="s2">)) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__slots__</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s2">[(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">v</span><span class="s2">) </span><span class="s0">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">attrs </span><span class="s0">if </span><span class="s1">v </span><span class="s2">!= </span><span class="s1">field_defaults_to_hide</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)]</span>

    <span class="s0">def </span><span class="s1">get_constraints</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]:</span>
        <span class="s4">&quot;&quot;&quot; 
        Gets the constraints set on the field by comparing the constraint value with its default value 
 
        :return: the constraints set on field_info 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s2">{</span><span class="s1">attr </span><span class="s0">for </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">default </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__field_constraints__</span><span class="s2">.</span><span class="s1">items</span><span class="s2">() </span><span class="s0">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">) != </span><span class="s1">default</span><span class="s2">}</span>

    <span class="s0">def </span><span class="s1">update_from_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">from_config</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Update this FieldInfo based on a dict from get_field_info, only fields which have not been set are dated. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">attr_name</span><span class="s2">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">from_config</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">current_value </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">attr_name</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">AttributeError</span><span class="s2">:</span>
                <span class="s5"># attr_name is not an attribute of FieldInfo, it should therefore be added to extra</span>
                <span class="s5"># (except if extra already has this value!)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">extra</span><span class="s2">.</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s1">attr_name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">current_value </span><span class="s0">is </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__field_constraints__</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">attr_name</span><span class="s2">, </span><span class="s0">None</span><span class="s2">):</span>
                    <span class="s1">setattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">attr_name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>
                <span class="s0">elif </span><span class="s1">attr_name </span><span class="s2">== </span><span class="s3">'exclude'</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">exclude </span><span class="s2">= </span><span class="s1">ValueItems</span><span class="s2">.</span><span class="s1">merge</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">current_value</span><span class="s2">)</span>
                <span class="s0">elif </span><span class="s1">attr_name </span><span class="s2">== </span><span class="s3">'include'</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">include </span><span class="s2">= </span><span class="s1">ValueItems</span><span class="s2">.</span><span class="s1">merge</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">current_value</span><span class="s2">, </span><span class="s1">intersect</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_validate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">default </span><span class="s0">is not </span><span class="s1">Undefined </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">default_factory </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'cannot specify both default and default_factory'</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">Field</span><span class="s2">(</span>
    <span class="s1">default</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">= </span><span class="s1">Undefined</span><span class="s2">,</span>
    <span class="s2">*,</span>
    <span class="s1">default_factory</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">NoArgAnyCallable</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">alias</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">title</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">description</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">exclude</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Union</span><span class="s2">[</span><span class="s3">'AbstractSetIntStr'</span><span class="s2">, </span><span class="s3">'MappingIntStrAny'</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">include</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Union</span><span class="s2">[</span><span class="s3">'AbstractSetIntStr'</span><span class="s2">, </span><span class="s3">'MappingIntStrAny'</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">const</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">bool</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">gt</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">float</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">ge</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">float</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">lt</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">float</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">le</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">float</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">multiple_of</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">float</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">allow_inf_nan</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">bool</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">max_digits</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">int</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">decimal_places</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">int</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">min_items</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">int</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">max_items</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">int</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">unique_items</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">bool</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">min_length</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">int</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">max_length</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">int</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">allow_mutation</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
    <span class="s1">regex</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">discriminator</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">repr</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
    <span class="s2">**</span><span class="s1">extra</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Used to provide extra information about a field, either for the model schema or complex validation. Some arguments 
    apply only to number fields (``int``, ``float``, ``Decimal``) and some apply only to ``str``. 
 
    :param default: since this is replacing the field’s default, its first argument is used 
      to set the default, use ellipsis (``...``) to indicate the field is required 
    :param default_factory: callable that will be called when a default value is needed for this field 
      If both `default` and `default_factory` are set, an error is raised. 
    :param alias: the public name of the field 
    :param title: can be any string, used in the schema 
    :param description: can be any string, used in the schema 
    :param exclude: exclude this field while dumping. 
      Takes same values as the ``include`` and ``exclude`` arguments on the ``.dict`` method. 
    :param include: include this field while dumping. 
      Takes same values as the ``include`` and ``exclude`` arguments on the ``.dict`` method. 
    :param const: this field is required and *must* take it's default value 
    :param gt: only applies to numbers, requires the field to be &quot;greater than&quot;. The schema 
      will have an ``exclusiveMinimum`` validation keyword 
    :param ge: only applies to numbers, requires the field to be &quot;greater than or equal to&quot;. The 
      schema will have a ``minimum`` validation keyword 
    :param lt: only applies to numbers, requires the field to be &quot;less than&quot;. The schema 
      will have an ``exclusiveMaximum`` validation keyword 
    :param le: only applies to numbers, requires the field to be &quot;less than or equal to&quot;. The 
      schema will have a ``maximum`` validation keyword 
    :param multiple_of: only applies to numbers, requires the field to be &quot;a multiple of&quot;. The 
      schema will have a ``multipleOf`` validation keyword 
    :param allow_inf_nan: only applies to numbers, allows the field to be NaN or infinity (+inf or -inf), 
        which is a valid Python float. Default True, set to False for compatibility with JSON. 
    :param max_digits: only applies to Decimals, requires the field to have a maximum number 
      of digits within the decimal. It does not include a zero before the decimal point or trailing decimal zeroes. 
    :param decimal_places: only applies to Decimals, requires the field to have at most a number of decimal places 
      allowed. It does not include trailing decimal zeroes. 
    :param min_items: only applies to lists, requires the field to have a minimum number of 
      elements. The schema will have a ``minItems`` validation keyword 
    :param max_items: only applies to lists, requires the field to have a maximum number of 
      elements. The schema will have a ``maxItems`` validation keyword 
    :param unique_items: only applies to lists, requires the field not to have duplicated 
      elements. The schema will have a ``uniqueItems`` validation keyword 
    :param min_length: only applies to strings, requires the field to have a minimum length. The 
      schema will have a ``minLength`` validation keyword 
    :param max_length: only applies to strings, requires the field to have a maximum length. The 
      schema will have a ``maxLength`` validation keyword 
    :param allow_mutation: a boolean which defaults to True. When False, the field raises a TypeError if the field is 
      assigned on an instance.  The BaseModel Config must set validate_assignment to True 
    :param regex: only applies to strings, requires the field match against a regular expression 
      pattern string. The schema will have a ``pattern`` validation keyword 
    :param discriminator: only useful with a (discriminated a.k.a. tagged) `Union` of sub models with a common field. 
      The `discriminator` is the name of this common field to shorten validation and improve generated schema 
    :param repr: show this field in the representation 
    :param **extra: any additional keyword arguments will be added as is to the schema 
    &quot;&quot;&quot;</span>
    <span class="s1">field_info </span><span class="s2">= </span><span class="s1">FieldInfo</span><span class="s2">(</span>
        <span class="s1">default</span><span class="s2">,</span>
        <span class="s1">default_factory</span><span class="s2">=</span><span class="s1">default_factory</span><span class="s2">,</span>
        <span class="s1">alias</span><span class="s2">=</span><span class="s1">alias</span><span class="s2">,</span>
        <span class="s1">title</span><span class="s2">=</span><span class="s1">title</span><span class="s2">,</span>
        <span class="s1">description</span><span class="s2">=</span><span class="s1">description</span><span class="s2">,</span>
        <span class="s1">exclude</span><span class="s2">=</span><span class="s1">exclude</span><span class="s2">,</span>
        <span class="s1">include</span><span class="s2">=</span><span class="s1">include</span><span class="s2">,</span>
        <span class="s1">const</span><span class="s2">=</span><span class="s1">const</span><span class="s2">,</span>
        <span class="s1">gt</span><span class="s2">=</span><span class="s1">gt</span><span class="s2">,</span>
        <span class="s1">ge</span><span class="s2">=</span><span class="s1">ge</span><span class="s2">,</span>
        <span class="s1">lt</span><span class="s2">=</span><span class="s1">lt</span><span class="s2">,</span>
        <span class="s1">le</span><span class="s2">=</span><span class="s1">le</span><span class="s2">,</span>
        <span class="s1">multiple_of</span><span class="s2">=</span><span class="s1">multiple_of</span><span class="s2">,</span>
        <span class="s1">allow_inf_nan</span><span class="s2">=</span><span class="s1">allow_inf_nan</span><span class="s2">,</span>
        <span class="s1">max_digits</span><span class="s2">=</span><span class="s1">max_digits</span><span class="s2">,</span>
        <span class="s1">decimal_places</span><span class="s2">=</span><span class="s1">decimal_places</span><span class="s2">,</span>
        <span class="s1">min_items</span><span class="s2">=</span><span class="s1">min_items</span><span class="s2">,</span>
        <span class="s1">max_items</span><span class="s2">=</span><span class="s1">max_items</span><span class="s2">,</span>
        <span class="s1">unique_items</span><span class="s2">=</span><span class="s1">unique_items</span><span class="s2">,</span>
        <span class="s1">min_length</span><span class="s2">=</span><span class="s1">min_length</span><span class="s2">,</span>
        <span class="s1">max_length</span><span class="s2">=</span><span class="s1">max_length</span><span class="s2">,</span>
        <span class="s1">allow_mutation</span><span class="s2">=</span><span class="s1">allow_mutation</span><span class="s2">,</span>
        <span class="s1">regex</span><span class="s2">=</span><span class="s1">regex</span><span class="s2">,</span>
        <span class="s1">discriminator</span><span class="s2">=</span><span class="s1">discriminator</span><span class="s2">,</span>
        <span class="s1">repr</span><span class="s2">=</span><span class="s1">repr</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">extra</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s1">field_info</span><span class="s2">.</span><span class="s1">_validate</span><span class="s2">()</span>
    <span class="s0">return </span><span class="s1">field_info</span>


<span class="s5"># used to be an enum but changed to int's for small performance improvement as less access overhead</span>
<span class="s1">SHAPE_SINGLETON </span><span class="s2">= </span><span class="s6">1</span>
<span class="s1">SHAPE_LIST </span><span class="s2">= </span><span class="s6">2</span>
<span class="s1">SHAPE_SET </span><span class="s2">= </span><span class="s6">3</span>
<span class="s1">SHAPE_MAPPING </span><span class="s2">= </span><span class="s6">4</span>
<span class="s1">SHAPE_TUPLE </span><span class="s2">= </span><span class="s6">5</span>
<span class="s1">SHAPE_TUPLE_ELLIPSIS </span><span class="s2">= </span><span class="s6">6</span>
<span class="s1">SHAPE_SEQUENCE </span><span class="s2">= </span><span class="s6">7</span>
<span class="s1">SHAPE_FROZENSET </span><span class="s2">= </span><span class="s6">8</span>
<span class="s1">SHAPE_ITERABLE </span><span class="s2">= </span><span class="s6">9</span>
<span class="s1">SHAPE_GENERIC </span><span class="s2">= </span><span class="s6">10</span>
<span class="s1">SHAPE_DEQUE </span><span class="s2">= </span><span class="s6">11</span>
<span class="s1">SHAPE_DICT </span><span class="s2">= </span><span class="s6">12</span>
<span class="s1">SHAPE_DEFAULTDICT </span><span class="s2">= </span><span class="s6">13</span>
<span class="s1">SHAPE_COUNTER </span><span class="s2">= </span><span class="s6">14</span>
<span class="s1">SHAPE_NAME_LOOKUP </span><span class="s2">= {</span>
    <span class="s1">SHAPE_LIST</span><span class="s2">: </span><span class="s3">'List[{}]'</span><span class="s2">,</span>
    <span class="s1">SHAPE_SET</span><span class="s2">: </span><span class="s3">'Set[{}]'</span><span class="s2">,</span>
    <span class="s1">SHAPE_TUPLE_ELLIPSIS</span><span class="s2">: </span><span class="s3">'Tuple[{}, ...]'</span><span class="s2">,</span>
    <span class="s1">SHAPE_SEQUENCE</span><span class="s2">: </span><span class="s3">'Sequence[{}]'</span><span class="s2">,</span>
    <span class="s1">SHAPE_FROZENSET</span><span class="s2">: </span><span class="s3">'FrozenSet[{}]'</span><span class="s2">,</span>
    <span class="s1">SHAPE_ITERABLE</span><span class="s2">: </span><span class="s3">'Iterable[{}]'</span><span class="s2">,</span>
    <span class="s1">SHAPE_DEQUE</span><span class="s2">: </span><span class="s3">'Deque[{}]'</span><span class="s2">,</span>
    <span class="s1">SHAPE_DICT</span><span class="s2">: </span><span class="s3">'Dict[{}]'</span><span class="s2">,</span>
    <span class="s1">SHAPE_DEFAULTDICT</span><span class="s2">: </span><span class="s3">'DefaultDict[{}]'</span><span class="s2">,</span>
    <span class="s1">SHAPE_COUNTER</span><span class="s2">: </span><span class="s3">'Counter[{}]'</span><span class="s2">,</span>
<span class="s2">}</span>

<span class="s1">MAPPING_LIKE_SHAPES</span><span class="s2">: </span><span class="s1">Set</span><span class="s2">[</span><span class="s1">int</span><span class="s2">] = {</span><span class="s1">SHAPE_DEFAULTDICT</span><span class="s2">, </span><span class="s1">SHAPE_DICT</span><span class="s2">, </span><span class="s1">SHAPE_MAPPING</span><span class="s2">, </span><span class="s1">SHAPE_COUNTER</span><span class="s2">}</span>


<span class="s0">class </span><span class="s1">ModelField</span><span class="s2">(</span><span class="s1">Representation</span><span class="s2">):</span>
    <span class="s1">__slots__ </span><span class="s2">= (</span>
        <span class="s3">'type_'</span><span class="s2">,</span>
        <span class="s3">'outer_type_'</span><span class="s2">,</span>
        <span class="s3">'annotation'</span><span class="s2">,</span>
        <span class="s3">'sub_fields'</span><span class="s2">,</span>
        <span class="s3">'sub_fields_mapping'</span><span class="s2">,</span>
        <span class="s3">'key_field'</span><span class="s2">,</span>
        <span class="s3">'validators'</span><span class="s2">,</span>
        <span class="s3">'pre_validators'</span><span class="s2">,</span>
        <span class="s3">'post_validators'</span><span class="s2">,</span>
        <span class="s3">'default'</span><span class="s2">,</span>
        <span class="s3">'default_factory'</span><span class="s2">,</span>
        <span class="s3">'required'</span><span class="s2">,</span>
        <span class="s3">'final'</span><span class="s2">,</span>
        <span class="s3">'model_config'</span><span class="s2">,</span>
        <span class="s3">'name'</span><span class="s2">,</span>
        <span class="s3">'alias'</span><span class="s2">,</span>
        <span class="s3">'has_alias'</span><span class="s2">,</span>
        <span class="s3">'field_info'</span><span class="s2">,</span>
        <span class="s3">'discriminator_key'</span><span class="s2">,</span>
        <span class="s3">'discriminator_alias'</span><span class="s2">,</span>
        <span class="s3">'validate_always'</span><span class="s2">,</span>
        <span class="s3">'allow_none'</span><span class="s2">,</span>
        <span class="s3">'shape'</span><span class="s2">,</span>
        <span class="s3">'class_validators'</span><span class="s2">,</span>
        <span class="s3">'parse_json'</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
        <span class="s1">type_</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">],</span>
        <span class="s1">class_validators</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Validator</span><span class="s2">]],</span>
        <span class="s1">model_config</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">[</span><span class="s3">'BaseConfig'</span><span class="s2">],</span>
        <span class="s1">default</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">default_factory</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">NoArgAnyCallable</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">required</span><span class="s2">: </span><span class="s3">'BoolUndefined' </span><span class="s2">= </span><span class="s1">Undefined</span><span class="s2">,</span>
        <span class="s1">final</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">alias</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">field_info</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">FieldInfo</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">: </span><span class="s1">str </span><span class="s2">= </span><span class="s1">name</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">has_alias</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s1">alias </span><span class="s0">is not None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">alias</span><span class="s2">: </span><span class="s1">str </span><span class="s2">= </span><span class="s1">alias </span><span class="s0">if </span><span class="s1">alias </span><span class="s0">is not None else </span><span class="s1">name</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">annotation </span><span class="s2">= </span><span class="s1">type_</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">= </span><span class="s1">convert_generics</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">outer_type_</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">= </span><span class="s1">type_</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">class_validators </span><span class="s2">= </span><span class="s1">class_validators </span><span class="s0">or </span><span class="s2">{}</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">default</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">= </span><span class="s1">default</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">default_factory</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">NoArgAnyCallable</span><span class="s2">] = </span><span class="s1">default_factory</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">required</span><span class="s2">: </span><span class="s3">'BoolUndefined' </span><span class="s2">= </span><span class="s1">required</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">final</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s1">final</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">model_config </span><span class="s2">= </span><span class="s1">model_config</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">: </span><span class="s1">FieldInfo </span><span class="s2">= </span><span class="s1">field_info </span><span class="s0">or </span><span class="s1">FieldInfo</span><span class="s2">(</span><span class="s1">default</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">discriminator_key</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">discriminator</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">discriminator_alias</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">discriminator_key</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">allow_none</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">validate_always</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">List</span><span class="s2">[</span><span class="s1">ModelField</span><span class="s2">]] = </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields_mapping</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s3">'ModelField'</span><span class="s2">]] = </span><span class="s0">None  </span><span class="s5"># used for discriminated union</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">key_field</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">ModelField</span><span class="s2">] = </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">validators</span><span class="s2">: </span><span class="s3">'ValidatorsList' </span><span class="s2">= []</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">pre_validators</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s3">'ValidatorsList'</span><span class="s2">] = </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">post_validators</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s3">'ValidatorsList'</span><span class="s2">] = </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">parse_json</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s1">SHAPE_SINGLETON</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">model_config</span><span class="s2">.</span><span class="s1">prepare_field</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">prepare</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">get_default</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">smart_deepcopy</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">default</span><span class="s2">) </span><span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">default_factory </span><span class="s0">is None else </span><span class="s1">self</span><span class="s2">.</span><span class="s1">default_factory</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s0">def </span><span class="s1">_get_field_info</span><span class="s2">(</span>
        <span class="s1">field_name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">annotation</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">config</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">[</span><span class="s3">'BaseConfig'</span><span class="s2">]</span>
    <span class="s2">) </span><span class="s1">-&gt; Tuple</span><span class="s2">[</span><span class="s1">FieldInfo</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]:</span>
        <span class="s4">&quot;&quot;&quot; 
        Get a FieldInfo from a root typing.Annotated annotation, value, or config default. 
 
        The FieldInfo may be set in typing.Annotated or the value, but not both. If neither contain 
        a FieldInfo, a new one will be created using the config. 
 
        :param field_name: name of the field for use in error messages 
        :param annotation: a type hint such as `str` or `Annotated[str, Field(..., min_length=5)]` 
        :param value: the field's assigned value 
        :param config: the model's config object 
        :return: the FieldInfo contained in the `annotation`, the value, or a new one from the config. 
        &quot;&quot;&quot;</span>
        <span class="s1">field_info_from_config </span><span class="s2">= </span><span class="s1">config</span><span class="s2">.</span><span class="s1">get_field_info</span><span class="s2">(</span><span class="s1">field_name</span><span class="s2">)</span>

        <span class="s1">field_info </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">get_origin</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">) </span><span class="s0">is </span><span class="s1">Annotated</span><span class="s2">:</span>
            <span class="s1">field_infos </span><span class="s2">= [</span><span class="s1">arg </span><span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">)[</span><span class="s6">1</span><span class="s2">:] </span><span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">FieldInfo</span><span class="s2">)]</span>
            <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">field_infos</span><span class="s2">) &gt; </span><span class="s6">1</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f'cannot specify multiple `Annotated` `Field`s for </span><span class="s0">{</span><span class="s1">field_name</span><span class="s0">!r}</span><span class="s3">'</span><span class="s2">)</span>
            <span class="s1">field_info </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">field_infos</span><span class="s2">), </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">field_info </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">field_info </span><span class="s2">= </span><span class="s1">copy</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">field_info</span><span class="s2">)</span>
                <span class="s1">field_info</span><span class="s2">.</span><span class="s1">update_from_config</span><span class="s2">(</span><span class="s1">field_info_from_config</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">default </span><span class="s0">not in </span><span class="s2">(</span><span class="s1">Undefined</span><span class="s2">, </span><span class="s1">Required</span><span class="s2">):</span>
                    <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f'`Field` default cannot be set in `Annotated` for </span><span class="s0">{</span><span class="s1">field_name</span><span class="s0">!r}</span><span class="s3">'</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">value </span><span class="s0">is not </span><span class="s1">Undefined </span><span class="s0">and </span><span class="s1">value </span><span class="s0">is not </span><span class="s1">Required</span><span class="s2">:</span>
                    <span class="s5"># check also `Required` because of `validate_arguments` that sets `...` as default value</span>
                    <span class="s1">field_info</span><span class="s2">.</span><span class="s1">default </span><span class="s2">= </span><span class="s1">value</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">FieldInfo</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">field_info </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f'cannot specify `Annotated` and value `Field`s together for </span><span class="s0">{</span><span class="s1">field_name</span><span class="s0">!r}</span><span class="s3">'</span><span class="s2">)</span>
            <span class="s1">field_info </span><span class="s2">= </span><span class="s1">value</span>
            <span class="s1">field_info</span><span class="s2">.</span><span class="s1">update_from_config</span><span class="s2">(</span><span class="s1">field_info_from_config</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">field_info </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">field_info </span><span class="s2">= </span><span class="s1">FieldInfo</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, **</span><span class="s1">field_info_from_config</span><span class="s2">)</span>
        <span class="s1">value </span><span class="s2">= </span><span class="s0">None if </span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">default_factory </span><span class="s0">is not None else </span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">default</span>
        <span class="s1">field_info</span><span class="s2">.</span><span class="s1">_validate</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">field_info</span><span class="s2">, </span><span class="s1">value</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">infer</span><span class="s2">(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
        <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
        <span class="s1">annotation</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
        <span class="s1">class_validators</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Validator</span><span class="s2">]],</span>
        <span class="s1">config</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">[</span><span class="s3">'BaseConfig'</span><span class="s2">],</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s3">'ModelField'</span><span class="s2">:</span>
        <span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">schema </span><span class="s0">import </span><span class="s1">get_annotation_from_field_info</span>

        <span class="s1">field_info</span><span class="s2">, </span><span class="s1">value </span><span class="s2">= </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">_get_field_info</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">annotation</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">config</span><span class="s2">)</span>
        <span class="s1">required</span><span class="s2">: </span><span class="s3">'BoolUndefined' </span><span class="s2">= </span><span class="s1">Undefined</span>
        <span class="s0">if </span><span class="s1">value </span><span class="s0">is </span><span class="s1">Required</span><span class="s2">:</span>
            <span class="s1">required </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s1">value </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">elif </span><span class="s1">value </span><span class="s0">is not </span><span class="s1">Undefined</span><span class="s2">:</span>
            <span class="s1">required </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s1">annotation </span><span class="s2">= </span><span class="s1">get_annotation_from_field_info</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">, </span><span class="s1">field_info</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">config</span><span class="s2">.</span><span class="s1">validate_assignment</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">cls</span><span class="s2">(</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s1">type_</span><span class="s2">=</span><span class="s1">annotation</span><span class="s2">,</span>
            <span class="s1">alias</span><span class="s2">=</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">alias</span><span class="s2">,</span>
            <span class="s1">class_validators</span><span class="s2">=</span><span class="s1">class_validators</span><span class="s2">,</span>
            <span class="s1">default</span><span class="s2">=</span><span class="s1">value</span><span class="s2">,</span>
            <span class="s1">default_factory</span><span class="s2">=</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">default_factory</span><span class="s2">,</span>
            <span class="s1">required</span><span class="s2">=</span><span class="s1">required</span><span class="s2">,</span>
            <span class="s1">model_config</span><span class="s2">=</span><span class="s1">config</span><span class="s2">,</span>
            <span class="s1">field_info</span><span class="s2">=</span><span class="s1">field_info</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">set_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">config</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">[</span><span class="s3">'BaseConfig'</span><span class="s2">]) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">model_config </span><span class="s2">= </span><span class="s1">config</span>
        <span class="s1">info_from_config </span><span class="s2">= </span><span class="s1">config</span><span class="s2">.</span><span class="s1">get_field_info</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>
        <span class="s1">config</span><span class="s2">.</span><span class="s1">prepare_field</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>
        <span class="s1">new_alias </span><span class="s2">= </span><span class="s1">info_from_config</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s3">'alias'</span><span class="s2">)</span>
        <span class="s1">new_alias_priority </span><span class="s2">= </span><span class="s1">info_from_config</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s3">'alias_priority'</span><span class="s2">) </span><span class="s0">or </span><span class="s6">0</span>
        <span class="s0">if </span><span class="s1">new_alias </span><span class="s0">and </span><span class="s1">new_alias_priority </span><span class="s2">&gt;= (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">alias_priority </span><span class="s0">or </span><span class="s6">0</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">alias </span><span class="s2">= </span><span class="s1">new_alias</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">alias_priority </span><span class="s2">= </span><span class="s1">new_alias_priority</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">alias </span><span class="s2">= </span><span class="s1">new_alias</span>
        <span class="s1">new_exclude </span><span class="s2">= </span><span class="s1">info_from_config</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s3">'exclude'</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">new_exclude </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">exclude </span><span class="s2">= </span><span class="s1">ValueItems</span><span class="s2">.</span><span class="s1">merge</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">exclude</span><span class="s2">, </span><span class="s1">new_exclude</span><span class="s2">)</span>
        <span class="s1">new_include </span><span class="s2">= </span><span class="s1">info_from_config</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s3">'include'</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">new_include </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">include </span><span class="s2">= </span><span class="s1">ValueItems</span><span class="s2">.</span><span class="s1">merge</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">include</span><span class="s2">, </span><span class="s1">new_include</span><span class="s2">, </span><span class="s1">intersect</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">alt_alias</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name </span><span class="s2">!= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">alias</span>

    <span class="s0">def </span><span class="s1">prepare</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Prepare the field but inspecting self.default, self.type_ etc. 
 
        Note: this method is **not** idempotent (because _type_analysis is not idempotent), 
        e.g. calling it it multiple times may modify the field and configure it incorrectly. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_set_default_and_type</span><span class="s2">()</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">.</span><span class="s1">__class__ </span><span class="s0">is </span><span class="s1">ForwardRef </span><span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">.</span><span class="s1">__class__ </span><span class="s0">is </span><span class="s1">DeferredType</span><span class="s2">:</span>
            <span class="s5"># self.type_ is currently a ForwardRef and there's nothing we can do now,</span>
            <span class="s5"># user will need to call model.update_forward_refs()</span>
            <span class="s0">return</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_type_analysis</span><span class="s2">()</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">required </span><span class="s0">is </span><span class="s1">Undefined</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">required </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">default </span><span class="s0">is </span><span class="s1">Undefined </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">default_factory </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">default </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">populate_validators</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">_set_default_and_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Set the default value, infer the type if needed and check if `None` value is valid. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">default_factory </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s0">is </span><span class="s1">Undefined</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">errors_</span><span class="s2">.</span><span class="s1">ConfigError</span><span class="s2">(</span>
                    <span class="s3">f'you need to set the type of field </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s0">!r} </span><span class="s3">when using `default_factory`'</span>
                <span class="s2">)</span>
            <span class="s0">return</span>

        <span class="s1">default_value </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_default</span><span class="s2">()</span>

        <span class="s0">if </span><span class="s1">default_value </span><span class="s0">is not None and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s0">is </span><span class="s1">Undefined</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">default_value</span><span class="s2">.</span><span class="s1">__class__</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">outer_type_ </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">annotation </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s0">is </span><span class="s1">Undefined</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">errors_</span><span class="s2">.</span><span class="s1">ConfigError</span><span class="s2">(</span><span class="s3">f'unable to infer type for attribute &quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s0">}</span><span class="s3">&quot;'</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">required </span><span class="s0">is False and </span><span class="s1">default_value </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">allow_none </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">_type_analysis</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:  </span><span class="s5"># noqa: C901 (ignore complexity)</span>
        <span class="s5"># typing interface is horrible, we have to do some ugly checks</span>
        <span class="s0">if </span><span class="s1">lenient_issubclass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">JsonWrapper</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">.</span><span class="s1">inner_type</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">parse_json </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s0">elif </span><span class="s1">lenient_issubclass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">Json</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">Any</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">parse_json </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">TypeVar</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">.</span><span class="s1">__bound__</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">.</span><span class="s1">__bound__</span>
            <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">.</span><span class="s1">__constraints__</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">.</span><span class="s1">__constraints__</span><span class="s2">]</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">Any</span>
        <span class="s0">elif </span><span class="s1">is_new_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">new_type_supertype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s0">is </span><span class="s1">Any </span><span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s0">is </span><span class="s1">object</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">required </span><span class="s0">is </span><span class="s1">Undefined</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">required </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">allow_none </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">return</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s0">is </span><span class="s1">Pattern </span><span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s0">is </span><span class="s1">re</span><span class="s2">.</span><span class="s1">Pattern</span><span class="s2">:</span>
            <span class="s5"># python 3.7 only, Pattern is a typing object but without sub fields</span>
            <span class="s0">return</span>
        <span class="s0">elif </span><span class="s1">is_literal_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">):</span>
            <span class="s0">return</span>
        <span class="s0">elif </span><span class="s1">is_typeddict</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">):</span>
            <span class="s0">return</span>

        <span class="s0">if </span><span class="s1">is_finalvar</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">final </span><span class="s2">= </span><span class="s0">True</span>

            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s0">is </span><span class="s1">Final</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">Any</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)[</span><span class="s6">0</span><span class="s2">]</span>

            <span class="s1">self</span><span class="s2">.</span><span class="s1">_type_analysis</span><span class="s2">()</span>
            <span class="s0">return</span>

        <span class="s1">origin </span><span class="s2">= </span><span class="s1">get_origin</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">origin </span><span class="s0">is </span><span class="s1">Annotated </span><span class="s0">or </span><span class="s1">is_typeddict_special</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)[</span><span class="s6">0</span><span class="s2">]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_type_analysis</span><span class="s2">()</span>
            <span class="s0">return</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">discriminator_key </span><span class="s0">is not None and not </span><span class="s1">is_union</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">'`discriminator` can only be used with `Union` type with more than one variant'</span><span class="s2">)</span>

        <span class="s5"># add extra check for `collections.abc.Hashable` for python 3.10+ where origin is not `None`</span>
        <span class="s0">if </span><span class="s1">origin </span><span class="s0">is None or </span><span class="s1">origin </span><span class="s0">is </span><span class="s1">CollectionsHashable</span><span class="s2">:</span>
            <span class="s5"># field is not &quot;typing&quot; object eg. Union, Dict, List etc.</span>
            <span class="s5"># allow None for virtual superclasses of NoneType, e.g. Hashable</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">type</span><span class="s2">) </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s0">None</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">allow_none </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">return</span>
        <span class="s0">elif </span><span class="s1">origin </span><span class="s0">is </span><span class="s1">Callable</span><span class="s2">:</span>
            <span class="s0">return</span>
        <span class="s0">elif </span><span class="s1">is_union</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">):</span>
            <span class="s1">types_ </span><span class="s2">= []</span>
            <span class="s0">for </span><span class="s1">type_ </span><span class="s0">in </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">is_none_type</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">) </span><span class="s0">or </span><span class="s1">type_ </span><span class="s0">is </span><span class="s1">Any </span><span class="s0">or </span><span class="s1">type_ </span><span class="s0">is </span><span class="s1">object</span><span class="s2">:</span>
                    <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">required </span><span class="s0">is </span><span class="s1">Undefined</span><span class="s2">:</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">required </span><span class="s2">= </span><span class="s0">False</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">allow_none </span><span class="s2">= </span><span class="s0">True</span>
                <span class="s0">if </span><span class="s1">is_none_type</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">):</span>
                    <span class="s0">continue</span>
                <span class="s1">types_</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">types_</span><span class="s2">) == </span><span class="s6">1</span><span class="s2">:</span>
                <span class="s5"># Optional[]</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">types_</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
                <span class="s5"># this is the one case where the &quot;outer type&quot; isn't just the original type</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">outer_type_ </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span>
                <span class="s5"># re-run to correctly interpret the new self.type_</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_type_analysis</span><span class="s2">()</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_create_sub_type</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s0">}</span><span class="s3">_</span><span class="s0">{</span><span class="s1">display_as_type</span><span class="s2">(</span><span class="s1">t</span><span class="s2">)</span><span class="s0">}</span><span class="s3">'</span><span class="s2">) </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">types_</span><span class="s2">]</span>

                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">discriminator_key </span><span class="s0">is not None</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">prepare_discriminated_union_sub_fields</span><span class="s2">()</span>
            <span class="s0">return</span>
        <span class="s0">elif </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">):  </span><span class="s5"># type: ignore</span>
            <span class="s5"># origin == Tuple without item type</span>
            <span class="s1">args </span><span class="s2">= </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)</span>
            <span class="s0">if not </span><span class="s1">args</span><span class="s2">:  </span><span class="s5"># plain tuple</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">Any</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">= </span><span class="s1">SHAPE_TUPLE_ELLIPSIS</span>
            <span class="s0">elif </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) == </span><span class="s6">2 </span><span class="s0">and </span><span class="s1">args</span><span class="s2">[</span><span class="s6">1</span><span class="s2">] </span><span class="s0">is </span><span class="s1">Ellipsis</span><span class="s2">:  </span><span class="s5"># e.g. Tuple[int, ...]</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">= </span><span class="s1">SHAPE_TUPLE_ELLIPSIS</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_create_sub_type</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s0">}</span><span class="s3">_0'</span><span class="s2">)]</span>
            <span class="s0">elif </span><span class="s1">args </span><span class="s2">== ((),):  </span><span class="s5"># Tuple[()] means empty tuple</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">= </span><span class="s1">SHAPE_TUPLE</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">Any</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields </span><span class="s2">= []</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">= </span><span class="s1">SHAPE_TUPLE</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_create_sub_type</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s0">}</span><span class="s3">_</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s3">'</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)]</span>
            <span class="s0">return</span>
        <span class="s0">elif </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">List</span><span class="s2">):</span>
            <span class="s5"># Create self validators</span>
            <span class="s1">get_validators </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">, </span><span class="s3">'__get_validators__'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">get_validators</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">class_validators</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span>
                    <span class="s2">{</span><span class="s3">f'list_</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s3">'</span><span class="s2">: </span><span class="s1">Validator</span><span class="s2">(</span><span class="s1">validator</span><span class="s2">, </span><span class="s1">pre</span><span class="s2">=</span><span class="s0">True</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">validator </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">get_validators</span><span class="s2">())}</span>
                <span class="s2">)</span>

            <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)[</span><span class="s6">0</span><span class="s2">]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">= </span><span class="s1">SHAPE_LIST</span>
        <span class="s0">elif </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">Set</span><span class="s2">):</span>
            <span class="s5"># Create self validators</span>
            <span class="s1">get_validators </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">, </span><span class="s3">'__get_validators__'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">get_validators</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">class_validators</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span>
                    <span class="s2">{</span><span class="s3">f'set_</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s3">'</span><span class="s2">: </span><span class="s1">Validator</span><span class="s2">(</span><span class="s1">validator</span><span class="s2">, </span><span class="s1">pre</span><span class="s2">=</span><span class="s0">True</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">validator </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">get_validators</span><span class="s2">())}</span>
                <span class="s2">)</span>

            <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)[</span><span class="s6">0</span><span class="s2">]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">= </span><span class="s1">SHAPE_SET</span>
        <span class="s0">elif </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">FrozenSet</span><span class="s2">):</span>
            <span class="s5"># Create self validators</span>
            <span class="s1">get_validators </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">, </span><span class="s3">'__get_validators__'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">get_validators</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">class_validators</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span>
                    <span class="s2">{</span><span class="s3">f'frozenset_</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s3">'</span><span class="s2">: </span><span class="s1">Validator</span><span class="s2">(</span><span class="s1">validator</span><span class="s2">, </span><span class="s1">pre</span><span class="s2">=</span><span class="s0">True</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">validator </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">get_validators</span><span class="s2">())}</span>
                <span class="s2">)</span>

            <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)[</span><span class="s6">0</span><span class="s2">]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">= </span><span class="s1">SHAPE_FROZENSET</span>
        <span class="s0">elif </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">Deque</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)[</span><span class="s6">0</span><span class="s2">]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">= </span><span class="s1">SHAPE_DEQUE</span>
        <span class="s0">elif </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">Sequence</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)[</span><span class="s6">0</span><span class="s2">]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">= </span><span class="s1">SHAPE_SEQUENCE</span>
        <span class="s5"># priority to most common mapping: dict</span>
        <span class="s0">elif </span><span class="s1">origin </span><span class="s0">is </span><span class="s1">dict </span><span class="s0">or </span><span class="s1">origin </span><span class="s0">is </span><span class="s1">Dict</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">key_field </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_create_sub_type</span><span class="s2">(</span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)[</span><span class="s6">0</span><span class="s2">], </span><span class="s3">'key_' </span><span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">, </span><span class="s1">for_keys</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)[</span><span class="s6">1</span><span class="s2">]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">= </span><span class="s1">SHAPE_DICT</span>
        <span class="s0">elif </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">DefaultDict</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">key_field </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_create_sub_type</span><span class="s2">(</span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)[</span><span class="s6">0</span><span class="s2">], </span><span class="s3">'key_' </span><span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">, </span><span class="s1">for_keys</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)[</span><span class="s6">1</span><span class="s2">]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">= </span><span class="s1">SHAPE_DEFAULTDICT</span>
        <span class="s0">elif </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">Counter</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">key_field </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_create_sub_type</span><span class="s2">(</span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)[</span><span class="s6">0</span><span class="s2">], </span><span class="s3">'key_' </span><span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">, </span><span class="s1">for_keys</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">int</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">= </span><span class="s1">SHAPE_COUNTER</span>
        <span class="s0">elif </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">Mapping</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">key_field </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_create_sub_type</span><span class="s2">(</span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)[</span><span class="s6">0</span><span class="s2">], </span><span class="s3">'key_' </span><span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">, </span><span class="s1">for_keys</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)[</span><span class="s6">1</span><span class="s2">]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">= </span><span class="s1">SHAPE_MAPPING</span>
        <span class="s5"># Equality check as almost everything inherits form Iterable, including str</span>
        <span class="s5"># check for Iterable and CollectionsIterable, as it could receive one even when declared with the other</span>
        <span class="s0">elif </span><span class="s1">origin </span><span class="s0">in </span><span class="s2">{</span><span class="s1">Iterable</span><span class="s2">, </span><span class="s1">CollectionsIterable</span><span class="s2">}:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)[</span><span class="s6">0</span><span class="s2">]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">= </span><span class="s1">SHAPE_ITERABLE</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_create_sub_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">, </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s0">}</span><span class="s3">_type'</span><span class="s2">)]</span>
        <span class="s0">elif </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">Type</span><span class="s2">):  </span><span class="s5"># type: ignore</span>
            <span class="s0">return</span>
        <span class="s0">elif </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s3">'__get_validators__'</span><span class="s2">) </span><span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">model_config</span><span class="s2">.</span><span class="s1">arbitrary_types_allowed</span><span class="s2">:</span>
            <span class="s5"># Is a Pydantic-compatible generic that handles itself</span>
            <span class="s5"># or we have arbitrary_types_allowed = True</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">= </span><span class="s1">SHAPE_GENERIC</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_create_sub_type</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s0">}</span><span class="s3">_</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s3">'</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">))]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">= </span><span class="s1">origin</span>
            <span class="s0">return</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">f'Fields of type &quot;</span><span class="s0">{</span><span class="s1">origin</span><span class="s0">}</span><span class="s3">&quot; are not supported.'</span><span class="s2">)</span>

        <span class="s5"># type_ has been refined eg. as the type of a List and sub_fields needs to be populated</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_create_sub_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">, </span><span class="s3">'_' </span><span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)]</span>

    <span class="s0">def </span><span class="s1">prepare_discriminated_union_sub_fields</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Prepare the mapping &lt;discriminator key&gt; -&gt; &lt;ModelField&gt; and update `sub_fields` 
        Note that this process can be aborted if a `ForwardRef` is encountered 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">discriminator_key </span><span class="s0">is not None</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">.</span><span class="s1">__class__ </span><span class="s0">is </span><span class="s1">DeferredType</span><span class="s2">:</span>
            <span class="s0">return</span>

        <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields </span><span class="s0">is not None</span>
        <span class="s1">sub_fields_mapping</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s3">'ModelField'</span><span class="s2">] = {}</span>
        <span class="s1">all_aliases</span><span class="s2">: </span><span class="s1">Set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s1">set</span><span class="s2">()</span>

        <span class="s0">for </span><span class="s1">sub_field </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields</span><span class="s2">:</span>
            <span class="s1">t </span><span class="s2">= </span><span class="s1">sub_field</span><span class="s2">.</span><span class="s1">type_</span>
            <span class="s0">if </span><span class="s1">t</span><span class="s2">.</span><span class="s1">__class__ </span><span class="s0">is </span><span class="s1">ForwardRef</span><span class="s2">:</span>
                <span class="s5"># Stopping everything...will need to call `update_forward_refs`</span>
                <span class="s0">return</span>

            <span class="s1">alias</span><span class="s2">, </span><span class="s1">discriminator_values </span><span class="s2">= </span><span class="s1">get_discriminator_alias_and_values</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">discriminator_key</span><span class="s2">)</span>
            <span class="s1">all_aliases</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">alias</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">discriminator_value </span><span class="s0">in </span><span class="s1">discriminator_values</span><span class="s2">:</span>
                <span class="s1">sub_fields_mapping</span><span class="s2">[</span><span class="s1">discriminator_value</span><span class="s2">] = </span><span class="s1">sub_field</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields_mapping </span><span class="s2">= </span><span class="s1">sub_fields_mapping</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">discriminator_alias </span><span class="s2">= </span><span class="s1">get_unique_discriminator_alias</span><span class="s2">(</span><span class="s1">all_aliases</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">discriminator_key</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_create_sub_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">type_</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">], </span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, *, </span><span class="s1">for_keys</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s3">'ModelField'</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">for_keys</span><span class="s2">:</span>
            <span class="s1">class_validators </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s5"># validators for sub items should not have `each_item` as we want to check only the first sublevel</span>
            <span class="s1">class_validators </span><span class="s2">= {</span>
                <span class="s1">k</span><span class="s2">: </span><span class="s1">Validator</span><span class="s2">(</span>
                    <span class="s1">func</span><span class="s2">=</span><span class="s1">v</span><span class="s2">.</span><span class="s1">func</span><span class="s2">,</span>
                    <span class="s1">pre</span><span class="s2">=</span><span class="s1">v</span><span class="s2">.</span><span class="s1">pre</span><span class="s2">,</span>
                    <span class="s1">each_item</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
                    <span class="s1">always</span><span class="s2">=</span><span class="s1">v</span><span class="s2">.</span><span class="s1">always</span><span class="s2">,</span>
                    <span class="s1">check_fields</span><span class="s2">=</span><span class="s1">v</span><span class="s2">.</span><span class="s1">check_fields</span><span class="s2">,</span>
                    <span class="s1">skip_on_failure</span><span class="s2">=</span><span class="s1">v</span><span class="s2">.</span><span class="s1">skip_on_failure</span><span class="s2">,</span>
                <span class="s2">)</span>
                <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">class_validators</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()</span>
                <span class="s0">if </span><span class="s1">v</span><span class="s2">.</span><span class="s1">each_item</span>
            <span class="s2">}</span>

        <span class="s1">field_info</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_field_info</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">type_</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">model_config</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">(</span>
            <span class="s1">type_</span><span class="s2">=</span><span class="s1">type_</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s1">class_validators</span><span class="s2">=</span><span class="s1">class_validators</span><span class="s2">,</span>
            <span class="s1">model_config</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">model_config</span><span class="s2">,</span>
            <span class="s1">field_info</span><span class="s2">=</span><span class="s1">field_info</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">populate_validators</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Prepare self.pre_validators, self.validators, and self.post_validators based on self.type_'s  __get_validators__ 
        and class validators. This method should be idempotent, e.g. it should be safe to call multiple times 
        without mis-configuring the field. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">validate_always </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">, </span><span class="s3">'validate_always'</span><span class="s2">, </span><span class="s0">False</span><span class="s2">) </span><span class="s0">or </span><span class="s1">any</span><span class="s2">(</span>
            <span class="s1">v</span><span class="s2">.</span><span class="s1">always </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">class_validators</span><span class="s2">.</span><span class="s1">values</span><span class="s2">()</span>
        <span class="s2">)</span>

        <span class="s1">class_validators_ </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">class_validators</span><span class="s2">.</span><span class="s1">values</span><span class="s2">()</span>
        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields </span><span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">SHAPE_GENERIC</span><span class="s2">:</span>
            <span class="s1">get_validators </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">, </span><span class="s3">'__get_validators__'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s1">v_funcs </span><span class="s2">= (</span>
                <span class="s2">*[</span><span class="s1">v</span><span class="s2">.</span><span class="s1">func </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">class_validators_ </span><span class="s0">if </span><span class="s1">v</span><span class="s2">.</span><span class="s1">each_item </span><span class="s0">and </span><span class="s1">v</span><span class="s2">.</span><span class="s1">pre</span><span class="s2">],</span>
                <span class="s2">*(</span><span class="s1">get_validators</span><span class="s2">() </span><span class="s0">if </span><span class="s1">get_validators </span><span class="s0">else </span><span class="s1">list</span><span class="s2">(</span><span class="s1">find_validators</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">model_config</span><span class="s2">))),</span>
                <span class="s2">*[</span><span class="s1">v</span><span class="s2">.</span><span class="s1">func </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">class_validators_ </span><span class="s0">if </span><span class="s1">v</span><span class="s2">.</span><span class="s1">each_item </span><span class="s0">and not </span><span class="s1">v</span><span class="s2">.</span><span class="s1">pre</span><span class="s2">],</span>
            <span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">validators </span><span class="s2">= </span><span class="s1">prep_validators</span><span class="s2">(</span><span class="s1">v_funcs</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">pre_validators </span><span class="s2">= []</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">post_validators </span><span class="s2">= []</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">field_info </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">const</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">post_validators</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">make_generic_validator</span><span class="s2">(</span><span class="s1">constant_validator</span><span class="s2">))</span>

        <span class="s0">if </span><span class="s1">class_validators_</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">pre_validators </span><span class="s2">+= </span><span class="s1">prep_validators</span><span class="s2">(</span><span class="s1">v</span><span class="s2">.</span><span class="s1">func </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">class_validators_ </span><span class="s0">if not </span><span class="s1">v</span><span class="s2">.</span><span class="s1">each_item </span><span class="s0">and </span><span class="s1">v</span><span class="s2">.</span><span class="s1">pre</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">post_validators </span><span class="s2">+= </span><span class="s1">prep_validators</span><span class="s2">(</span><span class="s1">v</span><span class="s2">.</span><span class="s1">func </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">class_validators_ </span><span class="s0">if not </span><span class="s1">v</span><span class="s2">.</span><span class="s1">each_item </span><span class="s0">and not </span><span class="s1">v</span><span class="s2">.</span><span class="s1">pre</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">parse_json</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">pre_validators</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">make_generic_validator</span><span class="s2">(</span><span class="s1">validate_json</span><span class="s2">))</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">pre_validators </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">pre_validators </span><span class="s0">or None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">post_validators </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">post_validators </span><span class="s0">or None</span>

    <span class="s0">def </span><span class="s1">validate</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">v</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">values</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], *, </span><span class="s1">loc</span><span class="s2">: </span><span class="s3">'LocStr'</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s3">'ModelOrDc'</span><span class="s2">] = </span><span class="s0">None</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s3">'ValidateReturn'</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">.</span><span class="s1">__class__ </span><span class="s0">is not </span><span class="s1">DeferredType</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">.</span><span class="s1">__class__ </span><span class="s0">is </span><span class="s1">ForwardRef</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s1">cls </span><span class="s0">is not None</span>
            <span class="s0">raise </span><span class="s1">ConfigError</span><span class="s2">(</span>
                <span class="s3">f'field &quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s0">}</span><span class="s3">&quot; not yet prepared so type is still a ForwardRef, '</span>
                <span class="s3">f'you might need to call </span><span class="s0">{</span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">}</span><span class="s3">.update_forward_refs().'</span>
            <span class="s2">)</span>

        <span class="s1">errors</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s3">'ErrorList'</span><span class="s2">]</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">pre_validators</span><span class="s2">:</span>
            <span class="s1">v</span><span class="s2">, </span><span class="s1">errors </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_apply_validators</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">pre_validators</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">errors</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">v</span><span class="s2">, </span><span class="s1">errors</span>

        <span class="s0">if </span><span class="s1">v </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">is_none_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">):</span>
                <span class="s5"># keep validating</span>
                <span class="s0">pass</span>
            <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">allow_none</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">post_validators</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_apply_validators</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">post_validators</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">return None</span><span class="s2">, </span><span class="s0">None</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">v</span><span class="s2">, </span><span class="s1">ErrorWrapper</span><span class="s2">(</span><span class="s1">NoneIsNotAllowedError</span><span class="s2">(), </span><span class="s1">loc</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">SHAPE_SINGLETON</span><span class="s2">:</span>
            <span class="s1">v</span><span class="s2">, </span><span class="s1">errors </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_validate_singleton</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s0">in </span><span class="s1">MAPPING_LIKE_SHAPES</span><span class="s2">:</span>
            <span class="s1">v</span><span class="s2">, </span><span class="s1">errors </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_validate_mapping_like</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">SHAPE_TUPLE</span><span class="s2">:</span>
            <span class="s1">v</span><span class="s2">, </span><span class="s1">errors </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_validate_tuple</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">SHAPE_ITERABLE</span><span class="s2">:</span>
            <span class="s1">v</span><span class="s2">, </span><span class="s1">errors </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_validate_iterable</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">SHAPE_GENERIC</span><span class="s2">:</span>
            <span class="s1">v</span><span class="s2">, </span><span class="s1">errors </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_apply_validators</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">validators</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s5">#  sequence, list, set, generator, tuple with ellipsis, frozen set</span>
            <span class="s1">v</span><span class="s2">, </span><span class="s1">errors </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_validate_sequence_like</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">)</span>

        <span class="s0">if not </span><span class="s1">errors </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">post_validators</span><span class="s2">:</span>
            <span class="s1">v</span><span class="s2">, </span><span class="s1">errors </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_apply_validators</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">post_validators</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">v</span><span class="s2">, </span><span class="s1">errors</span>

    <span class="s0">def </span><span class="s1">_validate_sequence_like</span><span class="s2">(  </span><span class="s5"># noqa: C901 (ignore complexity)</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">v</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">values</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], </span><span class="s1">loc</span><span class="s2">: </span><span class="s3">'LocStr'</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s3">'ModelOrDc'</span><span class="s2">]</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s3">'ValidateReturn'</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Validate sequence-like containers: lists, tuples, sets and generators 
        Note that large if-else blocks are necessary to enable Cython 
        optimization, which is why we disable the complexity check above. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">sequence_like</span><span class="s2">(</span><span class="s1">v</span><span class="s2">):</span>
            <span class="s1">e</span><span class="s2">: </span><span class="s1">errors_</span><span class="s2">.</span><span class="s1">PydanticTypeError</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">SHAPE_LIST</span><span class="s2">:</span>
                <span class="s1">e </span><span class="s2">= </span><span class="s1">errors_</span><span class="s2">.</span><span class="s1">ListError</span><span class="s2">()</span>
            <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s0">in </span><span class="s2">(</span><span class="s1">SHAPE_TUPLE</span><span class="s2">, </span><span class="s1">SHAPE_TUPLE_ELLIPSIS</span><span class="s2">):</span>
                <span class="s1">e </span><span class="s2">= </span><span class="s1">errors_</span><span class="s2">.</span><span class="s1">TupleError</span><span class="s2">()</span>
            <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">SHAPE_SET</span><span class="s2">:</span>
                <span class="s1">e </span><span class="s2">= </span><span class="s1">errors_</span><span class="s2">.</span><span class="s1">SetError</span><span class="s2">()</span>
            <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">SHAPE_FROZENSET</span><span class="s2">:</span>
                <span class="s1">e </span><span class="s2">= </span><span class="s1">errors_</span><span class="s2">.</span><span class="s1">FrozenSetError</span><span class="s2">()</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">e </span><span class="s2">= </span><span class="s1">errors_</span><span class="s2">.</span><span class="s1">SequenceError</span><span class="s2">()</span>
            <span class="s0">return </span><span class="s1">v</span><span class="s2">, </span><span class="s1">ErrorWrapper</span><span class="s2">(</span><span class="s1">e</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">)</span>

        <span class="s1">loc </span><span class="s2">= </span><span class="s1">loc </span><span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">) </span><span class="s0">else </span><span class="s2">(</span><span class="s1">loc</span><span class="s2">,)</span>
        <span class="s1">result </span><span class="s2">= []</span>
        <span class="s1">errors</span><span class="s2">: </span><span class="s1">List</span><span class="s2">[</span><span class="s1">ErrorList</span><span class="s2">] = []</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">v_ </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">v</span><span class="s2">):</span>
            <span class="s1">v_loc </span><span class="s2">= *</span><span class="s1">loc</span><span class="s2">, </span><span class="s1">i</span>
            <span class="s1">r</span><span class="s2">, </span><span class="s1">ee </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_validate_singleton</span><span class="s2">(</span><span class="s1">v_</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">v_loc</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">ee</span><span class="s2">:</span>
                <span class="s1">errors</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">ee</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">result</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">r</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">errors</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">v</span><span class="s2">, </span><span class="s1">errors</span>

        <span class="s1">converted</span><span class="s2">: </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">List</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">], </span><span class="s1">Set</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">], </span><span class="s1">FrozenSet</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">], </span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...], </span><span class="s1">Iterator</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">], </span><span class="s1">Deque</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">]] = </span><span class="s1">result</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">SHAPE_SET</span><span class="s2">:</span>
            <span class="s1">converted </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">SHAPE_FROZENSET</span><span class="s2">:</span>
            <span class="s1">converted </span><span class="s2">= </span><span class="s1">frozenset</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">SHAPE_TUPLE_ELLIPSIS</span><span class="s2">:</span>
            <span class="s1">converted </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">SHAPE_DEQUE</span><span class="s2">:</span>
            <span class="s1">converted </span><span class="s2">= </span><span class="s1">deque</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">maxlen</span><span class="s2">=</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s3">'maxlen'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">))</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">SHAPE_SEQUENCE</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s1">converted </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">set</span><span class="s2">):</span>
                <span class="s1">converted </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">Generator</span><span class="s2">):</span>
                <span class="s1">converted </span><span class="s2">= </span><span class="s1">iter</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">deque</span><span class="s2">):</span>
                <span class="s1">converted </span><span class="s2">= </span><span class="s1">deque</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">maxlen</span><span class="s2">=</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s3">'maxlen'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">))</span>
        <span class="s0">return </span><span class="s1">converted</span><span class="s2">, </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_validate_iterable</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">v</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">values</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], </span><span class="s1">loc</span><span class="s2">: </span><span class="s3">'LocStr'</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s3">'ModelOrDc'</span><span class="s2">]</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s3">'ValidateReturn'</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Validate Iterables. 
 
        This intentionally doesn't validate values to allow infinite generators. 
        &quot;&quot;&quot;</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">iterable </span><span class="s2">= </span><span class="s1">iter</span><span class="s2">(</span><span class="s1">v</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">TypeError</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">v</span><span class="s2">, </span><span class="s1">ErrorWrapper</span><span class="s2">(</span><span class="s1">errors_</span><span class="s2">.</span><span class="s1">IterableError</span><span class="s2">(), </span><span class="s1">loc</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">iterable</span><span class="s2">, </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_validate_tuple</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">v</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">values</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], </span><span class="s1">loc</span><span class="s2">: </span><span class="s3">'LocStr'</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s3">'ModelOrDc'</span><span class="s2">]</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s3">'ValidateReturn'</span><span class="s2">:</span>
        <span class="s1">e</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Exception</span><span class="s2">] = </span><span class="s0">None</span>
        <span class="s0">if not </span><span class="s1">sequence_like</span><span class="s2">(</span><span class="s1">v</span><span class="s2">):</span>
            <span class="s1">e </span><span class="s2">= </span><span class="s1">errors_</span><span class="s2">.</span><span class="s1">TupleError</span><span class="s2">()</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">actual_length</span><span class="s2">, </span><span class="s1">expected_length </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">v</span><span class="s2">), </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields</span><span class="s2">)  </span><span class="s5"># type: ignore</span>
            <span class="s0">if </span><span class="s1">actual_length </span><span class="s2">!= </span><span class="s1">expected_length</span><span class="s2">:</span>
                <span class="s1">e </span><span class="s2">= </span><span class="s1">errors_</span><span class="s2">.</span><span class="s1">TupleLengthError</span><span class="s2">(</span><span class="s1">actual_length</span><span class="s2">=</span><span class="s1">actual_length</span><span class="s2">, </span><span class="s1">expected_length</span><span class="s2">=</span><span class="s1">expected_length</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">e</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">v</span><span class="s2">, </span><span class="s1">ErrorWrapper</span><span class="s2">(</span><span class="s1">e</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">)</span>

        <span class="s1">loc </span><span class="s2">= </span><span class="s1">loc </span><span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">) </span><span class="s0">else </span><span class="s2">(</span><span class="s1">loc</span><span class="s2">,)</span>
        <span class="s1">result </span><span class="s2">= []</span>
        <span class="s1">errors</span><span class="s2">: </span><span class="s1">List</span><span class="s2">[</span><span class="s1">ErrorList</span><span class="s2">] = []</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s2">, (</span><span class="s1">v_</span><span class="s2">, </span><span class="s1">field</span><span class="s2">) </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields</span><span class="s2">)):  </span><span class="s5"># type: ignore</span>
            <span class="s1">v_loc </span><span class="s2">= *</span><span class="s1">loc</span><span class="s2">, </span><span class="s1">i</span>
            <span class="s1">r</span><span class="s2">, </span><span class="s1">ee </span><span class="s2">= </span><span class="s1">field</span><span class="s2">.</span><span class="s1">validate</span><span class="s2">(</span><span class="s1">v_</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">=</span><span class="s1">v_loc</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">=</span><span class="s1">cls</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">ee</span><span class="s2">:</span>
                <span class="s1">errors</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">ee</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">result</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">r</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">errors</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">v</span><span class="s2">, </span><span class="s1">errors</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">result</span><span class="s2">), </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_validate_mapping_like</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">v</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">values</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], </span><span class="s1">loc</span><span class="s2">: </span><span class="s3">'LocStr'</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s3">'ModelOrDc'</span><span class="s2">]</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s3">'ValidateReturn'</span><span class="s2">:</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">v_iter </span><span class="s2">= </span><span class="s1">dict_validator</span><span class="s2">(</span><span class="s1">v</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">TypeError </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">v</span><span class="s2">, </span><span class="s1">ErrorWrapper</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">)</span>

        <span class="s1">loc </span><span class="s2">= </span><span class="s1">loc </span><span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">) </span><span class="s0">else </span><span class="s2">(</span><span class="s1">loc</span><span class="s2">,)</span>
        <span class="s1">result</span><span class="s2">, </span><span class="s1">errors </span><span class="s2">= {}, []</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v_ </span><span class="s0">in </span><span class="s1">v_iter</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s1">v_loc </span><span class="s2">= *</span><span class="s1">loc</span><span class="s2">, </span><span class="s3">'__key__'</span>
            <span class="s1">key_result</span><span class="s2">, </span><span class="s1">key_errors </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">key_field</span><span class="s2">.</span><span class="s1">validate</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">=</span><span class="s1">v_loc</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">=</span><span class="s1">cls</span><span class="s2">)  </span><span class="s5"># type: ignore</span>
            <span class="s0">if </span><span class="s1">key_errors</span><span class="s2">:</span>
                <span class="s1">errors</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">key_errors</span><span class="s2">)</span>
                <span class="s0">continue</span>

            <span class="s1">v_loc </span><span class="s2">= *</span><span class="s1">loc</span><span class="s2">, </span><span class="s1">k</span>
            <span class="s1">value_result</span><span class="s2">, </span><span class="s1">value_errors </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_validate_singleton</span><span class="s2">(</span><span class="s1">v_</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">v_loc</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">value_errors</span><span class="s2">:</span>
                <span class="s1">errors</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">value_errors</span><span class="s2">)</span>
                <span class="s0">continue</span>

            <span class="s1">result</span><span class="s2">[</span><span class="s1">key_result</span><span class="s2">] = </span><span class="s1">value_result</span>
        <span class="s0">if </span><span class="s1">errors</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">v</span><span class="s2">, </span><span class="s1">errors</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">SHAPE_DICT</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">result</span><span class="s2">, </span><span class="s0">None</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">SHAPE_DEFAULTDICT</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">defaultdict</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">result</span><span class="s2">), </span><span class="s0">None</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">SHAPE_COUNTER</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">CollectionCounter</span><span class="s2">(</span><span class="s1">result</span><span class="s2">), </span><span class="s0">None</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_mapping_value</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">result</span><span class="s2">), </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_get_mapping_value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">original</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">converted</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]) </span><span class="s1">-&gt; Union</span><span class="s2">[</span><span class="s1">T</span><span class="s2">, </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]]:</span>
        <span class="s4">&quot;&quot;&quot; 
        When type is `Mapping[KT, KV]` (or another unsupported mapping), we try to avoid 
        coercing to `dict` unwillingly. 
        &quot;&quot;&quot;</span>
        <span class="s1">original_cls </span><span class="s2">= </span><span class="s1">original</span><span class="s2">.</span><span class="s1">__class__</span>

        <span class="s0">if </span><span class="s1">original_cls </span><span class="s2">== </span><span class="s1">dict </span><span class="s0">or </span><span class="s1">original_cls </span><span class="s2">== </span><span class="s1">Dict</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">converted</span>
        <span class="s0">elif </span><span class="s1">original_cls </span><span class="s0">in </span><span class="s2">{</span><span class="s1">defaultdict</span><span class="s2">, </span><span class="s1">DefaultDict</span><span class="s2">}:</span>
            <span class="s0">return </span><span class="s1">defaultdict</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">converted</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s5"># Counter, OrderedDict, UserDict, ...</span>
                <span class="s0">return </span><span class="s1">original_cls</span><span class="s2">(</span><span class="s1">converted</span><span class="s2">)  </span><span class="s5"># type: ignore</span>
            <span class="s0">except </span><span class="s1">TypeError</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s3">f'Could not convert dictionary to </span><span class="s0">{</span><span class="s1">original_cls</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">!r}</span><span class="s3">'</span><span class="s2">) </span><span class="s0">from None</span>

    <span class="s0">def </span><span class="s1">_validate_singleton</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">v</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">values</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], </span><span class="s1">loc</span><span class="s2">: </span><span class="s3">'LocStr'</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s3">'ModelOrDc'</span><span class="s2">]</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s3">'ValidateReturn'</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">discriminator_key </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_validate_discriminated_union</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">)</span>

            <span class="s1">errors </span><span class="s2">= []</span>

            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">model_config</span><span class="s2">.</span><span class="s1">smart_union </span><span class="s0">and </span><span class="s1">is_union</span><span class="s2">(</span><span class="s1">get_origin</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)):</span>
                <span class="s5"># 1st pass: check if the value is an exact instance of one of the Union types</span>
                <span class="s5"># (e.g. to avoid coercing a bool into an int)</span>
                <span class="s0">for </span><span class="s1">field </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields</span><span class="s2">:</span>
                    <span class="s0">if </span><span class="s1">v</span><span class="s2">.</span><span class="s1">__class__ </span><span class="s0">is </span><span class="s1">field</span><span class="s2">.</span><span class="s1">outer_type_</span><span class="s2">:</span>
                        <span class="s0">return </span><span class="s1">v</span><span class="s2">, </span><span class="s0">None</span>

                <span class="s5"># 2nd pass: check if the value is an instance of any subclass of the Union types</span>
                <span class="s0">for </span><span class="s1">field </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields</span><span class="s2">:</span>
                    <span class="s5"># This whole logic will be improved later on to support more complex `isinstance` checks</span>
                    <span class="s5"># It will probably be done once a strict mode is added and be something like:</span>
                    <span class="s5"># ```</span>
                    <span class="s5">#     value, error = field.validate(v, values, strict=True)</span>
                    <span class="s5">#     if error is None:</span>
                    <span class="s5">#         return value, None</span>
                    <span class="s5"># ```</span>
                    <span class="s0">try</span><span class="s2">:</span>
                        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">field</span><span class="s2">.</span><span class="s1">outer_type_</span><span class="s2">):</span>
                            <span class="s0">return </span><span class="s1">v</span><span class="s2">, </span><span class="s0">None</span>
                    <span class="s0">except </span><span class="s1">TypeError</span><span class="s2">:</span>
                        <span class="s5"># compound type</span>
                        <span class="s0">if </span><span class="s1">lenient_isinstance</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">get_origin</span><span class="s2">(</span><span class="s1">field</span><span class="s2">.</span><span class="s1">outer_type_</span><span class="s2">)):</span>
                            <span class="s1">value</span><span class="s2">, </span><span class="s1">error </span><span class="s2">= </span><span class="s1">field</span><span class="s2">.</span><span class="s1">validate</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">=</span><span class="s1">loc</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">=</span><span class="s1">cls</span><span class="s2">)</span>
                            <span class="s0">if not </span><span class="s1">error</span><span class="s2">:</span>
                                <span class="s0">return </span><span class="s1">value</span><span class="s2">, </span><span class="s0">None</span>

            <span class="s5"># 1st pass by default or 3rd pass with `smart_union` enabled:</span>
            <span class="s5"># check if the value can be coerced into one of the Union types</span>
            <span class="s0">for </span><span class="s1">field </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields</span><span class="s2">:</span>
                <span class="s1">value</span><span class="s2">, </span><span class="s1">error </span><span class="s2">= </span><span class="s1">field</span><span class="s2">.</span><span class="s1">validate</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">=</span><span class="s1">loc</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">=</span><span class="s1">cls</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">error</span><span class="s2">:</span>
                    <span class="s1">errors</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">error</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s1">value</span><span class="s2">, </span><span class="s0">None</span>
            <span class="s0">return </span><span class="s1">v</span><span class="s2">, </span><span class="s1">errors</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_apply_validators</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">validators</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_validate_discriminated_union</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">v</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">values</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], </span><span class="s1">loc</span><span class="s2">: </span><span class="s3">'LocStr'</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s3">'ModelOrDc'</span><span class="s2">]</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s3">'ValidateReturn'</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">discriminator_key </span><span class="s0">is not None</span>
        <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">discriminator_alias </span><span class="s0">is not None</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">discriminator_value </span><span class="s2">= </span><span class="s1">v</span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">discriminator_alias</span><span class="s2">]</span>
            <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">model_config</span><span class="s2">.</span><span class="s1">allow_population_by_field_name</span><span class="s2">:</span>
                    <span class="s1">discriminator_value </span><span class="s2">= </span><span class="s1">v</span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">discriminator_key</span><span class="s2">]</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">raise</span>
        <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">v</span><span class="s2">, </span><span class="s1">ErrorWrapper</span><span class="s2">(</span><span class="s1">MissingDiscriminator</span><span class="s2">(</span><span class="s1">discriminator_key</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">discriminator_key</span><span class="s2">), </span><span class="s1">loc</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">TypeError</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s5"># BaseModel or dataclass</span>
                <span class="s1">discriminator_value </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">discriminator_key</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s2">(</span><span class="s1">AttributeError</span><span class="s2">, </span><span class="s1">TypeError</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">v</span><span class="s2">, </span><span class="s1">ErrorWrapper</span><span class="s2">(</span><span class="s1">MissingDiscriminator</span><span class="s2">(</span><span class="s1">discriminator_key</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">discriminator_key</span><span class="s2">), </span><span class="s1">loc</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields_mapping </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s1">cls </span><span class="s0">is not None</span>
            <span class="s0">raise </span><span class="s1">ConfigError</span><span class="s2">(</span>
                <span class="s3">f'field &quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s0">}</span><span class="s3">&quot; not yet prepared so type is still a ForwardRef, '</span>
                <span class="s3">f'you might need to call </span><span class="s0">{</span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">}</span><span class="s3">.update_forward_refs().'</span>
            <span class="s2">)</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">sub_field </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields_mapping</span><span class="s2">[</span><span class="s1">discriminator_value</span><span class="s2">]</span>
        <span class="s0">except </span><span class="s2">(</span><span class="s1">KeyError</span><span class="s2">, </span><span class="s1">TypeError</span><span class="s2">):</span>
            <span class="s5"># KeyError: `discriminator_value` is not in the dictionary.</span>
            <span class="s5"># TypeError: `discriminator_value` is unhashable.</span>
            <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields_mapping </span><span class="s0">is not None</span>
            <span class="s0">return </span><span class="s1">v</span><span class="s2">, </span><span class="s1">ErrorWrapper</span><span class="s2">(</span>
                <span class="s1">InvalidDiscriminator</span><span class="s2">(</span>
                    <span class="s1">discriminator_key</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">discriminator_key</span><span class="s2">,</span>
                    <span class="s1">discriminator_value</span><span class="s2">=</span><span class="s1">discriminator_value</span><span class="s2">,</span>
                    <span class="s1">allowed_values</span><span class="s2">=</span><span class="s1">list</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields_mapping</span><span class="s2">),</span>
                <span class="s2">),</span>
                <span class="s1">loc</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s1">loc </span><span class="s2">= (</span><span class="s1">loc</span><span class="s2">,)</span>
            <span class="s0">return </span><span class="s1">sub_field</span><span class="s2">.</span><span class="s1">validate</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">=(*</span><span class="s1">loc</span><span class="s2">, </span><span class="s1">display_as_type</span><span class="s2">(</span><span class="s1">sub_field</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)), </span><span class="s1">cls</span><span class="s2">=</span><span class="s1">cls</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_apply_validators</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">v</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">values</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], </span><span class="s1">loc</span><span class="s2">: </span><span class="s3">'LocStr'</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s3">'ModelOrDc'</span><span class="s2">], </span><span class="s1">validators</span><span class="s2">: </span><span class="s3">'ValidatorsList'</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s3">'ValidateReturn'</span><span class="s2">:</span>
        <span class="s0">for </span><span class="s1">validator </span><span class="s0">in </span><span class="s1">validators</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">v </span><span class="s2">= </span><span class="s1">validator</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">model_config</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">TypeError</span><span class="s2">, </span><span class="s1">AssertionError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">v</span><span class="s2">, </span><span class="s1">ErrorWrapper</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">v</span><span class="s2">, </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">is_complex</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Whether the field is &quot;complex&quot; eg. env variables should be parsed as JSON. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">main </span><span class="s0">import </span><span class="s1">BaseModel</span>

        <span class="s0">return </span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">SHAPE_SINGLETON</span>
            <span class="s0">or </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">, </span><span class="s3">'__pydantic_model__'</span><span class="s2">)</span>
            <span class="s0">or </span><span class="s1">lenient_issubclass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">, (</span><span class="s1">BaseModel</span><span class="s2">, </span><span class="s1">list</span><span class="s2">, </span><span class="s1">set</span><span class="s2">, </span><span class="s1">frozenset</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">))</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_type_display</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; PyObjectStr</span><span class="s2">:</span>
        <span class="s1">t </span><span class="s2">= </span><span class="s1">display_as_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s0">in </span><span class="s1">MAPPING_LIKE_SHAPES</span><span class="s2">:</span>
            <span class="s1">t </span><span class="s2">= </span><span class="s3">f'Mapping[</span><span class="s0">{</span><span class="s1">display_as_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">key_field</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)</span><span class="s0">}</span><span class="s3">, </span><span class="s0">{</span><span class="s1">t</span><span class="s0">}</span><span class="s3">]'  </span><span class="s5"># type: ignore</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">SHAPE_TUPLE</span><span class="s2">:</span>
            <span class="s1">t </span><span class="s2">= </span><span class="s3">'Tuple[{}]'</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s3">', '</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">display_as_type</span><span class="s2">(</span><span class="s1">f</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">) </span><span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields</span><span class="s2">))  </span><span class="s5"># type: ignore</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">SHAPE_GENERIC</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields</span>
            <span class="s1">t </span><span class="s2">= </span><span class="s3">'{}[{}]'</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span>
                <span class="s1">display_as_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">), </span><span class="s3">', '</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">display_as_type</span><span class="s2">(</span><span class="s1">f</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">) </span><span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields</span><span class="s2">)</span>
            <span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">SHAPE_SINGLETON</span><span class="s2">:</span>
            <span class="s1">t </span><span class="s2">= </span><span class="s1">SHAPE_NAME_LOOKUP</span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">].</span><span class="s1">format</span><span class="s2">(</span><span class="s1">t</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">allow_none </span><span class="s0">and </span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">SHAPE_SINGLETON </span><span class="s0">or not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sub_fields</span><span class="s2">):</span>
            <span class="s1">t </span><span class="s2">= </span><span class="s3">f'Optional[</span><span class="s0">{</span><span class="s1">t</span><span class="s0">}</span><span class="s3">]'</span>
        <span class="s0">return </span><span class="s1">PyObjectStr</span><span class="s2">(</span><span class="s1">t</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__repr_args__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s3">'ReprArgs'</span><span class="s2">:</span>
        <span class="s1">args </span><span class="s2">= [(</span><span class="s3">'name'</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">), (</span><span class="s3">'type'</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_type_display</span><span class="s2">()), (</span><span class="s3">'required'</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">required</span><span class="s2">)]</span>

        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">required</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">default_factory </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">args</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s3">'default_factory'</span><span class="s2">, </span><span class="s3">f'&lt;function </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">default_factory</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">}</span><span class="s3">&gt;'</span><span class="s2">))</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">args</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s3">'default'</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">default</span><span class="s2">))</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">alt_alias</span><span class="s2">:</span>
            <span class="s1">args</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s3">'alias'</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">alias</span><span class="s2">))</span>
        <span class="s0">return </span><span class="s1">args</span>


<span class="s0">class </span><span class="s1">ModelPrivateAttr</span><span class="s2">(</span><span class="s1">Representation</span><span class="s2">):</span>
    <span class="s1">__slots__ </span><span class="s2">= (</span><span class="s3">'default'</span><span class="s2">, </span><span class="s3">'default_factory'</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">default</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">= </span><span class="s1">Undefined</span><span class="s2">, *, </span><span class="s1">default_factory</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">NoArgAnyCallable</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">default </span><span class="s2">= </span><span class="s1">default</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">default_factory </span><span class="s2">= </span><span class="s1">default_factory</span>

    <span class="s0">def </span><span class="s1">get_default</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">smart_deepcopy</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">default</span><span class="s2">) </span><span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">default_factory </span><span class="s0">is None else </span><span class="s1">self</span><span class="s2">.</span><span class="s1">default_factory</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">__eq__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">) </span><span class="s0">and </span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">default</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">default_factory</span><span class="s2">) == (</span>
            <span class="s1">other</span><span class="s2">.</span><span class="s1">default</span><span class="s2">,</span>
            <span class="s1">other</span><span class="s2">.</span><span class="s1">default_factory</span><span class="s2">,</span>
        <span class="s2">)</span>


<span class="s0">def </span><span class="s1">PrivateAttr</span><span class="s2">(</span>
    <span class="s1">default</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">= </span><span class="s1">Undefined</span><span class="s2">,</span>
    <span class="s2">*,</span>
    <span class="s1">default_factory</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">NoArgAnyCallable</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Indicates that attribute is only used internally and never mixed with regular fields. 
 
    Types or values of private attrs are not checked by pydantic and it's up to you to keep them relevant. 
 
    Private attrs are stored in model __slots__. 
 
    :param default: the attribute’s default value 
    :param default_factory: callable that will be called when a default value is needed for this attribute 
      If both `default` and `default_factory` are set, an error is raised. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">default </span><span class="s0">is not </span><span class="s1">Undefined </span><span class="s0">and </span><span class="s1">default_factory </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'cannot specify both default and default_factory'</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">ModelPrivateAttr</span><span class="s2">(</span>
        <span class="s1">default</span><span class="s2">,</span>
        <span class="s1">default_factory</span><span class="s2">=</span><span class="s1">default_factory</span><span class="s2">,</span>
    <span class="s2">)</span>


<span class="s0">class </span><span class="s1">DeferredType</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Used to postpone field preparation, while creating recursive generic models. 
    &quot;&quot;&quot;</span>


<span class="s0">def </span><span class="s1">is_finalvar_with_default_val</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">], </span><span class="s1">val</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
    <span class="s0">return </span><span class="s1">is_finalvar</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">) </span><span class="s0">and </span><span class="s1">val </span><span class="s0">is not </span><span class="s1">Undefined </span><span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">FieldInfo</span><span class="s2">)</span>
</pre>
</body>
</html>