<html>
<head>
<title>_generate_schema.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_generate_schema.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Convert python types to pydantic-core schema.&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations </span><span class="s2">as </span><span class="s1">_annotations</span>

<span class="s2">import </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span>
<span class="s2">import </span><span class="s1">dataclasses</span>
<span class="s2">import </span><span class="s1">datetime</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">pathlib</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">typing</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc </span><span class="s2">import </span><span class="s1">Generator</span><span class="s3">, </span><span class="s1">Iterable</span><span class="s3">, </span><span class="s1">Iterator</span><span class="s3">, </span><span class="s1">Mapping</span>
<span class="s2">from </span><span class="s1">contextlib </span><span class="s2">import </span><span class="s1">contextmanager</span>
<span class="s2">from </span><span class="s1">copy </span><span class="s2">import </span><span class="s1">copy</span>
<span class="s2">from </span><span class="s1">decimal </span><span class="s2">import </span><span class="s1">Decimal</span>
<span class="s2">from </span><span class="s1">enum </span><span class="s2">import </span><span class="s1">Enum</span>
<span class="s2">from </span><span class="s1">fractions </span><span class="s2">import </span><span class="s1">Fraction</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span>
<span class="s2">from </span><span class="s1">inspect </span><span class="s2">import </span><span class="s1">Parameter</span><span class="s3">, </span><span class="s1">_ParameterKind</span><span class="s3">, </span><span class="s1">signature</span>
<span class="s2">from </span><span class="s1">ipaddress </span><span class="s2">import </span><span class="s1">IPv4Address</span><span class="s3">, </span><span class="s1">IPv4Interface</span><span class="s3">, </span><span class="s1">IPv4Network</span><span class="s3">, </span><span class="s1">IPv6Address</span><span class="s3">, </span><span class="s1">IPv6Interface</span><span class="s3">, </span><span class="s1">IPv6Network</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">chain</span>
<span class="s2">from </span><span class="s1">operator </span><span class="s2">import </span><span class="s1">attrgetter</span>
<span class="s2">from </span><span class="s1">types </span><span class="s2">import </span><span class="s1">FunctionType</span><span class="s3">, </span><span class="s1">GenericAlias</span><span class="s3">, </span><span class="s1">LambdaType</span><span class="s3">, </span><span class="s1">MethodType</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s3">,</span>
    <span class="s1">Any</span><span class="s3">,</span>
    <span class="s1">Callable</span><span class="s3">,</span>
    <span class="s1">Final</span><span class="s3">,</span>
    <span class="s1">ForwardRef</span><span class="s3">,</span>
    <span class="s1">Literal</span><span class="s3">,</span>
    <span class="s1">TypeVar</span><span class="s3">,</span>
    <span class="s1">Union</span><span class="s3">,</span>
    <span class="s1">cast</span><span class="s3">,</span>
    <span class="s1">overload</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">uuid </span><span class="s2">import </span><span class="s1">UUID</span>
<span class="s2">from </span><span class="s1">warnings </span><span class="s2">import </span><span class="s1">warn</span>
<span class="s2">from </span><span class="s1">zoneinfo </span><span class="s2">import </span><span class="s1">ZoneInfo</span>

<span class="s2">import </span><span class="s1">typing_extensions</span>
<span class="s2">from </span><span class="s1">pydantic_core </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s1">MultiHostUrl</span><span class="s3">,</span>
    <span class="s1">PydanticCustomError</span><span class="s3">,</span>
    <span class="s1">PydanticSerializationUnexpectedValue</span><span class="s3">,</span>
    <span class="s1">PydanticUndefined</span><span class="s3">,</span>
    <span class="s1">Url</span><span class="s3">,</span>
    <span class="s1">core_schema</span><span class="s3">,</span>
    <span class="s1">to_jsonable_python</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">typing_extensions </span><span class="s2">import </span><span class="s1">TypeAlias</span><span class="s3">, </span><span class="s1">TypeAliasType</span><span class="s3">, </span><span class="s1">TypedDict</span><span class="s3">, </span><span class="s1">get_args</span><span class="s3">, </span><span class="s1">get_origin</span><span class="s3">, </span><span class="s1">is_typeddict</span>
<span class="s2">from </span><span class="s1">typing_inspection </span><span class="s2">import </span><span class="s1">typing_objects</span>
<span class="s2">from </span><span class="s1">typing_inspection</span><span class="s3">.</span><span class="s1">introspection </span><span class="s2">import </span><span class="s1">AnnotationSource</span><span class="s3">, </span><span class="s1">get_literal_values</span><span class="s3">, </span><span class="s1">is_union_origin</span>

<span class="s2">from </span><span class="s3">..</span><span class="s1">aliases </span><span class="s2">import </span><span class="s1">AliasChoices</span><span class="s3">, </span><span class="s1">AliasGenerator</span><span class="s3">, </span><span class="s1">AliasPath</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">annotated_handlers </span><span class="s2">import </span><span class="s1">GetCoreSchemaHandler</span><span class="s3">, </span><span class="s1">GetJsonSchemaHandler</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">config </span><span class="s2">import </span><span class="s1">ConfigDict</span><span class="s3">, </span><span class="s1">JsonDict</span><span class="s3">, </span><span class="s1">JsonEncoder</span><span class="s3">, </span><span class="s1">JsonSchemaExtraCallable</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">errors </span><span class="s2">import </span><span class="s1">PydanticSchemaGenerationError</span><span class="s3">, </span><span class="s1">PydanticUndefinedAnnotation</span><span class="s3">, </span><span class="s1">PydanticUserError</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">functional_validators </span><span class="s2">import </span><span class="s1">AfterValidator</span><span class="s3">, </span><span class="s1">BeforeValidator</span><span class="s3">, </span><span class="s1">FieldValidatorModes</span><span class="s3">, </span><span class="s1">PlainValidator</span><span class="s3">, </span><span class="s1">WrapValidator</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">json_schema </span><span class="s2">import </span><span class="s1">JsonSchemaValue</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">version </span><span class="s2">import </span><span class="s1">version_short</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">warnings </span><span class="s2">import </span><span class="s1">PydanticDeprecatedSince20</span>
<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">_decorators</span><span class="s3">, </span><span class="s1">_discriminated_union</span><span class="s3">, </span><span class="s1">_known_annotated_metadata</span><span class="s3">, </span><span class="s1">_repr</span><span class="s3">, </span><span class="s1">_typing_extra</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_config </span><span class="s2">import </span><span class="s1">ConfigWrapper</span><span class="s3">, </span><span class="s1">ConfigWrapperStack</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_core_metadata </span><span class="s2">import </span><span class="s1">CoreMetadata</span><span class="s3">, </span><span class="s1">update_core_metadata</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_core_utils </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">get_ref</span><span class="s3">,</span>
    <span class="s1">get_type_ref</span><span class="s3">,</span>
    <span class="s1">is_list_like_schema_with_items_schema</span><span class="s3">,</span>
    <span class="s1">validate_core_schema</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_decorators </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">Decorator</span><span class="s3">,</span>
    <span class="s1">DecoratorInfos</span><span class="s3">,</span>
    <span class="s1">FieldSerializerDecoratorInfo</span><span class="s3">,</span>
    <span class="s1">FieldValidatorDecoratorInfo</span><span class="s3">,</span>
    <span class="s1">ModelSerializerDecoratorInfo</span><span class="s3">,</span>
    <span class="s1">ModelValidatorDecoratorInfo</span><span class="s3">,</span>
    <span class="s1">RootValidatorDecoratorInfo</span><span class="s3">,</span>
    <span class="s1">ValidatorDecoratorInfo</span><span class="s3">,</span>
    <span class="s1">get_attribute_from_bases</span><span class="s3">,</span>
    <span class="s1">inspect_field_serializer</span><span class="s3">,</span>
    <span class="s1">inspect_model_serializer</span><span class="s3">,</span>
    <span class="s1">inspect_validator</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_docs_extraction </span><span class="s2">import </span><span class="s1">extract_docstrings_from_cls</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_fields </span><span class="s2">import </span><span class="s1">collect_dataclass_fields</span><span class="s3">, </span><span class="s1">rebuild_model_fields</span><span class="s3">, </span><span class="s1">takes_validated_data_argument</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_forward_ref </span><span class="s2">import </span><span class="s1">PydanticRecursiveRef</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_generics </span><span class="s2">import </span><span class="s1">get_standard_typevars_map</span><span class="s3">, </span><span class="s1">replace_types</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_import_utils </span><span class="s2">import </span><span class="s1">import_cached_base_model</span><span class="s3">, </span><span class="s1">import_cached_field_info</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_mock_val_ser </span><span class="s2">import </span><span class="s1">MockCoreSchema</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_namespace_utils </span><span class="s2">import </span><span class="s1">NamespacesTuple</span><span class="s3">, </span><span class="s1">NsResolver</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_schema_gather </span><span class="s2">import </span><span class="s1">MissingDefinitionError</span><span class="s3">, </span><span class="s1">gather_schemas_for_cleaning</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_schema_generation_shared </span><span class="s2">import </span><span class="s1">CallbackGetCoreSchemaHandler</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_utils </span><span class="s2">import </span><span class="s1">lenient_issubclass</span><span class="s3">, </span><span class="s1">smart_deepcopy</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">fields </span><span class="s2">import </span><span class="s1">ComputedFieldInfo</span><span class="s3">, </span><span class="s1">FieldInfo</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">main </span><span class="s2">import </span><span class="s1">BaseModel</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">types </span><span class="s2">import </span><span class="s1">Discriminator</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_dataclasses </span><span class="s2">import </span><span class="s1">StandardDataclass</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_schema_generation_shared </span><span class="s2">import </span><span class="s1">GetJsonSchemaFunction</span>

<span class="s1">_SUPPORTS_TYPEDDICT </span><span class="s3">= </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">12</span><span class="s3">)</span>

<span class="s1">FieldDecoratorInfo </span><span class="s3">= </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">ValidatorDecoratorInfo</span><span class="s3">, </span><span class="s1">FieldValidatorDecoratorInfo</span><span class="s3">, </span><span class="s1">FieldSerializerDecoratorInfo</span><span class="s3">]</span>
<span class="s1">FieldDecoratorInfoType </span><span class="s3">= </span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s5">'FieldDecoratorInfoType'</span><span class="s3">, </span><span class="s1">bound</span><span class="s3">=</span><span class="s1">FieldDecoratorInfo</span><span class="s3">)</span>
<span class="s1">AnyFieldDecorator </span><span class="s3">= </span><span class="s1">Union</span><span class="s3">[</span>
    <span class="s1">Decorator</span><span class="s3">[</span><span class="s1">ValidatorDecoratorInfo</span><span class="s3">],</span>
    <span class="s1">Decorator</span><span class="s3">[</span><span class="s1">FieldValidatorDecoratorInfo</span><span class="s3">],</span>
    <span class="s1">Decorator</span><span class="s3">[</span><span class="s1">FieldSerializerDecoratorInfo</span><span class="s3">],</span>
<span class="s3">]</span>

<span class="s1">ModifyCoreSchemaWrapHandler</span><span class="s3">: </span><span class="s1">TypeAlias </span><span class="s3">= </span><span class="s1">GetCoreSchemaHandler</span>
<span class="s1">GetCoreSchemaFunction</span><span class="s3">: </span><span class="s1">TypeAlias </span><span class="s3">= </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">ModifyCoreSchemaWrapHandler</span><span class="s3">], </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">]</span>
<span class="s1">ParametersCallback</span><span class="s3">: </span><span class="s1">TypeAlias </span><span class="s3">= </span><span class="s5">&quot;Callable[[int, str, Any], Literal['skip'] | None]&quot;</span>

<span class="s1">TUPLE_TYPES</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">type</span><span class="s3">] = [</span><span class="s1">typing</span><span class="s3">.</span><span class="s1">Tuple</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">]  </span><span class="s6"># noqa: UP006</span>
<span class="s1">LIST_TYPES</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">type</span><span class="s3">] = [</span><span class="s1">typing</span><span class="s3">.</span><span class="s1">List</span><span class="s3">, </span><span class="s1">list</span><span class="s3">, </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">MutableSequence</span><span class="s3">]  </span><span class="s6"># noqa: UP006</span>
<span class="s1">SET_TYPES</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">type</span><span class="s3">] = [</span><span class="s1">typing</span><span class="s3">.</span><span class="s1">Set</span><span class="s3">, </span><span class="s1">set</span><span class="s3">, </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">MutableSet</span><span class="s3">]  </span><span class="s6"># noqa: UP006</span>
<span class="s1">FROZEN_SET_TYPES</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">type</span><span class="s3">] = [</span><span class="s1">typing</span><span class="s3">.</span><span class="s1">FrozenSet</span><span class="s3">, </span><span class="s1">frozenset</span><span class="s3">, </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">Set</span><span class="s3">]  </span><span class="s6"># noqa: UP006</span>
<span class="s1">DICT_TYPES</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">type</span><span class="s3">] = [</span><span class="s1">typing</span><span class="s3">.</span><span class="s1">Dict</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">]  </span><span class="s6"># noqa: UP006</span>
<span class="s1">IP_TYPES</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">type</span><span class="s3">] = [</span><span class="s1">IPv4Address</span><span class="s3">, </span><span class="s1">IPv4Interface</span><span class="s3">, </span><span class="s1">IPv4Network</span><span class="s3">, </span><span class="s1">IPv6Address</span><span class="s3">, </span><span class="s1">IPv6Interface</span><span class="s3">, </span><span class="s1">IPv6Network</span><span class="s3">]</span>
<span class="s1">SEQUENCE_TYPES</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">type</span><span class="s3">] = [</span><span class="s1">typing</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">, </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">]</span>
<span class="s1">ITERABLE_TYPES</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">type</span><span class="s3">] = [</span><span class="s1">typing</span><span class="s3">.</span><span class="s1">Iterable</span><span class="s3">, </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">Iterable</span><span class="s3">, </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">Generator</span><span class="s3">, </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">Generator</span><span class="s3">]</span>
<span class="s1">TYPE_TYPES</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">type</span><span class="s3">] = [</span><span class="s1">typing</span><span class="s3">.</span><span class="s1">Type</span><span class="s3">, </span><span class="s1">type</span><span class="s3">]  </span><span class="s6"># noqa: UP006</span>
<span class="s1">PATTERN_TYPES</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">type</span><span class="s3">] = [</span><span class="s1">typing</span><span class="s3">.</span><span class="s1">Pattern</span><span class="s3">, </span><span class="s1">re</span><span class="s3">.</span><span class="s1">Pattern</span><span class="s3">]</span>
<span class="s1">PATH_TYPES</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">type</span><span class="s3">] = [</span>
    <span class="s1">os</span><span class="s3">.</span><span class="s1">PathLike</span><span class="s3">,</span>
    <span class="s1">pathlib</span><span class="s3">.</span><span class="s1">Path</span><span class="s3">,</span>
    <span class="s1">pathlib</span><span class="s3">.</span><span class="s1">PurePath</span><span class="s3">,</span>
    <span class="s1">pathlib</span><span class="s3">.</span><span class="s1">PosixPath</span><span class="s3">,</span>
    <span class="s1">pathlib</span><span class="s3">.</span><span class="s1">PurePosixPath</span><span class="s3">,</span>
    <span class="s1">pathlib</span><span class="s3">.</span><span class="s1">PureWindowsPath</span><span class="s3">,</span>
<span class="s3">]</span>
<span class="s1">MAPPING_TYPES </span><span class="s3">= [</span>
    <span class="s1">typing</span><span class="s3">.</span><span class="s1">Mapping</span><span class="s3">,</span>
    <span class="s1">typing</span><span class="s3">.</span><span class="s1">MutableMapping</span><span class="s3">,</span>
    <span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">Mapping</span><span class="s3">,</span>
    <span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">MutableMapping</span><span class="s3">,</span>
    <span class="s1">collections</span><span class="s3">.</span><span class="s1">OrderedDict</span><span class="s3">,</span>
    <span class="s1">typing_extensions</span><span class="s3">.</span><span class="s1">OrderedDict</span><span class="s3">,</span>
    <span class="s1">typing</span><span class="s3">.</span><span class="s1">DefaultDict</span><span class="s3">,  </span><span class="s6"># noqa: UP006</span>
    <span class="s1">collections</span><span class="s3">.</span><span class="s1">defaultdict</span><span class="s3">,</span>
<span class="s3">]</span>
<span class="s1">COUNTER_TYPES </span><span class="s3">= [</span><span class="s1">collections</span><span class="s3">.</span><span class="s1">Counter</span><span class="s3">, </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">Counter</span><span class="s3">]</span>
<span class="s1">DEQUE_TYPES</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">type</span><span class="s3">] = [</span><span class="s1">collections</span><span class="s3">.</span><span class="s1">deque</span><span class="s3">, </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">Deque</span><span class="s3">]  </span><span class="s6"># noqa: UP006</span>

<span class="s6"># Note: This does not play very well with type checkers. For example,</span>
<span class="s6"># `a: LambdaType = lambda x: x` will raise a type error by Pyright.</span>
<span class="s1">ValidateCallSupportedTypes </span><span class="s3">= </span><span class="s1">Union</span><span class="s3">[</span>
    <span class="s1">LambdaType</span><span class="s3">,</span>
    <span class="s1">FunctionType</span><span class="s3">,</span>
    <span class="s1">MethodType</span><span class="s3">,</span>
    <span class="s1">partial</span><span class="s3">,</span>
<span class="s3">]</span>

<span class="s1">VALIDATE_CALL_SUPPORTED_TYPES </span><span class="s3">= </span><span class="s1">get_args</span><span class="s3">(</span><span class="s1">ValidateCallSupportedTypes</span><span class="s3">)</span>

<span class="s1">_mode_to_validator</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span>
    <span class="s1">FieldValidatorModes</span><span class="s3">, </span><span class="s1">type</span><span class="s3">[</span><span class="s1">BeforeValidator </span><span class="s3">| </span><span class="s1">AfterValidator </span><span class="s3">| </span><span class="s1">PlainValidator </span><span class="s3">| </span><span class="s1">WrapValidator</span><span class="s3">]</span>
<span class="s3">] = {</span><span class="s5">'before'</span><span class="s3">: </span><span class="s1">BeforeValidator</span><span class="s3">, </span><span class="s5">'after'</span><span class="s3">: </span><span class="s1">AfterValidator</span><span class="s3">, </span><span class="s5">'plain'</span><span class="s3">: </span><span class="s1">PlainValidator</span><span class="s3">, </span><span class="s5">'wrap'</span><span class="s3">: </span><span class="s1">WrapValidator</span><span class="s3">}</span>


<span class="s2">def </span><span class="s1">check_validator_fields_against_field_name</span><span class="s3">(</span>
    <span class="s1">info</span><span class="s3">: </span><span class="s1">FieldDecoratorInfo</span><span class="s3">,</span>
    <span class="s1">field</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Check if field name is in validator fields. 
 
    Args: 
        info: The field info. 
        field: The field name to check. 
 
    Returns: 
        `True` if field name is in validator fields, `False` otherwise. 
    &quot;&quot;&quot;</span>
    <span class="s1">fields </span><span class="s3">= </span><span class="s1">info</span><span class="s3">.</span><span class="s1">fields</span>
    <span class="s2">return </span><span class="s5">'*' </span><span class="s2">in </span><span class="s1">fields </span><span class="s2">or </span><span class="s1">field </span><span class="s2">in </span><span class="s1">fields</span>


<span class="s2">def </span><span class="s1">check_decorator_fields_exist</span><span class="s3">(</span><span class="s1">decorators</span><span class="s3">: </span><span class="s1">Iterable</span><span class="s3">[</span><span class="s1">AnyFieldDecorator</span><span class="s3">], </span><span class="s1">fields</span><span class="s3">: </span><span class="s1">Iterable</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Check if the defined fields in decorators exist in `fields` param. 
 
    It ignores the check for a decorator if the decorator has `*` as field or `check_fields=False`. 
 
    Args: 
        decorators: An iterable of decorators. 
        fields: An iterable of fields name. 
 
    Raises: 
        PydanticUserError: If one of the field names does not exist in `fields` param. 
    &quot;&quot;&quot;</span>
    <span class="s1">fields </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">fields</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">dec </span><span class="s2">in </span><span class="s1">decorators</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s5">'*' </span><span class="s2">in </span><span class="s1">dec</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">fields</span><span class="s3">:</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">dec</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">check_fields </span><span class="s2">is False</span><span class="s3">:</span>
            <span class="s2">continue</span>
        <span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s1">dec</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">fields</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">field </span><span class="s2">not in </span><span class="s1">fields</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">PydanticUserError</span><span class="s3">(</span>
                    <span class="s5">f'Decorators defined with incorrect fields: </span><span class="s2">{</span><span class="s1">dec</span><span class="s3">.</span><span class="s1">cls_ref</span><span class="s2">}</span><span class="s5">.</span><span class="s2">{</span><span class="s1">dec</span><span class="s3">.</span><span class="s1">cls_var_name</span><span class="s2">}</span><span class="s5">'</span>
                    <span class="s5">&quot; (use check_fields=False if you're inheriting from the model and intended this)&quot;</span><span class="s3">,</span>
                    <span class="s1">code</span><span class="s3">=</span><span class="s5">'decorator-missing-field'</span><span class="s3">,</span>
                <span class="s3">)</span>


<span class="s2">def </span><span class="s1">filter_field_decorator_info_by_field</span><span class="s3">(</span>
    <span class="s1">validator_functions</span><span class="s3">: </span><span class="s1">Iterable</span><span class="s3">[</span><span class="s1">Decorator</span><span class="s3">[</span><span class="s1">FieldDecoratorInfoType</span><span class="s3">]], </span><span class="s1">field</span><span class="s3">: </span><span class="s1">str</span>
<span class="s3">) </span><span class="s1">-&gt; list</span><span class="s3">[</span><span class="s1">Decorator</span><span class="s3">[</span><span class="s1">FieldDecoratorInfoType</span><span class="s3">]]:</span>
    <span class="s2">return </span><span class="s3">[</span><span class="s1">dec </span><span class="s2">for </span><span class="s1">dec </span><span class="s2">in </span><span class="s1">validator_functions </span><span class="s2">if </span><span class="s1">check_validator_fields_against_field_name</span><span class="s3">(</span><span class="s1">dec</span><span class="s3">.</span><span class="s1">info</span><span class="s3">, </span><span class="s1">field</span><span class="s3">)]</span>


<span class="s2">def </span><span class="s1">apply_each_item_validators</span><span class="s3">(</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s1">each_item_validators</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">Decorator</span><span class="s3">[</span><span class="s1">ValidatorDecoratorInfo</span><span class="s3">]],</span>
    <span class="s1">field_name</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
    <span class="s6"># This V1 compatibility shim should eventually be removed</span>

    <span class="s6"># fail early if each_item_validators is empty</span>
    <span class="s2">if not </span><span class="s1">each_item_validators</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">schema</span>

    <span class="s6"># push down any `each_item=True` validators</span>
    <span class="s6"># note that this won't work for any Annotated types that get wrapped by a function validator</span>
    <span class="s6"># but that's okay because that didn't exist in V1</span>
    <span class="s2">if </span><span class="s1">schema</span><span class="s3">[</span><span class="s5">'type'</span><span class="s3">] == </span><span class="s5">'nullable'</span><span class="s3">:</span>
        <span class="s1">schema</span><span class="s3">[</span><span class="s5">'schema'</span><span class="s3">] = </span><span class="s1">apply_each_item_validators</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s5">'schema'</span><span class="s3">], </span><span class="s1">each_item_validators</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">schema</span>
    <span class="s2">elif </span><span class="s1">schema</span><span class="s3">[</span><span class="s5">'type'</span><span class="s3">] == </span><span class="s5">'tuple'</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">variadic_item_index </span><span class="s3">:= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'variadic_item_index'</span><span class="s3">)) </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">schema</span><span class="s3">[</span><span class="s5">'items_schema'</span><span class="s3">][</span><span class="s1">variadic_item_index</span><span class="s3">] = </span><span class="s1">apply_validators</span><span class="s3">(</span>
                <span class="s1">schema</span><span class="s3">[</span><span class="s5">'items_schema'</span><span class="s3">][</span><span class="s1">variadic_item_index</span><span class="s3">],</span>
                <span class="s1">each_item_validators</span><span class="s3">,</span>
                <span class="s1">field_name</span><span class="s3">,</span>
            <span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">is_list_like_schema_with_items_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">):</span>
        <span class="s1">inner_schema </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'items_schema'</span><span class="s3">, </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">any_schema</span><span class="s3">())</span>
        <span class="s1">schema</span><span class="s3">[</span><span class="s5">'items_schema'</span><span class="s3">] = </span><span class="s1">apply_validators</span><span class="s3">(</span><span class="s1">inner_schema</span><span class="s3">, </span><span class="s1">each_item_validators</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">schema</span><span class="s3">[</span><span class="s5">'type'</span><span class="s3">] == </span><span class="s5">'dict'</span><span class="s3">:</span>
        <span class="s1">inner_schema </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'values_schema'</span><span class="s3">, </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">any_schema</span><span class="s3">())</span>
        <span class="s1">schema</span><span class="s3">[</span><span class="s5">'values_schema'</span><span class="s3">] = </span><span class="s1">apply_validators</span><span class="s3">(</span><span class="s1">inner_schema</span><span class="s3">, </span><span class="s1">each_item_validators</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
            <span class="s5">f'`@validator(..., each_item=True)` cannot be applied to fields with a schema of </span><span class="s2">{</span><span class="s1">schema</span><span class="s3">[</span><span class="s5">&quot;type&quot;</span><span class="s3">]</span><span class="s2">}</span><span class="s5">'</span>
        <span class="s3">)</span>
    <span class="s2">return </span><span class="s1">schema</span>


<span class="s2">def </span><span class="s1">_extract_json_schema_info_from_field_info</span><span class="s3">(</span>
    <span class="s1">info</span><span class="s3">: </span><span class="s1">FieldInfo </span><span class="s3">| </span><span class="s1">ComputedFieldInfo</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; tuple</span><span class="s3">[</span><span class="s1">JsonDict </span><span class="s3">| </span><span class="s2">None</span><span class="s3">, </span><span class="s1">JsonDict </span><span class="s3">| </span><span class="s1">JsonSchemaExtraCallable </span><span class="s3">| </span><span class="s2">None</span><span class="s3">]:</span>
    <span class="s1">json_schema_updates </span><span class="s3">= {</span>
        <span class="s5">'title'</span><span class="s3">: </span><span class="s1">info</span><span class="s3">.</span><span class="s1">title</span><span class="s3">,</span>
        <span class="s5">'description'</span><span class="s3">: </span><span class="s1">info</span><span class="s3">.</span><span class="s1">description</span><span class="s3">,</span>
        <span class="s5">'deprecated'</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">deprecated</span><span class="s3">) </span><span class="s2">or </span><span class="s1">info</span><span class="s3">.</span><span class="s1">deprecated </span><span class="s3">== </span><span class="s5">'' </span><span class="s2">or None</span><span class="s3">,</span>
        <span class="s5">'examples'</span><span class="s3">: </span><span class="s1">to_jsonable_python</span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">examples</span><span class="s3">),</span>
    <span class="s3">}</span>
    <span class="s1">json_schema_updates </span><span class="s3">= {</span><span class="s1">k</span><span class="s3">: </span><span class="s1">v </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">json_schema_updates</span><span class="s3">.</span><span class="s1">items</span><span class="s3">() </span><span class="s2">if </span><span class="s1">v </span><span class="s2">is not None</span><span class="s3">}</span>
    <span class="s2">return </span><span class="s3">(</span><span class="s1">json_schema_updates </span><span class="s2">or None</span><span class="s3">, </span><span class="s1">info</span><span class="s3">.</span><span class="s1">json_schema_extra</span><span class="s3">)</span>


<span class="s1">JsonEncoders </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">type</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">], </span><span class="s1">JsonEncoder</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">_add_custom_serialization_from_json_encoders</span><span class="s3">(</span>
    <span class="s1">json_encoders</span><span class="s3">: </span><span class="s1">JsonEncoders </span><span class="s3">| </span><span class="s2">None</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span>
<span class="s3">) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Iterate over the json_encoders and add the first matching encoder to the schema. 
 
    Args: 
        json_encoders: A dictionary of types and their encoder functions. 
        tp: The type to check for a matching encoder. 
        schema: The schema to add the encoder to. 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">json_encoders</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">schema</span>
    <span class="s2">if </span><span class="s5">'serialization' </span><span class="s2">in </span><span class="s1">schema</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">schema</span>
    <span class="s6"># Check the class type and its superclasses for a matching encoder</span>
    <span class="s6"># Decimal.__class__.__mro__ (and probably other cases) doesn't include Decimal itself</span>
    <span class="s6"># if the type is a GenericAlias (e.g. from list[int]) we need to use __class__ instead of .__mro__</span>
    <span class="s2">for </span><span class="s1">base </span><span class="s2">in </span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, *</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s5">'__mro__'</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__mro__</span><span class="s3">)[:-</span><span class="s4">1</span><span class="s3">]):</span>
        <span class="s1">encoder </span><span class="s3">= </span><span class="s1">json_encoders</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">base</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">encoder </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">continue</span>

        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s5">f'`json_encoders` is deprecated. See https://docs.pydantic.dev/</span><span class="s2">{</span><span class="s1">version_short</span><span class="s3">()</span><span class="s2">}</span><span class="s5">/concepts/serialization/#custom-serializers for alternatives'</span><span class="s3">,</span>
            <span class="s1">PydanticDeprecatedSince20</span><span class="s3">,</span>
        <span class="s3">)</span>

        <span class="s6"># TODO: in theory we should check that the schema accepts a serialization key</span>
        <span class="s1">schema</span><span class="s3">[</span><span class="s5">'serialization'</span><span class="s3">] = </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">plain_serializer_function_ser_schema</span><span class="s3">(</span><span class="s1">encoder</span><span class="s3">, </span><span class="s1">when_used</span><span class="s3">=</span><span class="s5">'json'</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">schema</span>

    <span class="s2">return </span><span class="s1">schema</span>


<span class="s2">def </span><span class="s1">_get_first_non_null</span><span class="s3">(</span><span class="s1">a</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">b</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Return the first argument if it is not None, otherwise return the second argument. 
 
    Use case: serialization_alias (argument a) and alias (argument b) are both defined, and serialization_alias is ''. 
    This function will return serialization_alias, which is the first argument, even though it is an empty string. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">a </span><span class="s2">if </span><span class="s1">a </span><span class="s2">is not None else </span><span class="s1">b</span>


<span class="s2">class </span><span class="s1">InvalidSchemaError</span><span class="s3">(</span><span class="s1">Exception</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;The core schema is invalid.&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">GenerateSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Generate core schema for a Pydantic model, dataclass and types like `str`, `datetime`, ... .&quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s3">= (</span>
        <span class="s5">'_config_wrapper_stack'</span><span class="s3">,</span>
        <span class="s5">'_ns_resolver'</span><span class="s3">,</span>
        <span class="s5">'_typevars_map'</span><span class="s3">,</span>
        <span class="s5">'field_name_stack'</span><span class="s3">,</span>
        <span class="s5">'model_type_stack'</span><span class="s3">,</span>
        <span class="s5">'defs'</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">config_wrapper</span><span class="s3">: </span><span class="s1">ConfigWrapper</span><span class="s3">,</span>
        <span class="s1">ns_resolver</span><span class="s3">: </span><span class="s1">NsResolver </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">typevars_map</span><span class="s3">: </span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">TypeVar</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s6"># we need a stack for recursing into nested models</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper_stack </span><span class="s3">= </span><span class="s1">ConfigWrapperStack</span><span class="s3">(</span><span class="s1">config_wrapper</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_ns_resolver </span><span class="s3">= </span><span class="s1">ns_resolver </span><span class="s2">or </span><span class="s1">NsResolver</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_typevars_map </span><span class="s3">= </span><span class="s1">typevars_map</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">field_name_stack </span><span class="s3">= </span><span class="s1">_FieldNameStack</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">model_type_stack </span><span class="s3">= </span><span class="s1">_ModelTypeStack</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">defs </span><span class="s3">= </span><span class="s1">_Definitions</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">__init_subclass__</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">__init_subclass__</span><span class="s3">()</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s5">'Subclassing `GenerateSchema` is not supported. The API is highly subject to change in minor versions.'</span><span class="s3">,</span>
            <span class="s1">UserWarning</span><span class="s3">,</span>
            <span class="s1">stacklevel</span><span class="s3">=</span><span class="s4">2</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">_config_wrapper</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; ConfigWrapper</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper_stack</span><span class="s3">.</span><span class="s1">tail</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">_types_namespace</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; NamespacesTuple</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ns_resolver</span><span class="s3">.</span><span class="s1">types_namespace</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">_arbitrary_types</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper</span><span class="s3">.</span><span class="s1">arbitrary_types_allowed</span>

    <span class="s6"># the following methods can be overridden but should be considered</span>
    <span class="s6"># unstable / private APIs</span>
    <span class="s2">def </span><span class="s1">_list_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">items_type</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">list_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">items_type</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_dict_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">keys_type</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">values_type</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">dict_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">keys_type</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">values_type</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_set_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">items_type</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">set_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">items_type</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_frozenset_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">items_type</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">frozenset_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">items_type</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_enum_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">enum_type</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">Enum</span><span class="s3">]) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:</span>
        <span class="s1">cases</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">] = </span><span class="s1">list</span><span class="s3">(</span><span class="s1">enum_type</span><span class="s3">.</span><span class="s1">__members__</span><span class="s3">.</span><span class="s1">values</span><span class="s3">())</span>

        <span class="s1">enum_ref </span><span class="s3">= </span><span class="s1">get_type_ref</span><span class="s3">(</span><span class="s1">enum_type</span><span class="s3">)</span>
        <span class="s1">description </span><span class="s3">= </span><span class="s2">None if not </span><span class="s1">enum_type</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s2">else </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">cleandoc</span><span class="s3">(</span><span class="s1">enum_type</span><span class="s3">.</span><span class="s1">__doc__</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s3">(</span>
            <span class="s1">description </span><span class="s3">== </span><span class="s5">'An enumeration.'</span>
        <span class="s3">):  </span><span class="s6"># This is the default value provided by enum.EnumMeta.__new__; don't use it</span>
            <span class="s1">description </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">js_updates </span><span class="s3">= {</span><span class="s5">'title'</span><span class="s3">: </span><span class="s1">enum_type</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">, </span><span class="s5">'description'</span><span class="s3">: </span><span class="s1">description</span><span class="s3">}</span>
        <span class="s1">js_updates </span><span class="s3">= {</span><span class="s1">k</span><span class="s3">: </span><span class="s1">v </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">js_updates</span><span class="s3">.</span><span class="s1">items</span><span class="s3">() </span><span class="s2">if </span><span class="s1">v </span><span class="s2">is not None</span><span class="s3">}</span>

        <span class="s1">sub_type</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s5">'str'</span><span class="s3">, </span><span class="s5">'int'</span><span class="s3">, </span><span class="s5">'float'</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">enum_type</span><span class="s3">, </span><span class="s1">int</span><span class="s3">):</span>
            <span class="s1">sub_type </span><span class="s3">= </span><span class="s5">'int'</span>
            <span class="s1">value_ser_type</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">SerSchema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">simple_ser_schema</span><span class="s3">(</span><span class="s5">'int'</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">enum_type</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
            <span class="s6"># this handles `StrEnum` (3.11 only), and also `Foobar(str, Enum)`</span>
            <span class="s1">sub_type </span><span class="s3">= </span><span class="s5">'str'</span>
            <span class="s1">value_ser_type </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">simple_ser_schema</span><span class="s3">(</span><span class="s5">'str'</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">enum_type</span><span class="s3">, </span><span class="s1">float</span><span class="s3">):</span>
            <span class="s1">sub_type </span><span class="s3">= </span><span class="s5">'float'</span>
            <span class="s1">value_ser_type </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">simple_ser_schema</span><span class="s3">(</span><span class="s5">'float'</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s6"># TODO this is an ugly hack, how do we trigger an Any schema for serialization?</span>
            <span class="s1">value_ser_type </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">plain_serializer_function_ser_schema</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">x</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">cases</span><span class="s3">:</span>

            <span class="s2">def </span><span class="s1">get_json_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">: </span><span class="s1">GetJsonSchemaHandler</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
                <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">handler</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>
                <span class="s1">original_schema </span><span class="s3">= </span><span class="s1">handler</span><span class="s3">.</span><span class="s1">resolve_ref_schema</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">)</span>
                <span class="s1">original_schema</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">js_updates</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">json_schema</span>

            <span class="s6"># we don't want to add the missing to the schema if it's the default one</span>
            <span class="s1">default_missing </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">enum_type</span><span class="s3">.</span><span class="s1">_missing_</span><span class="s3">, </span><span class="s5">'__func__'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) </span><span class="s2">is </span><span class="s1">Enum</span><span class="s3">.</span><span class="s1">_missing_</span><span class="s3">.</span><span class="s1">__func__  </span><span class="s6"># pyright: ignore[reportFunctionMemberAccess]</span>
            <span class="s1">enum_schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">enum_schema</span><span class="s3">(</span>
                <span class="s1">enum_type</span><span class="s3">,</span>
                <span class="s1">cases</span><span class="s3">,</span>
                <span class="s1">sub_type</span><span class="s3">=</span><span class="s1">sub_type</span><span class="s3">,</span>
                <span class="s1">missing</span><span class="s3">=</span><span class="s2">None if </span><span class="s1">default_missing </span><span class="s2">else </span><span class="s1">enum_type</span><span class="s3">.</span><span class="s1">_missing_</span><span class="s3">,</span>
                <span class="s1">ref</span><span class="s3">=</span><span class="s1">enum_ref</span><span class="s3">,</span>
                <span class="s1">metadata</span><span class="s3">={</span><span class="s5">'pydantic_js_functions'</span><span class="s3">: [</span><span class="s1">get_json_schema</span><span class="s3">]},</span>
            <span class="s3">)</span>

            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper</span><span class="s3">.</span><span class="s1">use_enum_values</span><span class="s3">:</span>
                <span class="s1">enum_schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">no_info_after_validator_function</span><span class="s3">(</span>
                    <span class="s1">attrgetter</span><span class="s3">(</span><span class="s5">'value'</span><span class="s3">), </span><span class="s1">enum_schema</span><span class="s3">, </span><span class="s1">serialization</span><span class="s3">=</span><span class="s1">value_ser_type</span>
                <span class="s3">)</span>

            <span class="s2">return </span><span class="s1">enum_schema</span>

        <span class="s2">else</span><span class="s3">:</span>

            <span class="s2">def </span><span class="s1">get_json_schema_no_cases</span><span class="s3">(</span><span class="s1">_</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">: </span><span class="s1">GetJsonSchemaHandler</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
                <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">handler</span><span class="s3">(</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">enum_schema</span><span class="s3">(</span><span class="s1">enum_type</span><span class="s3">, </span><span class="s1">cases</span><span class="s3">, </span><span class="s1">sub_type</span><span class="s3">=</span><span class="s1">sub_type</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">=</span><span class="s1">enum_ref</span><span class="s3">))</span>
                <span class="s1">original_schema </span><span class="s3">= </span><span class="s1">handler</span><span class="s3">.</span><span class="s1">resolve_ref_schema</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">)</span>
                <span class="s1">original_schema</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">js_updates</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">json_schema</span>

            <span class="s6"># Use an isinstance check for enums with no cases.</span>
            <span class="s6"># The most important use case for this is creating TypeVar bounds for generics that should</span>
            <span class="s6"># be restricted to enums. This is more consistent than it might seem at first, since you can only</span>
            <span class="s6"># subclass enum.Enum (or subclasses of enum.Enum) if all parent classes have no cases.</span>
            <span class="s6"># We use the get_json_schema function when an Enum subclass has been declared with no cases</span>
            <span class="s6"># so that we can still generate a valid json schema.</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">is_instance_schema</span><span class="s3">(</span>
                <span class="s1">enum_type</span><span class="s3">,</span>
                <span class="s1">metadata</span><span class="s3">={</span><span class="s5">'pydantic_js_functions'</span><span class="s3">: [</span><span class="s1">get_json_schema_no_cases</span><span class="s3">]},</span>
            <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_ip_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:</span>
        <span class="s2">from </span><span class="s3">.</span><span class="s1">_validators </span><span class="s2">import </span><span class="s1">IP_VALIDATOR_LOOKUP</span><span class="s3">, </span><span class="s1">IpType</span>

        <span class="s1">ip_type_json_schema_format</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">type</span><span class="s3">[</span><span class="s1">IpType</span><span class="s3">], </span><span class="s1">str</span><span class="s3">] = {</span>
            <span class="s1">IPv4Address</span><span class="s3">: </span><span class="s5">'ipv4'</span><span class="s3">,</span>
            <span class="s1">IPv4Network</span><span class="s3">: </span><span class="s5">'ipv4network'</span><span class="s3">,</span>
            <span class="s1">IPv4Interface</span><span class="s3">: </span><span class="s5">'ipv4interface'</span><span class="s3">,</span>
            <span class="s1">IPv6Address</span><span class="s3">: </span><span class="s5">'ipv6'</span><span class="s3">,</span>
            <span class="s1">IPv6Network</span><span class="s3">: </span><span class="s5">'ipv6network'</span><span class="s3">,</span>
            <span class="s1">IPv6Interface</span><span class="s3">: </span><span class="s5">'ipv6interface'</span><span class="s3">,</span>
        <span class="s3">}</span>

        <span class="s2">def </span><span class="s1">ser_ip</span><span class="s3">(</span><span class="s1">ip</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">info</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">SerializationInfo</span><span class="s3">) </span><span class="s1">-&gt; str </span><span class="s3">| </span><span class="s1">IpType</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ip</span><span class="s3">, (</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">str</span><span class="s3">)):</span>
                <span class="s2">raise </span><span class="s1">PydanticSerializationUnexpectedValue</span><span class="s3">(</span>
                    <span class="s5">f&quot;Expected `</span><span class="s2">{</span><span class="s1">tp</span><span class="s2">}</span><span class="s5">` but got `</span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">ip</span><span class="s3">)</span><span class="s2">}</span><span class="s5">` with value `'</span><span class="s2">{</span><span class="s1">ip</span><span class="s2">}</span><span class="s5">'` - serialized value may not be as expected.&quot;</span>
                <span class="s3">)</span>
            <span class="s2">if </span><span class="s1">info</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s5">'python'</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">ip</span>
            <span class="s2">return </span><span class="s1">str</span><span class="s3">(</span><span class="s1">ip</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">lax_or_strict_schema</span><span class="s3">(</span>
            <span class="s1">lax_schema</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">no_info_plain_validator_function</span><span class="s3">(</span><span class="s1">IP_VALIDATOR_LOOKUP</span><span class="s3">[</span><span class="s1">tp</span><span class="s3">]),</span>
            <span class="s1">strict_schema</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">json_or_python_schema</span><span class="s3">(</span>
                <span class="s1">json_schema</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">no_info_after_validator_function</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">str_schema</span><span class="s3">()),</span>
                <span class="s1">python_schema</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">is_instance_schema</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">),</span>
            <span class="s3">),</span>
            <span class="s1">serialization</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">plain_serializer_function_ser_schema</span><span class="s3">(</span><span class="s1">ser_ip</span><span class="s3">, </span><span class="s1">info_arg</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">when_used</span><span class="s3">=</span><span class="s5">'always'</span><span class="s3">),</span>
            <span class="s1">metadata</span><span class="s3">={</span>
                <span class="s5">'pydantic_js_functions'</span><span class="s3">: [</span><span class="s2">lambda </span><span class="s1">_1</span><span class="s3">, </span><span class="s1">_2</span><span class="s3">: {</span><span class="s5">'type'</span><span class="s3">: </span><span class="s5">'string'</span><span class="s3">, </span><span class="s5">'format'</span><span class="s3">: </span><span class="s1">ip_type_json_schema_format</span><span class="s3">[</span><span class="s1">tp</span><span class="s3">]}]</span>
            <span class="s3">},</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_path_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">path_type</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">tp </span><span class="s2">is </span><span class="s1">os</span><span class="s3">.</span><span class="s1">PathLike </span><span class="s2">and </span><span class="s3">(</span><span class="s1">path_type </span><span class="s2">not in </span><span class="s3">{</span><span class="s1">str</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">} </span><span class="s2">and not </span><span class="s1">typing_objects</span><span class="s3">.</span><span class="s1">is_any</span><span class="s3">(</span><span class="s1">path_type</span><span class="s3">)):</span>
            <span class="s2">raise </span><span class="s1">PydanticUserError</span><span class="s3">(</span>
                <span class="s5">'`os.PathLike` can only be used with `str`, `bytes` or `Any`'</span><span class="s3">, </span><span class="s1">code</span><span class="s3">=</span><span class="s5">'schema-for-unknown-type'</span>
            <span class="s3">)</span>

        <span class="s1">path_constructor </span><span class="s3">= </span><span class="s1">pathlib</span><span class="s3">.</span><span class="s1">PurePath </span><span class="s2">if </span><span class="s1">tp </span><span class="s2">is </span><span class="s1">os</span><span class="s3">.</span><span class="s1">PathLike </span><span class="s2">else </span><span class="s1">tp</span>
        <span class="s1">strict_inner_schema </span><span class="s3">= (</span>
            <span class="s1">core_schema</span><span class="s3">.</span><span class="s1">bytes_schema</span><span class="s3">(</span><span class="s1">strict</span><span class="s3">=</span><span class="s2">True</span><span class="s3">) </span><span class="s2">if </span><span class="s3">(</span><span class="s1">path_type </span><span class="s2">is </span><span class="s1">bytes</span><span class="s3">) </span><span class="s2">else </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">str_schema</span><span class="s3">(</span><span class="s1">strict</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s3">)</span>
        <span class="s1">lax_inner_schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">bytes_schema</span><span class="s3">() </span><span class="s2">if </span><span class="s3">(</span><span class="s1">path_type </span><span class="s2">is </span><span class="s1">bytes</span><span class="s3">) </span><span class="s2">else </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">str_schema</span><span class="s3">()</span>

        <span class="s2">def </span><span class="s1">path_validator</span><span class="s3">(</span><span class="s1">input_value</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s1">bytes</span><span class="s3">) </span><span class="s1">-&gt; os</span><span class="s3">.</span><span class="s1">PathLike</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]:  </span><span class="s6"># type: ignore</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">path_type </span><span class="s2">is </span><span class="s1">bytes</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">input_value</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">):</span>
                        <span class="s2">try</span><span class="s3">:</span>
                            <span class="s1">input_value </span><span class="s3">= </span><span class="s1">input_value</span><span class="s3">.</span><span class="s1">decode</span><span class="s3">()</span>
                        <span class="s2">except </span><span class="s1">UnicodeDecodeError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                            <span class="s2">raise </span><span class="s1">PydanticCustomError</span><span class="s3">(</span><span class="s5">'bytes_type'</span><span class="s3">, </span><span class="s5">'Input must be valid bytes'</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s2">raise </span><span class="s1">PydanticCustomError</span><span class="s3">(</span><span class="s5">'bytes_type'</span><span class="s3">, </span><span class="s5">'Input must be bytes'</span><span class="s3">)</span>
                <span class="s2">elif not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">input_value</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
                    <span class="s2">raise </span><span class="s1">PydanticCustomError</span><span class="s3">(</span><span class="s5">'path_type'</span><span class="s3">, </span><span class="s5">'Input is not a valid path'</span><span class="s3">)</span>

                <span class="s2">return </span><span class="s1">path_constructor</span><span class="s3">(</span><span class="s1">input_value</span><span class="s3">)  </span><span class="s6"># type: ignore</span>
            <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">PydanticCustomError</span><span class="s3">(</span><span class="s5">'path_type'</span><span class="s3">, </span><span class="s5">'Input is not a valid path'</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>

        <span class="s2">def </span><span class="s1">ser_path</span><span class="s3">(</span><span class="s1">path</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">info</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">SerializationInfo</span><span class="s3">) </span><span class="s1">-&gt; str </span><span class="s3">| </span><span class="s1">os</span><span class="s3">.</span><span class="s1">PathLike</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]:</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, (</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">str</span><span class="s3">)):</span>
                <span class="s2">raise </span><span class="s1">PydanticSerializationUnexpectedValue</span><span class="s3">(</span>
                    <span class="s5">f&quot;Expected `</span><span class="s2">{</span><span class="s1">tp</span><span class="s2">}</span><span class="s5">` but got `</span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span><span class="s2">}</span><span class="s5">` with value `'</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s5">'` - serialized value may not be as expected.&quot;</span>
                <span class="s3">)</span>
            <span class="s2">if </span><span class="s1">info</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s5">'python'</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">path</span>
            <span class="s2">return </span><span class="s1">str</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>

        <span class="s1">instance_schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">json_or_python_schema</span><span class="s3">(</span>
            <span class="s1">json_schema</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">no_info_after_validator_function</span><span class="s3">(</span><span class="s1">path_validator</span><span class="s3">, </span><span class="s1">lax_inner_schema</span><span class="s3">),</span>
            <span class="s1">python_schema</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">is_instance_schema</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">),</span>
        <span class="s3">)</span>

        <span class="s1">schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">lax_or_strict_schema</span><span class="s3">(</span>
            <span class="s1">lax_schema</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">union_schema</span><span class="s3">(</span>
                <span class="s3">[</span>
                    <span class="s1">instance_schema</span><span class="s3">,</span>
                    <span class="s1">core_schema</span><span class="s3">.</span><span class="s1">no_info_after_validator_function</span><span class="s3">(</span><span class="s1">path_validator</span><span class="s3">, </span><span class="s1">strict_inner_schema</span><span class="s3">),</span>
                <span class="s3">],</span>
                <span class="s1">custom_error_type</span><span class="s3">=</span><span class="s5">'path_type'</span><span class="s3">,</span>
                <span class="s1">custom_error_message</span><span class="s3">=</span><span class="s5">f'Input is not a valid path for </span><span class="s2">{</span><span class="s1">tp</span><span class="s2">}</span><span class="s5">'</span><span class="s3">,</span>
            <span class="s3">),</span>
            <span class="s1">strict_schema</span><span class="s3">=</span><span class="s1">instance_schema</span><span class="s3">,</span>
            <span class="s1">serialization</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">plain_serializer_function_ser_schema</span><span class="s3">(</span><span class="s1">ser_path</span><span class="s3">, </span><span class="s1">info_arg</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">when_used</span><span class="s3">=</span><span class="s5">'always'</span><span class="s3">),</span>
            <span class="s1">metadata</span><span class="s3">={</span><span class="s5">'pydantic_js_functions'</span><span class="s3">: [</span><span class="s2">lambda </span><span class="s1">source</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">: {**</span><span class="s1">handler</span><span class="s3">(</span><span class="s1">source</span><span class="s3">), </span><span class="s5">'format'</span><span class="s3">: </span><span class="s5">'path'</span><span class="s3">}]},</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">schema</span>

    <span class="s2">def </span><span class="s1">_deque_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">items_type</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:</span>
        <span class="s2">from </span><span class="s3">.</span><span class="s1">_serializers </span><span class="s2">import </span><span class="s1">serialize_sequence_via_list</span>
        <span class="s2">from </span><span class="s3">.</span><span class="s1">_validators </span><span class="s2">import </span><span class="s1">deque_validator</span>

        <span class="s1">item_type_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">items_type</span><span class="s3">)</span>

        <span class="s6"># we have to use a lax list schema here, because we need to validate the deque's</span>
        <span class="s6"># items via a list schema, but it's ok if the deque itself is not a list</span>
        <span class="s1">list_schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">list_schema</span><span class="s3">(</span><span class="s1">item_type_schema</span><span class="s3">, </span><span class="s1">strict</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

        <span class="s1">check_instance </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">json_or_python_schema</span><span class="s3">(</span>
            <span class="s1">json_schema</span><span class="s3">=</span><span class="s1">list_schema</span><span class="s3">,</span>
            <span class="s1">python_schema</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">is_instance_schema</span><span class="s3">(</span><span class="s1">collections</span><span class="s3">.</span><span class="s1">deque</span><span class="s3">, </span><span class="s1">cls_repr</span><span class="s3">=</span><span class="s5">'Deque'</span><span class="s3">),</span>
        <span class="s3">)</span>

        <span class="s1">lax_schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">no_info_wrap_validator_function</span><span class="s3">(</span><span class="s1">deque_validator</span><span class="s3">, </span><span class="s1">list_schema</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">lax_or_strict_schema</span><span class="s3">(</span>
            <span class="s1">lax_schema</span><span class="s3">=</span><span class="s1">lax_schema</span><span class="s3">,</span>
            <span class="s1">strict_schema</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">chain_schema</span><span class="s3">([</span><span class="s1">check_instance</span><span class="s3">, </span><span class="s1">lax_schema</span><span class="s3">]),</span>
            <span class="s1">serialization</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">wrap_serializer_function_ser_schema</span><span class="s3">(</span>
                <span class="s1">serialize_sequence_via_list</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">=</span><span class="s1">item_type_schema</span><span class="s3">, </span><span class="s1">info_arg</span><span class="s3">=</span><span class="s2">True</span>
            <span class="s3">),</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_mapping_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">keys_type</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">values_type</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:</span>
        <span class="s2">from </span><span class="s3">.</span><span class="s1">_validators </span><span class="s2">import </span><span class="s1">MAPPING_ORIGIN_MAP</span><span class="s3">, </span><span class="s1">defaultdict_validator</span><span class="s3">, </span><span class="s1">get_defaultdict_default_default_factory</span>

        <span class="s1">mapped_origin </span><span class="s3">= </span><span class="s1">MAPPING_ORIGIN_MAP</span><span class="s3">[</span><span class="s1">tp</span><span class="s3">]</span>
        <span class="s1">keys_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">keys_type</span><span class="s3">)</span>
        <span class="s1">values_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">values_type</span><span class="s3">)</span>
        <span class="s1">dict_schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">dict_schema</span><span class="s3">(</span><span class="s1">keys_schema</span><span class="s3">, </span><span class="s1">values_schema</span><span class="s3">, </span><span class="s1">strict</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">mapped_origin </span><span class="s2">is </span><span class="s1">dict</span><span class="s3">:</span>
            <span class="s1">schema </span><span class="s3">= </span><span class="s1">dict_schema</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">check_instance </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">json_or_python_schema</span><span class="s3">(</span>
                <span class="s1">json_schema</span><span class="s3">=</span><span class="s1">dict_schema</span><span class="s3">,</span>
                <span class="s1">python_schema</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">is_instance_schema</span><span class="s3">(</span><span class="s1">mapped_origin</span><span class="s3">),</span>
            <span class="s3">)</span>

            <span class="s2">if </span><span class="s1">tp </span><span class="s2">is </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">defaultdict</span><span class="s3">:</span>
                <span class="s1">default_default_factory </span><span class="s3">= </span><span class="s1">get_defaultdict_default_default_factory</span><span class="s3">(</span><span class="s1">values_type</span><span class="s3">)</span>
                <span class="s1">coerce_instance_wrap </span><span class="s3">= </span><span class="s1">partial</span><span class="s3">(</span>
                    <span class="s1">core_schema</span><span class="s3">.</span><span class="s1">no_info_wrap_validator_function</span><span class="s3">,</span>
                    <span class="s1">partial</span><span class="s3">(</span><span class="s1">defaultdict_validator</span><span class="s3">, </span><span class="s1">default_default_factory</span><span class="s3">=</span><span class="s1">default_default_factory</span><span class="s3">),</span>
                <span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">coerce_instance_wrap </span><span class="s3">= </span><span class="s1">partial</span><span class="s3">(</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">no_info_after_validator_function</span><span class="s3">, </span><span class="s1">mapped_origin</span><span class="s3">)</span>

            <span class="s1">lax_schema </span><span class="s3">= </span><span class="s1">coerce_instance_wrap</span><span class="s3">(</span><span class="s1">dict_schema</span><span class="s3">)</span>
            <span class="s1">strict_schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">chain_schema</span><span class="s3">([</span><span class="s1">check_instance</span><span class="s3">, </span><span class="s1">lax_schema</span><span class="s3">])</span>

            <span class="s1">schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">lax_or_strict_schema</span><span class="s3">(</span>
                <span class="s1">lax_schema</span><span class="s3">=</span><span class="s1">lax_schema</span><span class="s3">,</span>
                <span class="s1">strict_schema</span><span class="s3">=</span><span class="s1">strict_schema</span><span class="s3">,</span>
                <span class="s1">serialization</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">wrap_serializer_function_ser_schema</span><span class="s3">(</span>
                    <span class="s2">lambda </span><span class="s1">v</span><span class="s3">, </span><span class="s1">h</span><span class="s3">: </span><span class="s1">h</span><span class="s3">(</span><span class="s1">v</span><span class="s3">), </span><span class="s1">schema</span><span class="s3">=</span><span class="s1">dict_schema</span><span class="s3">, </span><span class="s1">info_arg</span><span class="s3">=</span><span class="s2">False</span>
                <span class="s3">),</span>
            <span class="s3">)</span>

        <span class="s2">return </span><span class="s1">schema</span>

    <span class="s2">def </span><span class="s1">_fraction_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Support for [`fractions.Fraction`][fractions.Fraction].&quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s3">.</span><span class="s1">_validators </span><span class="s2">import </span><span class="s1">fraction_validator</span>

        <span class="s6"># TODO: note, this is a fairly common pattern, re lax / strict for attempted type coercion,</span>
        <span class="s6"># can we use a helper function to reduce boilerplate?</span>
        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">lax_or_strict_schema</span><span class="s3">(</span>
            <span class="s1">lax_schema</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">no_info_plain_validator_function</span><span class="s3">(</span><span class="s1">fraction_validator</span><span class="s3">),</span>
            <span class="s1">strict_schema</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">json_or_python_schema</span><span class="s3">(</span>
                <span class="s1">json_schema</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">no_info_plain_validator_function</span><span class="s3">(</span><span class="s1">fraction_validator</span><span class="s3">),</span>
                <span class="s1">python_schema</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">is_instance_schema</span><span class="s3">(</span><span class="s1">Fraction</span><span class="s3">),</span>
            <span class="s3">),</span>
            <span class="s6"># use str serialization to guarantee round trip behavior</span>
            <span class="s1">serialization</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">to_string_ser_schema</span><span class="s3">(</span><span class="s1">when_used</span><span class="s3">=</span><span class="s5">'always'</span><span class="s3">),</span>
            <span class="s1">metadata</span><span class="s3">={</span><span class="s5">'pydantic_js_functions'</span><span class="s3">: [</span><span class="s2">lambda </span><span class="s1">_1</span><span class="s3">, </span><span class="s1">_2</span><span class="s3">: {</span><span class="s5">'type'</span><span class="s3">: </span><span class="s5">'string'</span><span class="s3">, </span><span class="s5">'format'</span><span class="s3">: </span><span class="s5">'fraction'</span><span class="s3">}]},</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_arbitrary_type_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">type</span><span class="s3">):</span>
            <span class="s1">warn</span><span class="s3">(</span>
                <span class="s5">f'</span><span class="s2">{</span><span class="s1">tp</span><span class="s2">!r} </span><span class="s5">is not a Python type (it may be an instance of an object),'</span>
                <span class="s5">' Pydantic will allow any object with no validation since we cannot even'</span>
                <span class="s5">' enforce that the input is an instance of the given type.'</span>
                <span class="s5">' To get rid of this error wrap the type with `pydantic.SkipValidation`.'</span><span class="s3">,</span>
                <span class="s1">UserWarning</span><span class="s3">,</span>
            <span class="s3">)</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">any_schema</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">is_instance_schema</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_unknown_type_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">PydanticSchemaGenerationError</span><span class="s3">(</span>
            <span class="s5">f'Unable to generate pydantic-core schema for </span><span class="s2">{</span><span class="s1">obj</span><span class="s2">!r}</span><span class="s5">. '</span>
            <span class="s5">'Set `arbitrary_types_allowed=True` in the model_config to ignore this error'</span>
            <span class="s5">' or implement `__get_pydantic_core_schema__` on your type to fully support it.'</span>
            <span class="s5">'</span><span class="s2">\n\n</span><span class="s5">If you got this error by calling handler(&lt;some type&gt;) within'</span>
            <span class="s5">' `__get_pydantic_core_schema__` then you likely need to call'</span>
            <span class="s5">' `handler.generate_schema(&lt;some type&gt;)` since we do not call'</span>
            <span class="s5">' `__get_pydantic_core_schema__` on `&lt;some type&gt;` otherwise to avoid infinite recursion.'</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_apply_discriminator_to_union</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">, </span><span class="s1">discriminator</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s1">Discriminator </span><span class="s3">| </span><span class="s2">None</span>
    <span class="s3">) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">discriminator </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">schema</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">_discriminated_union</span><span class="s3">.</span><span class="s1">apply_discriminator</span><span class="s3">(</span>
                <span class="s1">schema</span><span class="s3">,</span>
                <span class="s1">discriminator</span><span class="s3">,</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">.</span><span class="s1">_definitions</span><span class="s3">,</span>
            <span class="s3">)</span>
        <span class="s2">except </span><span class="s1">_discriminated_union</span><span class="s3">.</span><span class="s1">MissingDefinitionForUnionRef</span><span class="s3">:</span>
            <span class="s6"># defer until defs are resolved</span>
            <span class="s1">_discriminated_union</span><span class="s3">.</span><span class="s1">set_discriminator_in_metadata</span><span class="s3">(</span>
                <span class="s1">schema</span><span class="s3">,</span>
                <span class="s1">discriminator</span><span class="s3">,</span>
            <span class="s3">)</span>
            <span class="s2">return </span><span class="s1">schema</span>

    <span class="s2">def </span><span class="s1">clean_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:</span>
        <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">.</span><span class="s1">finalize_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>
        <span class="s1">schema </span><span class="s3">= </span><span class="s1">validate_core_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">schema</span>

    <span class="s2">def </span><span class="s1">_add_js_function</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">metadata_schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">, </span><span class="s1">js_function</span><span class="s3">: </span><span class="s1">Callable</span><span class="s3">[..., </span><span class="s1">Any</span><span class="s3">]) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">metadata </span><span class="s3">= </span><span class="s1">metadata_schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'metadata'</span><span class="s3">, {})</span>
        <span class="s1">pydantic_js_functions </span><span class="s3">= </span><span class="s1">metadata</span><span class="s3">.</span><span class="s1">setdefault</span><span class="s3">(</span><span class="s5">'pydantic_js_functions'</span><span class="s3">, [])</span>
        <span class="s6"># because of how we generate core schemas for nested generic models</span>
        <span class="s6"># we can end up adding `BaseModel.__get_pydantic_json_schema__` multiple times</span>
        <span class="s6"># this check may fail to catch duplicates if the function is a `functools.partial`</span>
        <span class="s6"># or something like that, but if it does it'll fail by inserting the duplicate</span>
        <span class="s2">if </span><span class="s1">js_function </span><span class="s2">not in </span><span class="s1">pydantic_js_functions</span><span class="s3">:</span>
            <span class="s1">pydantic_js_functions</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">js_function</span><span class="s3">)</span>
        <span class="s1">metadata_schema</span><span class="s3">[</span><span class="s5">'metadata'</span><span class="s3">] = </span><span class="s1">metadata</span>

    <span class="s2">def </span><span class="s1">generate_schema</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">obj</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generate core schema. 
 
        Args: 
            obj: The object to generate core schema for. 
 
        Returns: 
            The generated core schema. 
 
        Raises: 
            PydanticUndefinedAnnotation: 
                If it is not possible to evaluate forward reference. 
            PydanticSchemaGenerationError: 
                If it is not possible to generate pydantic-core schema. 
            TypeError: 
                - If `alias_generator` returns a disallowed type (must be str, AliasPath or AliasChoices). 
                - If V1 style validator with `each_item=True` applied on a wrong field. 
            PydanticUserError: 
                - If `typing.TypedDict` is used instead of `typing_extensions.TypedDict` on Python &lt; 3.12. 
                - If `__modify_schema__` method is used instead of `__get_pydantic_json_schema__`. 
        &quot;&quot;&quot;</span>
        <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_schema_from_get_schema_method</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">schema </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_schema_inner</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>

        <span class="s1">metadata_js_function </span><span class="s3">= </span><span class="s1">_extract_get_pydantic_json_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">metadata_js_function </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">metadata_schema </span><span class="s3">= </span><span class="s1">resolve_original_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">metadata_schema</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_add_js_function</span><span class="s3">(</span><span class="s1">metadata_schema</span><span class="s3">, </span><span class="s1">metadata_js_function</span><span class="s3">)</span>

        <span class="s1">schema </span><span class="s3">= </span><span class="s1">_add_custom_serialization_from_json_encoders</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper</span><span class="s3">.</span><span class="s1">json_encoders</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">schema</span>

    <span class="s2">def </span><span class="s1">_model_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">BaseModel</span><span class="s3">]) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generate schema for a Pydantic model.&quot;&quot;&quot;</span>
        <span class="s1">BaseModel_ </span><span class="s3">= </span><span class="s1">import_cached_base_model</span><span class="s3">()</span>

        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">.</span><span class="s1">get_schema_or_ref</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">) </span><span class="s2">as </span><span class="s3">(</span><span class="s1">model_ref</span><span class="s3">, </span><span class="s1">maybe_schema</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">maybe_schema </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">maybe_schema</span>

            <span class="s1">schema </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'__pydantic_core_schema__'</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">schema </span><span class="s2">is not None and not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">MockCoreSchema</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">schema</span><span class="s3">[</span><span class="s5">'type'</span><span class="s3">] == </span><span class="s5">'definitions'</span><span class="s3">:</span>
                    <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">.</span><span class="s1">unpack_definitions</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>
                <span class="s1">ref </span><span class="s3">= </span><span class="s1">get_ref</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">ref</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">.</span><span class="s1">create_definition_reference_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s1">schema</span>

            <span class="s1">config_wrapper </span><span class="s3">= </span><span class="s1">ConfigWrapper</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">model_config</span><span class="s3">, </span><span class="s1">check</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper_stack</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">config_wrapper</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ns_resolver</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">):</span>
                <span class="s1">core_config </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper</span><span class="s3">.</span><span class="s1">core_config</span><span class="s3">(</span><span class="s1">title</span><span class="s3">=</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">)</span>

                <span class="s2">if </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__pydantic_fields_complete__ </span><span class="s2">or </span><span class="s1">cls </span><span class="s2">is </span><span class="s1">BaseModel_</span><span class="s3">:</span>
                    <span class="s1">fields </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s5">'__pydantic_fields__'</span><span class="s3">, {})</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">try</span><span class="s3">:</span>
                        <span class="s1">fields </span><span class="s3">= </span><span class="s1">rebuild_model_fields</span><span class="s3">(</span>
                            <span class="s1">cls</span><span class="s3">,</span>
                            <span class="s1">ns_resolver</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ns_resolver</span><span class="s3">,</span>
                            <span class="s1">typevars_map</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_typevars_map </span><span class="s2">or </span><span class="s3">{},</span>
                        <span class="s3">)</span>
                    <span class="s2">except </span><span class="s1">NameError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                        <span class="s2">raise </span><span class="s1">PydanticUndefinedAnnotation</span><span class="s3">.</span><span class="s1">from_name_error</span><span class="s3">(</span><span class="s1">e</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>

                <span class="s1">decorators </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__pydantic_decorators__</span>
                <span class="s1">computed_fields </span><span class="s3">= </span><span class="s1">decorators</span><span class="s3">.</span><span class="s1">computed_fields</span>
                <span class="s1">check_decorator_fields_exist</span><span class="s3">(</span>
                    <span class="s1">chain</span><span class="s3">(</span>
                        <span class="s1">decorators</span><span class="s3">.</span><span class="s1">field_validators</span><span class="s3">.</span><span class="s1">values</span><span class="s3">(),</span>
                        <span class="s1">decorators</span><span class="s3">.</span><span class="s1">field_serializers</span><span class="s3">.</span><span class="s1">values</span><span class="s3">(),</span>
                        <span class="s1">decorators</span><span class="s3">.</span><span class="s1">validators</span><span class="s3">.</span><span class="s1">values</span><span class="s3">(),</span>
                    <span class="s3">),</span>
                    <span class="s3">{*</span><span class="s1">fields</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(), *</span><span class="s1">computed_fields</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()},</span>
                <span class="s3">)</span>

                <span class="s1">model_validators </span><span class="s3">= </span><span class="s1">decorators</span><span class="s3">.</span><span class="s1">model_validators</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()</span>

                <span class="s1">extras_schema </span><span class="s3">= </span><span class="s2">None</span>
                <span class="s1">extras_keys_schema </span><span class="s3">= </span><span class="s2">None</span>
                <span class="s2">if </span><span class="s1">core_config</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'extra_fields_behavior'</span><span class="s3">) == </span><span class="s5">'allow'</span><span class="s3">:</span>
                    <span class="s2">assert </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__mro__</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] </span><span class="s2">is </span><span class="s1">cls</span>
                    <span class="s2">assert </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__mro__</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">] </span><span class="s2">is </span><span class="s1">object</span>
                    <span class="s2">for </span><span class="s1">candidate_cls </span><span class="s2">in </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__mro__</span><span class="s3">[:-</span><span class="s4">1</span><span class="s3">]:</span>
                        <span class="s1">extras_annotation </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">candidate_cls</span><span class="s3">, </span><span class="s5">'__annotations__'</span><span class="s3">, {}).</span><span class="s1">get</span><span class="s3">(</span>
                            <span class="s5">'__pydantic_extra__'</span><span class="s3">, </span><span class="s2">None</span>
                        <span class="s3">)</span>
                        <span class="s2">if </span><span class="s1">extras_annotation </span><span class="s2">is not None</span><span class="s3">:</span>
                            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">extras_annotation</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
                                <span class="s1">extras_annotation </span><span class="s3">= </span><span class="s1">_typing_extra</span><span class="s3">.</span><span class="s1">eval_type_backport</span><span class="s3">(</span>
                                    <span class="s1">_typing_extra</span><span class="s3">.</span><span class="s1">_make_forward_ref</span><span class="s3">(</span>
                                        <span class="s1">extras_annotation</span><span class="s3">, </span><span class="s1">is_argument</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">is_class</span><span class="s3">=</span><span class="s2">True</span>
                                    <span class="s3">),</span>
                                    <span class="s3">*</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_types_namespace</span><span class="s3">,</span>
                                <span class="s3">)</span>
                            <span class="s1">tp </span><span class="s3">= </span><span class="s1">get_origin</span><span class="s3">(</span><span class="s1">extras_annotation</span><span class="s3">)</span>
                            <span class="s2">if </span><span class="s1">tp </span><span class="s2">not in </span><span class="s1">DICT_TYPES</span><span class="s3">:</span>
                                <span class="s2">raise </span><span class="s1">PydanticSchemaGenerationError</span><span class="s3">(</span>
                                    <span class="s5">'The type annotation for `__pydantic_extra__` must be `dict[str, ...]`'</span>
                                <span class="s3">)</span>
                            <span class="s1">extra_keys_type</span><span class="s3">, </span><span class="s1">extra_items_type </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_args_resolving_forward_refs</span><span class="s3">(</span>
                                <span class="s1">extras_annotation</span><span class="s3">,</span>
                                <span class="s1">required</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                            <span class="s3">)</span>
                            <span class="s2">if </span><span class="s1">extra_keys_type </span><span class="s2">is not </span><span class="s1">str</span><span class="s3">:</span>
                                <span class="s1">extras_keys_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">extra_keys_type</span><span class="s3">)</span>
                            <span class="s2">if not </span><span class="s1">typing_objects</span><span class="s3">.</span><span class="s1">is_any</span><span class="s3">(</span><span class="s1">extra_items_type</span><span class="s3">):</span>
                                <span class="s1">extras_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">extra_items_type</span><span class="s3">)</span>
                            <span class="s2">if </span><span class="s1">extras_keys_schema </span><span class="s2">is not None or </span><span class="s1">extras_schema </span><span class="s2">is not None</span><span class="s3">:</span>
                                <span class="s2">break</span>

                <span class="s1">generic_origin</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">BaseModel</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s5">'__pydantic_generic_metadata__'</span><span class="s3">, {}).</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'origin'</span><span class="s3">)</span>

                <span class="s2">if </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__pydantic_root_model__</span><span class="s3">:</span>
                    <span class="s1">root_field </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_common_field_schema</span><span class="s3">(</span><span class="s5">'root'</span><span class="s3">, </span><span class="s1">fields</span><span class="s3">[</span><span class="s5">'root'</span><span class="s3">], </span><span class="s1">decorators</span><span class="s3">)</span>
                    <span class="s1">inner_schema </span><span class="s3">= </span><span class="s1">root_field</span><span class="s3">[</span><span class="s5">'schema'</span><span class="s3">]</span>
                    <span class="s1">inner_schema </span><span class="s3">= </span><span class="s1">apply_model_validators</span><span class="s3">(</span><span class="s1">inner_schema</span><span class="s3">, </span><span class="s1">model_validators</span><span class="s3">, </span><span class="s5">'inner'</span><span class="s3">)</span>
                    <span class="s1">model_schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">model_schema</span><span class="s3">(</span>
                        <span class="s1">cls</span><span class="s3">,</span>
                        <span class="s1">inner_schema</span><span class="s3">,</span>
                        <span class="s1">generic_origin</span><span class="s3">=</span><span class="s1">generic_origin</span><span class="s3">,</span>
                        <span class="s1">custom_init</span><span class="s3">=</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s5">'__pydantic_custom_init__'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">),</span>
                        <span class="s1">root_model</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                        <span class="s1">post_init</span><span class="s3">=</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s5">'__pydantic_post_init__'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">),</span>
                        <span class="s1">config</span><span class="s3">=</span><span class="s1">core_config</span><span class="s3">,</span>
                        <span class="s1">ref</span><span class="s3">=</span><span class="s1">model_ref</span><span class="s3">,</span>
                    <span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">fields_schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">model_fields_schema</span><span class="s3">(</span>
                        <span class="s3">{</span><span class="s1">k</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_md_field_schema</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">decorators</span><span class="s3">) </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">fields</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()},</span>
                        <span class="s1">computed_fields</span><span class="s3">=[</span>
                            <span class="s1">self</span><span class="s3">.</span><span class="s1">_computed_field_schema</span><span class="s3">(</span><span class="s1">d</span><span class="s3">, </span><span class="s1">decorators</span><span class="s3">.</span><span class="s1">field_serializers</span><span class="s3">)</span>
                            <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">computed_fields</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()</span>
                        <span class="s3">],</span>
                        <span class="s1">extras_schema</span><span class="s3">=</span><span class="s1">extras_schema</span><span class="s3">,</span>
                        <span class="s1">extras_keys_schema</span><span class="s3">=</span><span class="s1">extras_keys_schema</span><span class="s3">,</span>
                        <span class="s1">model_name</span><span class="s3">=</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">,</span>
                    <span class="s3">)</span>
                    <span class="s1">inner_schema </span><span class="s3">= </span><span class="s1">apply_validators</span><span class="s3">(</span><span class="s1">fields_schema</span><span class="s3">, </span><span class="s1">decorators</span><span class="s3">.</span><span class="s1">root_validators</span><span class="s3">.</span><span class="s1">values</span><span class="s3">(), </span><span class="s2">None</span><span class="s3">)</span>
                    <span class="s1">inner_schema </span><span class="s3">= </span><span class="s1">apply_model_validators</span><span class="s3">(</span><span class="s1">inner_schema</span><span class="s3">, </span><span class="s1">model_validators</span><span class="s3">, </span><span class="s5">'inner'</span><span class="s3">)</span>

                    <span class="s1">model_schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">model_schema</span><span class="s3">(</span>
                        <span class="s1">cls</span><span class="s3">,</span>
                        <span class="s1">inner_schema</span><span class="s3">,</span>
                        <span class="s1">generic_origin</span><span class="s3">=</span><span class="s1">generic_origin</span><span class="s3">,</span>
                        <span class="s1">custom_init</span><span class="s3">=</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s5">'__pydantic_custom_init__'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">),</span>
                        <span class="s1">root_model</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                        <span class="s1">post_init</span><span class="s3">=</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s5">'__pydantic_post_init__'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">),</span>
                        <span class="s1">config</span><span class="s3">=</span><span class="s1">core_config</span><span class="s3">,</span>
                        <span class="s1">ref</span><span class="s3">=</span><span class="s1">model_ref</span><span class="s3">,</span>
                    <span class="s3">)</span>

                <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_apply_model_serializers</span><span class="s3">(</span><span class="s1">model_schema</span><span class="s3">, </span><span class="s1">decorators</span><span class="s3">.</span><span class="s1">model_serializers</span><span class="s3">.</span><span class="s1">values</span><span class="s3">())</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">apply_model_validators</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">model_validators</span><span class="s3">, </span><span class="s5">'outer'</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">.</span><span class="s1">create_definition_reference_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_resolve_self_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s1">obj </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">model_type_stack</span><span class="s3">.</span><span class="s1">get</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">obj </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">PydanticUserError</span><span class="s3">(</span><span class="s5">'`typing.Self` is invalid in this context'</span><span class="s3">, </span><span class="s1">code</span><span class="s3">=</span><span class="s5">'invalid-self-type'</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">obj</span>

    <span class="s2">def </span><span class="s1">_generate_schema_from_get_schema_method</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">source</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">BaseModel_ </span><span class="s3">= </span><span class="s1">import_cached_base_model</span><span class="s3">()</span>

        <span class="s1">get_schema </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s5">'__get_pydantic_core_schema__'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s1">is_base_model_get_schema </span><span class="s3">= (</span>
            <span class="s1">getattr</span><span class="s3">(</span><span class="s1">get_schema</span><span class="s3">, </span><span class="s5">'__func__'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) </span><span class="s2">is </span><span class="s1">BaseModel_</span><span class="s3">.</span><span class="s1">__get_pydantic_core_schema__</span><span class="s3">.</span><span class="s1">__func__  </span><span class="s6"># pyright: ignore[reportFunctionMemberAccess]</span>
        <span class="s3">)</span>

        <span class="s2">if </span><span class="s3">(</span>
            <span class="s1">get_schema </span><span class="s2">is not None</span>
            <span class="s6"># BaseModel.__get_pydantic_core_schema__ is defined for backwards compatibility,</span>
            <span class="s6"># to allow existing code to call `super().__get_pydantic_core_schema__` in Pydantic</span>
            <span class="s6"># model that overrides `__get_pydantic_core_schema__`. However, it raises a deprecation</span>
            <span class="s6"># warning stating that the method will be removed, and during the core schema gen we actually</span>
            <span class="s6"># don't call the method:</span>
            <span class="s2">and not </span><span class="s1">is_base_model_get_schema</span>
        <span class="s3">):</span>
            <span class="s6"># Some referenceable types might have a `__get_pydantic_core_schema__` method</span>
            <span class="s6"># defined on it by users (e.g. on a dataclass). This generally doesn't play well</span>
            <span class="s6"># as these types are already recognized by the `GenerateSchema` class and isn't ideal</span>
            <span class="s6"># as we might end up calling `get_schema_or_ref` (expensive) on types that are actually</span>
            <span class="s6"># not referenceable:</span>
            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">.</span><span class="s1">get_schema_or_ref</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) </span><span class="s2">as </span><span class="s3">(</span><span class="s1">_</span><span class="s3">, </span><span class="s1">maybe_schema</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">maybe_schema </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s1">maybe_schema</span>

            <span class="s2">if </span><span class="s1">obj </span><span class="s2">is </span><span class="s1">source</span><span class="s3">:</span>
                <span class="s1">ref_mode </span><span class="s3">= </span><span class="s5">'unpack'</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">ref_mode </span><span class="s3">= </span><span class="s5">'to-def'</span>
            <span class="s1">schema </span><span class="s3">= </span><span class="s1">get_schema</span><span class="s3">(</span>
                <span class="s1">source</span><span class="s3">, </span><span class="s1">CallbackGetCoreSchemaHandler</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_schema_inner</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">ref_mode</span><span class="s3">=</span><span class="s1">ref_mode</span><span class="s3">)</span>
            <span class="s3">)</span>
            <span class="s2">if </span><span class="s1">schema</span><span class="s3">[</span><span class="s5">'type'</span><span class="s3">] == </span><span class="s5">'definitions'</span><span class="s3">:</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">.</span><span class="s1">unpack_definitions</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>

            <span class="s1">ref </span><span class="s3">= </span><span class="s1">get_ref</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">ref</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">.</span><span class="s1">create_definition_reference_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>

            <span class="s6"># Note: if schema is of type `'definition-ref'`, we might want to copy it as a</span>
            <span class="s6"># safety measure (because these are inlined in place -- i.e. mutated directly)</span>
            <span class="s2">return </span><span class="s1">schema</span>

        <span class="s2">if </span><span class="s1">get_schema </span><span class="s2">is None and </span><span class="s3">(</span><span class="s1">validators </span><span class="s3">:= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s5">'__get_validators__'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)) </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">from </span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">v1 </span><span class="s2">import </span><span class="s1">BaseModel </span><span class="s2">as </span><span class="s1">BaseModelV1</span>

            <span class="s2">if </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">BaseModelV1</span><span class="s3">):</span>
                <span class="s1">warn</span><span class="s3">(</span>
                    <span class="s5">f'Mixing V1 models and V2 models (or constructs, like `TypeAdapter`) is not supported. Please upgrade `</span><span class="s2">{</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">}</span><span class="s5">` to V2.'</span><span class="s3">,</span>
                    <span class="s1">UserWarning</span><span class="s3">,</span>
                <span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">warn</span><span class="s3">(</span>
                    <span class="s5">'`__get_validators__` is deprecated and will be removed, use `__get_pydantic_core_schema__` instead.'</span><span class="s3">,</span>
                    <span class="s1">PydanticDeprecatedSince20</span><span class="s3">,</span>
                <span class="s3">)</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">chain_schema</span><span class="s3">([</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">with_info_plain_validator_function</span><span class="s3">(</span><span class="s1">v</span><span class="s3">) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">validators</span><span class="s3">()])</span>

    <span class="s2">def </span><span class="s1">_resolve_forward_ref</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s6"># we assume that types_namespace has the target of forward references in its scope,</span>
        <span class="s6"># but this could fail, for example, if calling Validator on an imported type which contains</span>
        <span class="s6"># forward references to other types only defined in the module from which it was imported</span>
        <span class="s6"># `Validator(SomeImportedTypeAliasWithAForwardReference)`</span>
        <span class="s6"># or the equivalent for BaseModel</span>
        <span class="s6"># class Model(BaseModel):</span>
        <span class="s6">#   x: SomeImportedTypeAliasWithAForwardReference</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">obj </span><span class="s3">= </span><span class="s1">_typing_extra</span><span class="s3">.</span><span class="s1">eval_type_backport</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, *</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_types_namespace</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">NameError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">PydanticUndefinedAnnotation</span><span class="s3">.</span><span class="s1">from_name_error</span><span class="s3">(</span><span class="s1">e</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>

        <span class="s6"># if obj is still a ForwardRef, it means we can't evaluate it, raise PydanticUndefinedAnnotation</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">ForwardRef</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">PydanticUndefinedAnnotation</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">__forward_arg__</span><span class="s3">, </span><span class="s5">f'Unable to evaluate forward reference </span><span class="s2">{</span><span class="s1">obj</span><span class="s2">}</span><span class="s5">'</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_typevars_map</span><span class="s3">:</span>
            <span class="s1">obj </span><span class="s3">= </span><span class="s1">replace_types</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_typevars_map</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">obj</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">_get_args_resolving_forward_refs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">required</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">True</span><span class="s3">]) </span><span class="s1">-&gt; tuple</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, ...]: ...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">_get_args_resolving_forward_refs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; tuple</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, ...] | </span><span class="s2">None</span><span class="s3">: ...</span>

    <span class="s2">def </span><span class="s1">_get_args_resolving_forward_refs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">required</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">) </span><span class="s1">-&gt; tuple</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, ...] | </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">args </span><span class="s3">= </span><span class="s1">get_args</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">args</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">GenericAlias</span><span class="s3">):</span>
                <span class="s6"># PEP 585 generic aliases don't convert args to ForwardRefs, unlike `typing.List/Dict` etc.</span>
                <span class="s1">args </span><span class="s3">= (</span><span class="s1">_typing_extra</span><span class="s3">.</span><span class="s1">_make_forward_ref</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) </span><span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">str</span><span class="s3">) </span><span class="s2">else </span><span class="s1">a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">args</span><span class="s3">)</span>
            <span class="s1">args </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_resolve_forward_ref</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) </span><span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">ForwardRef</span><span class="s3">) </span><span class="s2">else </span><span class="s1">a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">args</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">required</span><span class="s3">:  </span><span class="s6"># pragma: no cover</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s5">f'Expected </span><span class="s2">{</span><span class="s1">obj</span><span class="s2">} </span><span class="s5">to have generic parameters but it had none'</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">args</span>

    <span class="s2">def </span><span class="s1">_get_first_arg_or_any</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s1">args </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_args_resolving_forward_refs</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">args</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">Any</span>
        <span class="s2">return </span><span class="s1">args</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">_get_first_two_args_or_any</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; tuple</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]:</span>
        <span class="s1">args </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_args_resolving_forward_refs</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">args</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s3">(</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">args</span><span class="s3">) &lt; </span><span class="s4">2</span><span class="s3">:</span>
            <span class="s1">origin </span><span class="s3">= </span><span class="s1">get_origin</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s5">f'Expected two type arguments for </span><span class="s2">{</span><span class="s1">origin</span><span class="s2">}</span><span class="s5">, got 1'</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">args</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">args</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">_generate_schema_inner</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">typing_objects</span><span class="s3">.</span><span class="s1">is_self</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">):</span>
            <span class="s1">obj </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_resolve_self_type</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">typing_objects</span><span class="s3">.</span><span class="s1">is_annotated</span><span class="s3">(</span><span class="s1">get_origin</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_annotated_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">):</span>
            <span class="s6"># we assume this is already a valid schema</span>
            <span class="s2">return </span><span class="s1">obj  </span><span class="s6"># type: ignore[return-value]</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
            <span class="s1">obj </span><span class="s3">= </span><span class="s1">ForwardRef</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">ForwardRef</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_resolve_forward_ref</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">))</span>

        <span class="s1">BaseModel </span><span class="s3">= </span><span class="s1">import_cached_base_model</span><span class="s3">()</span>

        <span class="s2">if </span><span class="s1">lenient_issubclass</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">BaseModel</span><span class="s3">):</span>
            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">model_type_stack</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_model_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">PydanticRecursiveRef</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">definition_reference_schema</span><span class="s3">(</span><span class="s1">schema_ref</span><span class="s3">=</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">type_ref</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">match_type</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">match_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:  </span><span class="s6"># noqa: C901</span>
        <span class="s0">&quot;&quot;&quot;Main mapping of types to schemas. 
 
        The general structure is a series of if statements starting with the simple cases 
        (non-generic primitive types) and then handling generics and other more complex cases. 
 
        Each case either generates a schema directly, calls into a public user-overridable method 
        (like `GenerateSchema.tuple_variable_schema`) or calls into a private method that handles some 
        boilerplate before calling into the user-facing method (e.g. `GenerateSchema._tuple_schema`). 
 
        The idea is that we'll evolve this into adding more and more user facing methods over time 
        as they get requested and we figure out what the right API for them is. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">obj </span><span class="s2">is </span><span class="s1">str</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">str_schema</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">is </span><span class="s1">bytes</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">bytes_schema</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">is </span><span class="s1">int</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">int_schema</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">is </span><span class="s1">float</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">float_schema</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">is </span><span class="s1">bool</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">bool_schema</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">is </span><span class="s1">complex</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">complex_schema</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">typing_objects</span><span class="s3">.</span><span class="s1">is_any</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) </span><span class="s2">or </span><span class="s1">obj </span><span class="s2">is </span><span class="s1">object</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">any_schema</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">is </span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">date</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">date_schema</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">is </span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">datetime</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">datetime_schema</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">is </span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">time</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">time_schema</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">is </span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">timedelta</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">timedelta_schema</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">is </span><span class="s1">Decimal</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">decimal_schema</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">is </span><span class="s1">UUID</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">uuid_schema</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">is </span><span class="s1">Url</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">url_schema</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">is </span><span class="s1">Fraction</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fraction_schema</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">is </span><span class="s1">MultiHostUrl</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">multi_host_url_schema</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">is None or </span><span class="s1">obj </span><span class="s2">is </span><span class="s1">_typing_extra</span><span class="s3">.</span><span class="s1">NoneType</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">none_schema</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">IP_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ip_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">TUPLE_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_tuple_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">LIST_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_list_schema</span><span class="s3">(</span><span class="s1">Any</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">SET_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_set_schema</span><span class="s3">(</span><span class="s1">Any</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">FROZEN_SET_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_frozenset_schema</span><span class="s3">(</span><span class="s1">Any</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">SEQUENCE_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_sequence_schema</span><span class="s3">(</span><span class="s1">Any</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">ITERABLE_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_iterable_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">DICT_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_dict_schema</span><span class="s3">(</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">PATH_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_path_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">DEQUE_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_deque_schema</span><span class="s3">(</span><span class="s1">Any</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">MAPPING_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mapping_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">COUNTER_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mapping_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">int</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">typing_objects</span><span class="s3">.</span><span class="s1">is_typealiastype</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type_alias_type_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">is </span><span class="s1">type</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type_schema</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">_typing_extra</span><span class="s3">.</span><span class="s1">is_callable</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">callable_schema</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">typing_objects</span><span class="s3">.</span><span class="s1">is_literal</span><span class="s3">(</span><span class="s1">get_origin</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_literal_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">is_typeddict</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_typed_dict_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">_typing_extra</span><span class="s3">.</span><span class="s1">is_namedtuple</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_namedtuple_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">typing_objects</span><span class="s3">.</span><span class="s1">is_newtype</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">):</span>
            <span class="s6"># NewType, can't use isinstance because it fails &lt;3.10</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">__supertype__</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">PATTERN_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_pattern_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">_typing_extra</span><span class="s3">.</span><span class="s1">is_hashable</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_hashable_schema</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">TypeVar</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_unsubstituted_typevar_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">_typing_extra</span><span class="s3">.</span><span class="s1">is_finalvar</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">obj </span><span class="s2">is </span><span class="s1">Final</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">any_schema</span><span class="s3">()</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_get_first_arg_or_any</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">),</span>
            <span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">VALIDATE_CALL_SUPPORTED_TYPES</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_call_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">isclass</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) </span><span class="s2">and </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">Enum</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_enum_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">obj </span><span class="s2">is </span><span class="s1">ZoneInfo</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_zoneinfo_schema</span><span class="s3">()</span>

        <span class="s6"># dataclasses.is_dataclass coerces dc instances to types, but we only handle</span>
        <span class="s6"># the case of a dc type here</span>
        <span class="s2">if </span><span class="s1">dataclasses</span><span class="s3">.</span><span class="s1">is_dataclass</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_dataclass_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)  </span><span class="s6"># pyright: ignore[reportArgumentType]</span>

        <span class="s1">origin </span><span class="s3">= </span><span class="s1">get_origin</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">origin </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_match_generic_type</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_arbitrary_types</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_arbitrary_type_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_unknown_type_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_match_generic_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:  </span><span class="s6"># noqa: C901</span>
        <span class="s6"># Need to handle generic dataclasses before looking for the schema properties because attribute accesses</span>
        <span class="s6"># on _GenericAlias delegate to the origin type, so lose the information about the concrete parametrization</span>
        <span class="s6"># As a result, currently, there is no way to cache the schema for generic dataclasses. This may be possible</span>
        <span class="s6"># to resolve by modifying the value returned by `Generic.__class_getitem__`, but that is a dangerous game.</span>
        <span class="s2">if </span><span class="s1">dataclasses</span><span class="s3">.</span><span class="s1">is_dataclass</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_dataclass_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">)  </span><span class="s6"># pyright: ignore[reportArgumentType]</span>
        <span class="s2">if </span><span class="s1">_typing_extra</span><span class="s3">.</span><span class="s1">is_namedtuple</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_namedtuple_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">)</span>

        <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_schema_from_get_schema_method</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">schema </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">schema</span>

        <span class="s2">if </span><span class="s1">typing_objects</span><span class="s3">.</span><span class="s1">is_typealiastype</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type_alias_type_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">is_union_origin</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_union_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">origin </span><span class="s2">in </span><span class="s1">TUPLE_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_tuple_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">origin </span><span class="s2">in </span><span class="s1">LIST_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_list_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_first_arg_or_any</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">origin </span><span class="s2">in </span><span class="s1">SET_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_set_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_first_arg_or_any</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">origin </span><span class="s2">in </span><span class="s1">FROZEN_SET_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_frozenset_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_first_arg_or_any</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">origin </span><span class="s2">in </span><span class="s1">DICT_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_dict_schema</span><span class="s3">(*</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_first_two_args_or_any</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">origin </span><span class="s2">in </span><span class="s1">PATH_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_path_schema</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_first_arg_or_any</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">origin </span><span class="s2">in </span><span class="s1">DEQUE_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_deque_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_first_arg_or_any</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">origin </span><span class="s2">in </span><span class="s1">MAPPING_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mapping_schema</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">, *</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_first_two_args_or_any</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">origin </span><span class="s2">in </span><span class="s1">COUNTER_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mapping_schema</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_first_arg_or_any</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">), </span><span class="s1">int</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">is_typeddict</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_typed_dict_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">origin </span><span class="s2">in </span><span class="s1">TYPE_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_subclass_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">origin </span><span class="s2">in </span><span class="s1">SEQUENCE_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_sequence_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_first_arg_or_any</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">origin </span><span class="s2">in </span><span class="s1">ITERABLE_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_iterable_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">origin </span><span class="s2">in </span><span class="s1">PATTERN_TYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_pattern_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_arbitrary_types</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_arbitrary_type_schema</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_unknown_type_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_generate_td_field_schema</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
        <span class="s1">field_info</span><span class="s3">: </span><span class="s1">FieldInfo</span><span class="s3">,</span>
        <span class="s1">decorators</span><span class="s3">: </span><span class="s1">DecoratorInfos</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">required</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">TypedDictField</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Prepare a TypedDictField to represent a model or typeddict field.&quot;&quot;&quot;</span>
        <span class="s1">common_field </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_common_field_schema</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">field_info</span><span class="s3">, </span><span class="s1">decorators</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">typed_dict_field</span><span class="s3">(</span>
            <span class="s1">common_field</span><span class="s3">[</span><span class="s5">'schema'</span><span class="s3">],</span>
            <span class="s1">required</span><span class="s3">=</span><span class="s2">False if not </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">is_required</span><span class="s3">() </span><span class="s2">else </span><span class="s1">required</span><span class="s3">,</span>
            <span class="s1">serialization_exclude</span><span class="s3">=</span><span class="s1">common_field</span><span class="s3">[</span><span class="s5">'serialization_exclude'</span><span class="s3">],</span>
            <span class="s1">validation_alias</span><span class="s3">=</span><span class="s1">common_field</span><span class="s3">[</span><span class="s5">'validation_alias'</span><span class="s3">],</span>
            <span class="s1">serialization_alias</span><span class="s3">=</span><span class="s1">common_field</span><span class="s3">[</span><span class="s5">'serialization_alias'</span><span class="s3">],</span>
            <span class="s1">metadata</span><span class="s3">=</span><span class="s1">common_field</span><span class="s3">[</span><span class="s5">'metadata'</span><span class="s3">],</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_generate_md_field_schema</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
        <span class="s1">field_info</span><span class="s3">: </span><span class="s1">FieldInfo</span><span class="s3">,</span>
        <span class="s1">decorators</span><span class="s3">: </span><span class="s1">DecoratorInfos</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">ModelField</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Prepare a ModelField to represent a model field.&quot;&quot;&quot;</span>
        <span class="s1">common_field </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_common_field_schema</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">field_info</span><span class="s3">, </span><span class="s1">decorators</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">model_field</span><span class="s3">(</span>
            <span class="s1">common_field</span><span class="s3">[</span><span class="s5">'schema'</span><span class="s3">],</span>
            <span class="s1">serialization_exclude</span><span class="s3">=</span><span class="s1">common_field</span><span class="s3">[</span><span class="s5">'serialization_exclude'</span><span class="s3">],</span>
            <span class="s1">validation_alias</span><span class="s3">=</span><span class="s1">common_field</span><span class="s3">[</span><span class="s5">'validation_alias'</span><span class="s3">],</span>
            <span class="s1">serialization_alias</span><span class="s3">=</span><span class="s1">common_field</span><span class="s3">[</span><span class="s5">'serialization_alias'</span><span class="s3">],</span>
            <span class="s1">frozen</span><span class="s3">=</span><span class="s1">common_field</span><span class="s3">[</span><span class="s5">'frozen'</span><span class="s3">],</span>
            <span class="s1">metadata</span><span class="s3">=</span><span class="s1">common_field</span><span class="s3">[</span><span class="s5">'metadata'</span><span class="s3">],</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_generate_dc_field_schema</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
        <span class="s1">field_info</span><span class="s3">: </span><span class="s1">FieldInfo</span><span class="s3">,</span>
        <span class="s1">decorators</span><span class="s3">: </span><span class="s1">DecoratorInfos</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">DataclassField</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Prepare a DataclassField to represent the parameter/field, of a dataclass.&quot;&quot;&quot;</span>
        <span class="s1">common_field </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_common_field_schema</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">field_info</span><span class="s3">, </span><span class="s1">decorators</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">dataclass_field</span><span class="s3">(</span>
            <span class="s1">name</span><span class="s3">,</span>
            <span class="s1">common_field</span><span class="s3">[</span><span class="s5">'schema'</span><span class="s3">],</span>
            <span class="s1">init</span><span class="s3">=</span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">init</span><span class="s3">,</span>
            <span class="s1">init_only</span><span class="s3">=</span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">init_var </span><span class="s2">or None</span><span class="s3">,</span>
            <span class="s1">kw_only</span><span class="s3">=</span><span class="s2">None if </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">kw_only </span><span class="s2">else False</span><span class="s3">,</span>
            <span class="s1">serialization_exclude</span><span class="s3">=</span><span class="s1">common_field</span><span class="s3">[</span><span class="s5">'serialization_exclude'</span><span class="s3">],</span>
            <span class="s1">validation_alias</span><span class="s3">=</span><span class="s1">common_field</span><span class="s3">[</span><span class="s5">'validation_alias'</span><span class="s3">],</span>
            <span class="s1">serialization_alias</span><span class="s3">=</span><span class="s1">common_field</span><span class="s3">[</span><span class="s5">'serialization_alias'</span><span class="s3">],</span>
            <span class="s1">frozen</span><span class="s3">=</span><span class="s1">common_field</span><span class="s3">[</span><span class="s5">'frozen'</span><span class="s3">],</span>
            <span class="s1">metadata</span><span class="s3">=</span><span class="s1">common_field</span><span class="s3">[</span><span class="s5">'metadata'</span><span class="s3">],</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">staticmethod</span>
    <span class="s2">def </span><span class="s1">_apply_alias_generator_to_field_info</span><span class="s3">(</span>
        <span class="s1">alias_generator</span><span class="s3">: </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">str</span><span class="s3">], </span><span class="s1">str</span><span class="s3">] | </span><span class="s1">AliasGenerator</span><span class="s3">, </span><span class="s1">field_info</span><span class="s3">: </span><span class="s1">FieldInfo</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Apply an alias_generator to aliases on a FieldInfo instance if appropriate. 
 
        Args: 
            alias_generator: A callable that takes a string and returns a string, or an AliasGenerator instance. 
            field_info: The FieldInfo instance to which the alias_generator is (maybe) applied. 
            field_name: The name of the field from which to generate the alias. 
        &quot;&quot;&quot;</span>
        <span class="s6"># Apply an alias_generator if</span>
        <span class="s6"># 1. An alias is not specified</span>
        <span class="s6"># 2. An alias is specified, but the priority is &lt;= 1</span>
        <span class="s2">if </span><span class="s3">(</span>
            <span class="s1">field_info</span><span class="s3">.</span><span class="s1">alias_priority </span><span class="s2">is None</span>
            <span class="s2">or </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">alias_priority </span><span class="s3">&lt;= </span><span class="s4">1</span>
            <span class="s2">or </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">alias </span><span class="s2">is None</span>
            <span class="s2">or </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">validation_alias </span><span class="s2">is None</span>
            <span class="s2">or </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">serialization_alias </span><span class="s2">is None</span>
        <span class="s3">):</span>
            <span class="s1">alias</span><span class="s3">, </span><span class="s1">validation_alias</span><span class="s3">, </span><span class="s1">serialization_alias </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span>

            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">alias_generator</span><span class="s3">, </span><span class="s1">AliasGenerator</span><span class="s3">):</span>
                <span class="s1">alias</span><span class="s3">, </span><span class="s1">validation_alias</span><span class="s3">, </span><span class="s1">serialization_alias </span><span class="s3">= </span><span class="s1">alias_generator</span><span class="s3">.</span><span class="s1">generate_aliases</span><span class="s3">(</span><span class="s1">field_name</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">alias_generator</span><span class="s3">, </span><span class="s1">Callable</span><span class="s3">):</span>
                <span class="s1">alias </span><span class="s3">= </span><span class="s1">alias_generator</span><span class="s3">(</span><span class="s1">field_name</span><span class="s3">)</span>
                <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">alias</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
                    <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s5">f'alias_generator </span><span class="s2">{</span><span class="s1">alias_generator</span><span class="s2">} </span><span class="s5">must return str, not </span><span class="s2">{</span><span class="s1">alias</span><span class="s3">.</span><span class="s1">__class__</span><span class="s2">}</span><span class="s5">'</span><span class="s3">)</span>

            <span class="s6"># if priority is not set, we set to 1</span>
            <span class="s6"># which supports the case where the alias_generator from a child class is used</span>
            <span class="s6"># to generate an alias for a field in a parent class</span>
            <span class="s2">if </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">alias_priority </span><span class="s2">is None or </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">alias_priority </span><span class="s3">&lt;= </span><span class="s4">1</span><span class="s3">:</span>
                <span class="s1">field_info</span><span class="s3">.</span><span class="s1">alias_priority </span><span class="s3">= </span><span class="s4">1</span>

            <span class="s6"># if the priority is 1, then we set the aliases to the generated alias</span>
            <span class="s2">if </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">alias_priority </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
                <span class="s1">field_info</span><span class="s3">.</span><span class="s1">serialization_alias </span><span class="s3">= </span><span class="s1">_get_first_non_null</span><span class="s3">(</span><span class="s1">serialization_alias</span><span class="s3">, </span><span class="s1">alias</span><span class="s3">)</span>
                <span class="s1">field_info</span><span class="s3">.</span><span class="s1">validation_alias </span><span class="s3">= </span><span class="s1">_get_first_non_null</span><span class="s3">(</span><span class="s1">validation_alias</span><span class="s3">, </span><span class="s1">alias</span><span class="s3">)</span>
                <span class="s1">field_info</span><span class="s3">.</span><span class="s1">alias </span><span class="s3">= </span><span class="s1">alias</span>

            <span class="s6"># if any of the aliases are not set, then we set them to the corresponding generated alias</span>
            <span class="s2">if </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">alias </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">field_info</span><span class="s3">.</span><span class="s1">alias </span><span class="s3">= </span><span class="s1">alias</span>
            <span class="s2">if </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">serialization_alias </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">field_info</span><span class="s3">.</span><span class="s1">serialization_alias </span><span class="s3">= </span><span class="s1">_get_first_non_null</span><span class="s3">(</span><span class="s1">serialization_alias</span><span class="s3">, </span><span class="s1">alias</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">validation_alias </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">field_info</span><span class="s3">.</span><span class="s1">validation_alias </span><span class="s3">= </span><span class="s1">_get_first_non_null</span><span class="s3">(</span><span class="s1">validation_alias</span><span class="s3">, </span><span class="s1">alias</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">staticmethod</span>
    <span class="s2">def </span><span class="s1">_apply_alias_generator_to_computed_field_info</span><span class="s3">(</span>
        <span class="s1">alias_generator</span><span class="s3">: </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">str</span><span class="s3">], </span><span class="s1">str</span><span class="s3">] | </span><span class="s1">AliasGenerator</span><span class="s3">,</span>
        <span class="s1">computed_field_info</span><span class="s3">: </span><span class="s1">ComputedFieldInfo</span><span class="s3">,</span>
        <span class="s1">computed_field_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Apply an alias_generator to alias on a ComputedFieldInfo instance if appropriate. 
 
        Args: 
            alias_generator: A callable that takes a string and returns a string, or an AliasGenerator instance. 
            computed_field_info: The ComputedFieldInfo instance to which the alias_generator is (maybe) applied. 
            computed_field_name: The name of the computed field from which to generate the alias. 
        &quot;&quot;&quot;</span>
        <span class="s6"># Apply an alias_generator if</span>
        <span class="s6"># 1. An alias is not specified</span>
        <span class="s6"># 2. An alias is specified, but the priority is &lt;= 1</span>

        <span class="s2">if </span><span class="s3">(</span>
            <span class="s1">computed_field_info</span><span class="s3">.</span><span class="s1">alias_priority </span><span class="s2">is None</span>
            <span class="s2">or </span><span class="s1">computed_field_info</span><span class="s3">.</span><span class="s1">alias_priority </span><span class="s3">&lt;= </span><span class="s4">1</span>
            <span class="s2">or </span><span class="s1">computed_field_info</span><span class="s3">.</span><span class="s1">alias </span><span class="s2">is None</span>
        <span class="s3">):</span>
            <span class="s1">alias</span><span class="s3">, </span><span class="s1">validation_alias</span><span class="s3">, </span><span class="s1">serialization_alias </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span>

            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">alias_generator</span><span class="s3">, </span><span class="s1">AliasGenerator</span><span class="s3">):</span>
                <span class="s1">alias</span><span class="s3">, </span><span class="s1">validation_alias</span><span class="s3">, </span><span class="s1">serialization_alias </span><span class="s3">= </span><span class="s1">alias_generator</span><span class="s3">.</span><span class="s1">generate_aliases</span><span class="s3">(</span><span class="s1">computed_field_name</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">alias_generator</span><span class="s3">, </span><span class="s1">Callable</span><span class="s3">):</span>
                <span class="s1">alias </span><span class="s3">= </span><span class="s1">alias_generator</span><span class="s3">(</span><span class="s1">computed_field_name</span><span class="s3">)</span>
                <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">alias</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
                    <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s5">f'alias_generator </span><span class="s2">{</span><span class="s1">alias_generator</span><span class="s2">} </span><span class="s5">must return str, not </span><span class="s2">{</span><span class="s1">alias</span><span class="s3">.</span><span class="s1">__class__</span><span class="s2">}</span><span class="s5">'</span><span class="s3">)</span>

            <span class="s6"># if priority is not set, we set to 1</span>
            <span class="s6"># which supports the case where the alias_generator from a child class is used</span>
            <span class="s6"># to generate an alias for a field in a parent class</span>
            <span class="s2">if </span><span class="s1">computed_field_info</span><span class="s3">.</span><span class="s1">alias_priority </span><span class="s2">is None or </span><span class="s1">computed_field_info</span><span class="s3">.</span><span class="s1">alias_priority </span><span class="s3">&lt;= </span><span class="s4">1</span><span class="s3">:</span>
                <span class="s1">computed_field_info</span><span class="s3">.</span><span class="s1">alias_priority </span><span class="s3">= </span><span class="s4">1</span>

            <span class="s6"># if the priority is 1, then we set the aliases to the generated alias</span>
            <span class="s6"># note that we use the serialization_alias with priority over alias, as computed_field</span>
            <span class="s6"># aliases are used for serialization only (not validation)</span>
            <span class="s2">if </span><span class="s1">computed_field_info</span><span class="s3">.</span><span class="s1">alias_priority </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
                <span class="s1">computed_field_info</span><span class="s3">.</span><span class="s1">alias </span><span class="s3">= </span><span class="s1">_get_first_non_null</span><span class="s3">(</span><span class="s1">serialization_alias</span><span class="s3">, </span><span class="s1">alias</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">staticmethod</span>
    <span class="s2">def </span><span class="s1">_apply_field_title_generator_to_field_info</span><span class="s3">(</span>
        <span class="s1">config_wrapper</span><span class="s3">: </span><span class="s1">ConfigWrapper</span><span class="s3">, </span><span class="s1">field_info</span><span class="s3">: </span><span class="s1">FieldInfo </span><span class="s3">| </span><span class="s1">ComputedFieldInfo</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">: </span><span class="s1">str</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Apply a field_title_generator on a FieldInfo or ComputedFieldInfo instance if appropriate 
        Args: 
            config_wrapper: The config of the model 
            field_info: The FieldInfo or ComputedField instance to which the title_generator is (maybe) applied. 
            field_name: The name of the field from which to generate the title. 
        &quot;&quot;&quot;</span>
        <span class="s1">field_title_generator </span><span class="s3">= </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">field_title_generator </span><span class="s2">or </span><span class="s1">config_wrapper</span><span class="s3">.</span><span class="s1">field_title_generator</span>

        <span class="s2">if </span><span class="s1">field_title_generator </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">title </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">title </span><span class="s3">= </span><span class="s1">field_title_generator</span><span class="s3">(</span><span class="s1">field_name</span><span class="s3">, </span><span class="s1">field_info</span><span class="s3">)  </span><span class="s6"># type: ignore</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">title</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s5">f'field_title_generator </span><span class="s2">{</span><span class="s1">field_title_generator</span><span class="s2">} </span><span class="s5">must return str, not </span><span class="s2">{</span><span class="s1">title</span><span class="s3">.</span><span class="s1">__class__</span><span class="s2">}</span><span class="s5">'</span><span class="s3">)</span>

            <span class="s1">field_info</span><span class="s3">.</span><span class="s1">title </span><span class="s3">= </span><span class="s1">title</span>

    <span class="s2">def </span><span class="s1">_common_field_schema</span><span class="s3">(  </span><span class="s6"># C901</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">field_info</span><span class="s3">: </span><span class="s1">FieldInfo</span><span class="s3">, </span><span class="s1">decorators</span><span class="s3">: </span><span class="s1">DecoratorInfos</span>
    <span class="s3">) </span><span class="s1">-&gt; _CommonField</span><span class="s3">:</span>
        <span class="s1">source_type</span><span class="s3">, </span><span class="s1">annotations </span><span class="s3">= </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">annotation</span><span class="s3">, </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">metadata</span>

        <span class="s2">def </span><span class="s1">set_discriminator</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:</span>
            <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_apply_discriminator_to_union</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">discriminator</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">schema</span>

        <span class="s6"># Convert `@field_validator` decorators to `Before/After/Plain/WrapValidator` instances:</span>
        <span class="s1">validators_from_decorators </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">decorator </span><span class="s2">in </span><span class="s1">filter_field_decorator_info_by_field</span><span class="s3">(</span><span class="s1">decorators</span><span class="s3">.</span><span class="s1">field_validators</span><span class="s3">.</span><span class="s1">values</span><span class="s3">(), </span><span class="s1">name</span><span class="s3">):</span>
            <span class="s1">validators_from_decorators</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">_mode_to_validator</span><span class="s3">[</span><span class="s1">decorator</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">mode</span><span class="s3">].</span><span class="s1">_from_decorator</span><span class="s3">(</span><span class="s1">decorator</span><span class="s3">))</span>

        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">field_name_stack</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">name</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">discriminator </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_apply_annotations</span><span class="s3">(</span>
                    <span class="s1">source_type</span><span class="s3">, </span><span class="s1">annotations </span><span class="s3">+ </span><span class="s1">validators_from_decorators</span><span class="s3">, </span><span class="s1">transform_inner_schema</span><span class="s3">=</span><span class="s1">set_discriminator</span>
                <span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_apply_annotations</span><span class="s3">(</span>
                    <span class="s1">source_type</span><span class="s3">,</span>
                    <span class="s1">annotations </span><span class="s3">+ </span><span class="s1">validators_from_decorators</span><span class="s3">,</span>
                <span class="s3">)</span>

        <span class="s6"># This V1 compatibility shim should eventually be removed</span>
        <span class="s6"># push down any `each_item=True` validators</span>
        <span class="s6"># note that this won't work for any Annotated types that get wrapped by a function validator</span>
        <span class="s6"># but that's okay because that didn't exist in V1</span>
        <span class="s1">this_field_validators </span><span class="s3">= </span><span class="s1">filter_field_decorator_info_by_field</span><span class="s3">(</span><span class="s1">decorators</span><span class="s3">.</span><span class="s1">validators</span><span class="s3">.</span><span class="s1">values</span><span class="s3">(), </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">_validators_require_validate_default</span><span class="s3">(</span><span class="s1">this_field_validators</span><span class="s3">):</span>
            <span class="s1">field_info</span><span class="s3">.</span><span class="s1">validate_default </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s1">each_item_validators </span><span class="s3">= [</span><span class="s1">v </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">this_field_validators </span><span class="s2">if </span><span class="s1">v</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">each_item </span><span class="s2">is True</span><span class="s3">]</span>
        <span class="s1">this_field_validators </span><span class="s3">= [</span><span class="s1">v </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">this_field_validators </span><span class="s2">if </span><span class="s1">v </span><span class="s2">not in </span><span class="s1">each_item_validators</span><span class="s3">]</span>
        <span class="s1">schema </span><span class="s3">= </span><span class="s1">apply_each_item_validators</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">each_item_validators</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>

        <span class="s1">schema </span><span class="s3">= </span><span class="s1">apply_validators</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">this_field_validators</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>

        <span class="s6"># the default validator needs to go outside of any other validators</span>
        <span class="s6"># so that it is the topmost validator for the field validator</span>
        <span class="s6"># which uses it to check if the field has a default value or not</span>
        <span class="s2">if not </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">is_required</span><span class="s3">():</span>
            <span class="s1">schema </span><span class="s3">= </span><span class="s1">wrap_default</span><span class="s3">(</span><span class="s1">field_info</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">)</span>

        <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_apply_field_serializers</span><span class="s3">(</span>
            <span class="s1">schema</span><span class="s3">, </span><span class="s1">filter_field_decorator_info_by_field</span><span class="s3">(</span><span class="s1">decorators</span><span class="s3">.</span><span class="s1">field_serializers</span><span class="s3">.</span><span class="s1">values</span><span class="s3">(), </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_apply_field_title_generator_to_field_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper</span><span class="s3">, </span><span class="s1">field_info</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>

        <span class="s1">pydantic_js_updates</span><span class="s3">, </span><span class="s1">pydantic_js_extra </span><span class="s3">= </span><span class="s1">_extract_json_schema_info_from_field_info</span><span class="s3">(</span><span class="s1">field_info</span><span class="s3">)</span>
        <span class="s1">core_metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] = {}</span>
        <span class="s1">update_core_metadata</span><span class="s3">(</span>
            <span class="s1">core_metadata</span><span class="s3">, </span><span class="s1">pydantic_js_updates</span><span class="s3">=</span><span class="s1">pydantic_js_updates</span><span class="s3">, </span><span class="s1">pydantic_js_extra</span><span class="s3">=</span><span class="s1">pydantic_js_extra</span>
        <span class="s3">)</span>

        <span class="s1">alias_generator </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper</span><span class="s3">.</span><span class="s1">alias_generator</span>
        <span class="s2">if </span><span class="s1">alias_generator </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_apply_alias_generator_to_field_info</span><span class="s3">(</span><span class="s1">alias_generator</span><span class="s3">, </span><span class="s1">field_info</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">validation_alias</span><span class="s3">, (</span><span class="s1">AliasChoices</span><span class="s3">, </span><span class="s1">AliasPath</span><span class="s3">)):</span>
            <span class="s1">validation_alias </span><span class="s3">= </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">validation_alias</span><span class="s3">.</span><span class="s1">convert_to_aliases</span><span class="s3">()</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">validation_alias </span><span class="s3">= </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">validation_alias</span>

        <span class="s2">return </span><span class="s1">_common_field</span><span class="s3">(</span>
            <span class="s1">schema</span><span class="s3">,</span>
            <span class="s1">serialization_exclude</span><span class="s3">=</span><span class="s2">True if </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">exclude </span><span class="s2">else None</span><span class="s3">,</span>
            <span class="s1">validation_alias</span><span class="s3">=</span><span class="s1">validation_alias</span><span class="s3">,</span>
            <span class="s1">serialization_alias</span><span class="s3">=</span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">serialization_alias</span><span class="s3">,</span>
            <span class="s1">frozen</span><span class="s3">=</span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">frozen</span><span class="s3">,</span>
            <span class="s1">metadata</span><span class="s3">=</span><span class="s1">core_metadata</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_union_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">union_type</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generate schema for a Union.&quot;&quot;&quot;</span>
        <span class="s1">args </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_args_resolving_forward_refs</span><span class="s3">(</span><span class="s1">union_type</span><span class="s3">, </span><span class="s1">required</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">choices</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">] = []</span>
        <span class="s1">nullable </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">arg </span><span class="s2">is None or </span><span class="s1">arg </span><span class="s2">is </span><span class="s1">_typing_extra</span><span class="s3">.</span><span class="s1">NoneType</span><span class="s3">:</span>
                <span class="s1">nullable </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">choices</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">))</span>

        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">choices</span><span class="s3">) == </span><span class="s4">1</span><span class="s3">:</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s1">choices</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">choices_with_tags</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">CoreSchema</span><span class="s3">, </span><span class="s1">str</span><span class="s3">]] = []</span>
            <span class="s2">for </span><span class="s1">choice </span><span class="s2">in </span><span class="s1">choices</span><span class="s3">:</span>
                <span class="s1">tag </span><span class="s3">= </span><span class="s1">cast</span><span class="s3">(</span><span class="s1">CoreMetadata</span><span class="s3">, </span><span class="s1">choice</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'metadata'</span><span class="s3">, {})).</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'pydantic_internal_union_tag_key'</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">tag </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">choices_with_tags</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">choice</span><span class="s3">, </span><span class="s1">tag</span><span class="s3">))</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">choices_with_tags</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">choice</span><span class="s3">)</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">union_schema</span><span class="s3">(</span><span class="s1">choices_with_tags</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">nullable</span><span class="s3">:</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">nullable_schema</span><span class="s3">(</span><span class="s1">s</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">def </span><span class="s1">_type_alias_type_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">: </span><span class="s1">TypeAliasType</span><span class="s3">) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">.</span><span class="s1">get_schema_or_ref</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) </span><span class="s2">as </span><span class="s3">(</span><span class="s1">ref</span><span class="s3">, </span><span class="s1">maybe_schema</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">maybe_schema </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">maybe_schema</span>

            <span class="s1">origin</span><span class="s3">: </span><span class="s1">TypeAliasType </span><span class="s3">= </span><span class="s1">get_origin</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) </span><span class="s2">or </span><span class="s1">obj</span>
            <span class="s1">typevars_map </span><span class="s3">= </span><span class="s1">get_standard_typevars_map</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>

            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ns_resolver</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">):</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s1">annotation </span><span class="s3">= </span><span class="s1">_typing_extra</span><span class="s3">.</span><span class="s1">eval_type</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">.</span><span class="s1">__value__</span><span class="s3">, *</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_types_namespace</span><span class="s3">)</span>
                <span class="s2">except </span><span class="s1">NameError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">PydanticUndefinedAnnotation</span><span class="s3">.</span><span class="s1">from_name_error</span><span class="s3">(</span><span class="s1">e</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>
                <span class="s1">annotation </span><span class="s3">= </span><span class="s1">replace_types</span><span class="s3">(</span><span class="s1">annotation</span><span class="s3">, </span><span class="s1">typevars_map</span><span class="s3">)</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">annotation</span><span class="s3">)</span>
                <span class="s2">assert </span><span class="s1">schema</span><span class="s3">[</span><span class="s5">'type'</span><span class="s3">] != </span><span class="s5">'definitions'</span>
                <span class="s1">schema</span><span class="s3">[</span><span class="s5">'ref'</span><span class="s3">] = </span><span class="s1">ref  </span><span class="s6"># type: ignore</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">.</span><span class="s1">create_definition_reference_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_literal_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">literal_type</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generate schema for a Literal.&quot;&quot;&quot;</span>
        <span class="s1">expected </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">get_literal_values</span><span class="s3">(</span><span class="s1">literal_type</span><span class="s3">, </span><span class="s1">type_check</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">unpack_type_aliases</span><span class="s3">=</span><span class="s5">'eager'</span><span class="s3">))</span>
        <span class="s2">assert </span><span class="s1">expected</span><span class="s3">, </span><span class="s5">f'literal &quot;expected&quot; cannot be empty, obj=</span><span class="s2">{</span><span class="s1">literal_type</span><span class="s2">}</span><span class="s5">'</span>
        <span class="s1">schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">literal_schema</span><span class="s3">(</span><span class="s1">expected</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper</span><span class="s3">.</span><span class="s1">use_enum_values </span><span class="s2">and </span><span class="s1">any</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">Enum</span><span class="s3">) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">expected</span><span class="s3">):</span>
            <span class="s1">schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">no_info_after_validator_function</span><span class="s3">(</span>
                <span class="s2">lambda </span><span class="s1">v</span><span class="s3">: </span><span class="s1">v</span><span class="s3">.</span><span class="s1">value </span><span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">Enum</span><span class="s3">) </span><span class="s2">else </span><span class="s1">v</span><span class="s3">, </span><span class="s1">schema</span>
            <span class="s3">)</span>

        <span class="s2">return </span><span class="s1">schema</span>

    <span class="s2">def </span><span class="s1">_typed_dict_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typed_dict_cls</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generate a core schema for a `TypedDict` class. 
 
        To be able to build a `DecoratorInfos` instance for the `TypedDict` class (which will include 
        validators, serializers, etc.), we need to have access to the original bases of the class 
        (see https://docs.python.org/3/library/types.html#types.get_original_bases). 
        However, the `__orig_bases__` attribute was only added in 3.12 (https://github.com/python/cpython/pull/103698). 
 
        For this reason, we require Python 3.12 (or using the `typing_extensions` backport). 
        &quot;&quot;&quot;</span>
        <span class="s1">FieldInfo </span><span class="s3">= </span><span class="s1">import_cached_field_info</span><span class="s3">()</span>

        <span class="s2">with </span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">model_type_stack</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">typed_dict_cls</span><span class="s3">),</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">.</span><span class="s1">get_schema_or_ref</span><span class="s3">(</span><span class="s1">typed_dict_cls</span><span class="s3">) </span><span class="s2">as </span><span class="s3">(</span>
                <span class="s1">typed_dict_ref</span><span class="s3">,</span>
                <span class="s1">maybe_schema</span><span class="s3">,</span>
            <span class="s3">),</span>
        <span class="s3">):</span>
            <span class="s2">if </span><span class="s1">maybe_schema </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">maybe_schema</span>

            <span class="s1">typevars_map </span><span class="s3">= </span><span class="s1">get_standard_typevars_map</span><span class="s3">(</span><span class="s1">typed_dict_cls</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">origin </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">typed_dict_cls </span><span class="s3">= </span><span class="s1">origin</span>

            <span class="s2">if not </span><span class="s1">_SUPPORTS_TYPEDDICT </span><span class="s2">and </span><span class="s1">type</span><span class="s3">(</span><span class="s1">typed_dict_cls</span><span class="s3">).</span><span class="s1">__module__ </span><span class="s3">== </span><span class="s5">'typing'</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">PydanticUserError</span><span class="s3">(</span>
                    <span class="s5">'Please use `typing_extensions.TypedDict` instead of `typing.TypedDict` on Python &lt; 3.12.'</span><span class="s3">,</span>
                    <span class="s1">code</span><span class="s3">=</span><span class="s5">'typed-dict-version'</span><span class="s3">,</span>
                <span class="s3">)</span>

            <span class="s2">try</span><span class="s3">:</span>
                <span class="s6"># if a typed dictionary class doesn't have config, we use the parent's config, hence a default of `None`</span>
                <span class="s6"># see https://github.com/pydantic/pydantic/issues/10917</span>
                <span class="s1">config</span><span class="s3">: </span><span class="s1">ConfigDict </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s1">get_attribute_from_bases</span><span class="s3">(</span><span class="s1">typed_dict_cls</span><span class="s3">, </span><span class="s5">'__pydantic_config__'</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
                <span class="s1">config </span><span class="s3">= </span><span class="s2">None</span>

            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper_stack</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">config</span><span class="s3">):</span>
                <span class="s1">core_config </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper</span><span class="s3">.</span><span class="s1">core_config</span><span class="s3">(</span><span class="s1">title</span><span class="s3">=</span><span class="s1">typed_dict_cls</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">)</span>

                <span class="s1">required_keys</span><span class="s3">: </span><span class="s1">frozenset</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = </span><span class="s1">typed_dict_cls</span><span class="s3">.</span><span class="s1">__required_keys__</span>

                <span class="s1">fields</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">TypedDictField</span><span class="s3">] = {}</span>

                <span class="s1">decorators </span><span class="s3">= </span><span class="s1">DecoratorInfos</span><span class="s3">.</span><span class="s1">build</span><span class="s3">(</span><span class="s1">typed_dict_cls</span><span class="s3">)</span>

                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper</span><span class="s3">.</span><span class="s1">use_attribute_docstrings</span><span class="s3">:</span>
                    <span class="s1">field_docstrings </span><span class="s3">= </span><span class="s1">extract_docstrings_from_cls</span><span class="s3">(</span><span class="s1">typed_dict_cls</span><span class="s3">, </span><span class="s1">use_inspect</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">field_docstrings </span><span class="s3">= </span><span class="s2">None</span>

                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s1">annotations </span><span class="s3">= </span><span class="s1">_typing_extra</span><span class="s3">.</span><span class="s1">get_cls_type_hints</span><span class="s3">(</span><span class="s1">typed_dict_cls</span><span class="s3">, </span><span class="s1">ns_resolver</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ns_resolver</span><span class="s3">)</span>
                <span class="s2">except </span><span class="s1">NameError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">PydanticUndefinedAnnotation</span><span class="s3">.</span><span class="s1">from_name_error</span><span class="s3">(</span><span class="s1">e</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>

                <span class="s1">readonly_fields</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = []</span>

                <span class="s2">for </span><span class="s1">field_name</span><span class="s3">, </span><span class="s1">annotation </span><span class="s2">in </span><span class="s1">annotations</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                    <span class="s1">field_info </span><span class="s3">= </span><span class="s1">FieldInfo</span><span class="s3">.</span><span class="s1">from_annotation</span><span class="s3">(</span><span class="s1">annotation</span><span class="s3">, </span><span class="s1">_source</span><span class="s3">=</span><span class="s1">AnnotationSource</span><span class="s3">.</span><span class="s1">TYPED_DICT</span><span class="s3">)</span>
                    <span class="s1">field_info</span><span class="s3">.</span><span class="s1">annotation </span><span class="s3">= </span><span class="s1">replace_types</span><span class="s3">(</span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">annotation</span><span class="s3">, </span><span class="s1">typevars_map</span><span class="s3">)</span>

                    <span class="s1">required </span><span class="s3">= (</span>
                        <span class="s1">field_name </span><span class="s2">in </span><span class="s1">required_keys </span><span class="s2">or </span><span class="s5">'required' </span><span class="s2">in </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">_qualifiers</span>
                    <span class="s3">) </span><span class="s2">and </span><span class="s5">'not_required' </span><span class="s2">not in </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">_qualifiers</span>
                    <span class="s2">if </span><span class="s5">'read_only' </span><span class="s2">in </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">_qualifiers</span><span class="s3">:</span>
                        <span class="s1">readonly_fields</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">field_name</span><span class="s3">)</span>

                    <span class="s2">if </span><span class="s3">(</span>
                        <span class="s1">field_docstrings </span><span class="s2">is not None</span>
                        <span class="s2">and </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">description </span><span class="s2">is None</span>
                        <span class="s2">and </span><span class="s1">field_name </span><span class="s2">in </span><span class="s1">field_docstrings</span>
                    <span class="s3">):</span>
                        <span class="s1">field_info</span><span class="s3">.</span><span class="s1">description </span><span class="s3">= </span><span class="s1">field_docstrings</span><span class="s3">[</span><span class="s1">field_name</span><span class="s3">]</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">_apply_field_title_generator_to_field_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper</span><span class="s3">, </span><span class="s1">field_info</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">)</span>
                    <span class="s1">fields</span><span class="s3">[</span><span class="s1">field_name</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_td_field_schema</span><span class="s3">(</span>
                        <span class="s1">field_name</span><span class="s3">, </span><span class="s1">field_info</span><span class="s3">, </span><span class="s1">decorators</span><span class="s3">, </span><span class="s1">required</span><span class="s3">=</span><span class="s1">required</span>
                    <span class="s3">)</span>

                <span class="s2">if </span><span class="s1">readonly_fields</span><span class="s3">:</span>
                    <span class="s1">fields_repr </span><span class="s3">= </span><span class="s5">', '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">repr</span><span class="s3">(</span><span class="s1">f</span><span class="s3">) </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">readonly_fields</span><span class="s3">)</span>
                    <span class="s1">plural </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">readonly_fields</span><span class="s3">) &gt;= </span><span class="s4">2</span>
                    <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                        <span class="s5">f'Item</span><span class="s2">{</span><span class="s5">&quot;s&quot; </span><span class="s2">if </span><span class="s1">plural </span><span class="s2">else </span><span class="s5">&quot;&quot;</span><span class="s2">} {</span><span class="s1">fields_repr</span><span class="s2">} </span><span class="s5">on TypedDict class </span><span class="s2">{</span><span class="s1">typed_dict_cls</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">!r} </span><span class="s5">'</span>
                        <span class="s5">f'</span><span class="s2">{</span><span class="s5">&quot;are&quot; </span><span class="s2">if </span><span class="s1">plural </span><span class="s2">else </span><span class="s5">&quot;is&quot;</span><span class="s2">} </span><span class="s5">using the `ReadOnly` qualifier. Pydantic will not protect items '</span>
                        <span class="s5">'from any mutation on dictionary instances.'</span><span class="s3">,</span>
                        <span class="s1">UserWarning</span><span class="s3">,</span>
                    <span class="s3">)</span>

                <span class="s1">td_schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">typed_dict_schema</span><span class="s3">(</span>
                    <span class="s1">fields</span><span class="s3">,</span>
                    <span class="s1">cls</span><span class="s3">=</span><span class="s1">typed_dict_cls</span><span class="s3">,</span>
                    <span class="s1">computed_fields</span><span class="s3">=[</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">_computed_field_schema</span><span class="s3">(</span><span class="s1">d</span><span class="s3">, </span><span class="s1">decorators</span><span class="s3">.</span><span class="s1">field_serializers</span><span class="s3">)</span>
                        <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">decorators</span><span class="s3">.</span><span class="s1">computed_fields</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()</span>
                    <span class="s3">],</span>
                    <span class="s1">ref</span><span class="s3">=</span><span class="s1">typed_dict_ref</span><span class="s3">,</span>
                    <span class="s1">config</span><span class="s3">=</span><span class="s1">core_config</span><span class="s3">,</span>
                <span class="s3">)</span>

                <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_apply_model_serializers</span><span class="s3">(</span><span class="s1">td_schema</span><span class="s3">, </span><span class="s1">decorators</span><span class="s3">.</span><span class="s1">model_serializers</span><span class="s3">.</span><span class="s1">values</span><span class="s3">())</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">apply_model_validators</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">decorators</span><span class="s3">.</span><span class="s1">model_validators</span><span class="s3">.</span><span class="s1">values</span><span class="s3">(), </span><span class="s5">'all'</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">.</span><span class="s1">create_definition_reference_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_namedtuple_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">namedtuple_cls</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generate schema for a NamedTuple.&quot;&quot;&quot;</span>
        <span class="s2">with </span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">model_type_stack</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">namedtuple_cls</span><span class="s3">),</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">.</span><span class="s1">get_schema_or_ref</span><span class="s3">(</span><span class="s1">namedtuple_cls</span><span class="s3">) </span><span class="s2">as </span><span class="s3">(</span>
                <span class="s1">namedtuple_ref</span><span class="s3">,</span>
                <span class="s1">maybe_schema</span><span class="s3">,</span>
            <span class="s3">),</span>
        <span class="s3">):</span>
            <span class="s2">if </span><span class="s1">maybe_schema </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">maybe_schema</span>
            <span class="s1">typevars_map </span><span class="s3">= </span><span class="s1">get_standard_typevars_map</span><span class="s3">(</span><span class="s1">namedtuple_cls</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">origin </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">namedtuple_cls </span><span class="s3">= </span><span class="s1">origin</span>

            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">annotations </span><span class="s3">= </span><span class="s1">_typing_extra</span><span class="s3">.</span><span class="s1">get_cls_type_hints</span><span class="s3">(</span><span class="s1">namedtuple_cls</span><span class="s3">, </span><span class="s1">ns_resolver</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ns_resolver</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">NameError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">PydanticUndefinedAnnotation</span><span class="s3">.</span><span class="s1">from_name_error</span><span class="s3">(</span><span class="s1">e</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>
            <span class="s2">if not </span><span class="s1">annotations</span><span class="s3">:</span>
                <span class="s6"># annotations is empty, happens if namedtuple_cls defined via collections.namedtuple(...)</span>
                <span class="s1">annotations</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] = {</span><span class="s1">k</span><span class="s3">: </span><span class="s1">Any </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">namedtuple_cls</span><span class="s3">.</span><span class="s1">_fields</span><span class="s3">}</span>

            <span class="s2">if </span><span class="s1">typevars_map</span><span class="s3">:</span>
                <span class="s1">annotations </span><span class="s3">= {</span>
                    <span class="s1">field_name</span><span class="s3">: </span><span class="s1">replace_types</span><span class="s3">(</span><span class="s1">annotation</span><span class="s3">, </span><span class="s1">typevars_map</span><span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">field_name</span><span class="s3">, </span><span class="s1">annotation </span><span class="s2">in </span><span class="s1">annotations</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
                <span class="s3">}</span>

            <span class="s1">arguments_schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">arguments_schema</span><span class="s3">(</span>
                <span class="s3">[</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_parameter_schema</span><span class="s3">(</span>
                        <span class="s1">field_name</span><span class="s3">,</span>
                        <span class="s1">annotation</span><span class="s3">,</span>
                        <span class="s1">source</span><span class="s3">=</span><span class="s1">AnnotationSource</span><span class="s3">.</span><span class="s1">NAMED_TUPLE</span><span class="s3">,</span>
                        <span class="s1">default</span><span class="s3">=</span><span class="s1">namedtuple_cls</span><span class="s3">.</span><span class="s1">_field_defaults</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">field_name</span><span class="s3">, </span><span class="s1">Parameter</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">),</span>
                    <span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">field_name</span><span class="s3">, </span><span class="s1">annotation </span><span class="s2">in </span><span class="s1">annotations</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
                <span class="s3">],</span>
                <span class="s1">metadata</span><span class="s3">={</span><span class="s5">'pydantic_js_prefer_positional_arguments'</span><span class="s3">: </span><span class="s2">True</span><span class="s3">},</span>
            <span class="s3">)</span>
            <span class="s1">schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">call_schema</span><span class="s3">(</span><span class="s1">arguments_schema</span><span class="s3">, </span><span class="s1">namedtuple_cls</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">=</span><span class="s1">namedtuple_ref</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">.</span><span class="s1">create_definition_reference_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_generate_parameter_schema</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
        <span class="s1">annotation</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">],</span>
        <span class="s1">source</span><span class="s3">: </span><span class="s1">AnnotationSource</span><span class="s3">,</span>
        <span class="s1">default</span><span class="s3">: </span><span class="s1">Any </span><span class="s3">= </span><span class="s1">Parameter</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">,</span>
        <span class="s1">mode</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s5">'positional_only'</span><span class="s3">, </span><span class="s5">'positional_or_keyword'</span><span class="s3">, </span><span class="s5">'keyword_only'</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">ArgumentsParameter</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generate the definition of a field in a namedtuple or a parameter in a function signature. 
 
        This definition is meant to be used for the `'arguments'` core schema, which will be replaced 
        in V3 by the `'arguments-v3`'. 
        &quot;&quot;&quot;</span>
        <span class="s1">FieldInfo </span><span class="s3">= </span><span class="s1">import_cached_field_info</span><span class="s3">()</span>

        <span class="s2">if </span><span class="s1">default </span><span class="s2">is </span><span class="s1">Parameter</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">:</span>
            <span class="s1">field </span><span class="s3">= </span><span class="s1">FieldInfo</span><span class="s3">.</span><span class="s1">from_annotation</span><span class="s3">(</span><span class="s1">annotation</span><span class="s3">, </span><span class="s1">_source</span><span class="s3">=</span><span class="s1">source</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">field </span><span class="s3">= </span><span class="s1">FieldInfo</span><span class="s3">.</span><span class="s1">from_annotated_attribute</span><span class="s3">(</span><span class="s1">annotation</span><span class="s3">, </span><span class="s1">default</span><span class="s3">, </span><span class="s1">_source</span><span class="s3">=</span><span class="s1">source</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">field</span><span class="s3">.</span><span class="s1">annotation </span><span class="s2">is not None</span><span class="s3">, </span><span class="s5">'field.annotation should not be None when generating a schema'</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">field_name_stack</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">name</span><span class="s3">):</span>
            <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_apply_annotations</span><span class="s3">(</span><span class="s1">field</span><span class="s3">.</span><span class="s1">annotation</span><span class="s3">, [</span><span class="s1">field</span><span class="s3">])</span>

        <span class="s2">if not </span><span class="s1">field</span><span class="s3">.</span><span class="s1">is_required</span><span class="s3">():</span>
            <span class="s1">schema </span><span class="s3">= </span><span class="s1">wrap_default</span><span class="s3">(</span><span class="s1">field</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">)</span>

        <span class="s1">parameter_schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">arguments_parameter</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">mode </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">parameter_schema</span><span class="s3">[</span><span class="s5">'mode'</span><span class="s3">] = </span><span class="s1">mode</span>
        <span class="s2">if </span><span class="s1">field</span><span class="s3">.</span><span class="s1">alias </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">parameter_schema</span><span class="s3">[</span><span class="s5">'alias'</span><span class="s3">] = </span><span class="s1">field</span><span class="s3">.</span><span class="s1">alias</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">alias_generator </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper</span><span class="s3">.</span><span class="s1">alias_generator</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">alias_generator</span><span class="s3">, </span><span class="s1">AliasGenerator</span><span class="s3">) </span><span class="s2">and </span><span class="s1">alias_generator</span><span class="s3">.</span><span class="s1">alias </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">parameter_schema</span><span class="s3">[</span><span class="s5">'alias'</span><span class="s3">] = </span><span class="s1">alias_generator</span><span class="s3">.</span><span class="s1">alias</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">alias_generator</span><span class="s3">):</span>
                <span class="s1">parameter_schema</span><span class="s3">[</span><span class="s5">'alias'</span><span class="s3">] = </span><span class="s1">alias_generator</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">parameter_schema</span>

    <span class="s2">def </span><span class="s1">_generate_parameter_v3_schema</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
        <span class="s1">annotation</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
        <span class="s1">source</span><span class="s3">: </span><span class="s1">AnnotationSource</span><span class="s3">,</span>
        <span class="s1">mode</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span>
            <span class="s5">'positional_only'</span><span class="s3">,</span>
            <span class="s5">'positional_or_keyword'</span><span class="s3">,</span>
            <span class="s5">'keyword_only'</span><span class="s3">,</span>
            <span class="s5">'var_args'</span><span class="s3">,</span>
            <span class="s5">'var_kwargs_uniform'</span><span class="s3">,</span>
            <span class="s5">'var_kwargs_unpacked_typed_dict'</span><span class="s3">,</span>
        <span class="s3">],</span>
        <span class="s1">default</span><span class="s3">: </span><span class="s1">Any </span><span class="s3">= </span><span class="s1">Parameter</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">ArgumentsV3Parameter</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generate the definition of a parameter in a function signature. 
 
        This definition is meant to be used for the `'arguments-v3'` core schema, which will replace 
        the `'arguments`' schema in V3. 
        &quot;&quot;&quot;</span>
        <span class="s1">FieldInfo </span><span class="s3">= </span><span class="s1">import_cached_field_info</span><span class="s3">()</span>

        <span class="s2">if </span><span class="s1">default </span><span class="s2">is </span><span class="s1">Parameter</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">:</span>
            <span class="s1">field </span><span class="s3">= </span><span class="s1">FieldInfo</span><span class="s3">.</span><span class="s1">from_annotation</span><span class="s3">(</span><span class="s1">annotation</span><span class="s3">, </span><span class="s1">_source</span><span class="s3">=</span><span class="s1">source</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">field </span><span class="s3">= </span><span class="s1">FieldInfo</span><span class="s3">.</span><span class="s1">from_annotated_attribute</span><span class="s3">(</span><span class="s1">annotation</span><span class="s3">, </span><span class="s1">default</span><span class="s3">, </span><span class="s1">_source</span><span class="s3">=</span><span class="s1">source</span><span class="s3">)</span>

        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">field_name_stack</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">name</span><span class="s3">):</span>
            <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_apply_annotations</span><span class="s3">(</span><span class="s1">field</span><span class="s3">.</span><span class="s1">annotation</span><span class="s3">, [</span><span class="s1">field</span><span class="s3">])</span>

        <span class="s2">if not </span><span class="s1">field</span><span class="s3">.</span><span class="s1">is_required</span><span class="s3">():</span>
            <span class="s1">schema </span><span class="s3">= </span><span class="s1">wrap_default</span><span class="s3">(</span><span class="s1">field</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">)</span>

        <span class="s1">parameter_schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">arguments_v3_parameter</span><span class="s3">(</span>
            <span class="s1">name</span><span class="s3">=</span><span class="s1">name</span><span class="s3">,</span>
            <span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">,</span>
            <span class="s1">mode</span><span class="s3">=</span><span class="s1">mode</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s2">if </span><span class="s1">field</span><span class="s3">.</span><span class="s1">alias </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">parameter_schema</span><span class="s3">[</span><span class="s5">'alias'</span><span class="s3">] = </span><span class="s1">field</span><span class="s3">.</span><span class="s1">alias</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">alias_generator </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper</span><span class="s3">.</span><span class="s1">alias_generator</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">alias_generator</span><span class="s3">, </span><span class="s1">AliasGenerator</span><span class="s3">) </span><span class="s2">and </span><span class="s1">alias_generator</span><span class="s3">.</span><span class="s1">alias </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">parameter_schema</span><span class="s3">[</span><span class="s5">'alias'</span><span class="s3">] = </span><span class="s1">alias_generator</span><span class="s3">.</span><span class="s1">alias</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">alias_generator</span><span class="s3">):</span>
                <span class="s1">parameter_schema</span><span class="s3">[</span><span class="s5">'alias'</span><span class="s3">] = </span><span class="s1">alias_generator</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">parameter_schema</span>

    <span class="s2">def </span><span class="s1">_tuple_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tuple_type</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generate schema for a Tuple, e.g. `tuple[int, str]` or `tuple[int, ...]`.&quot;&quot;&quot;</span>
        <span class="s6"># TODO: do we really need to resolve type vars here?</span>
        <span class="s1">typevars_map </span><span class="s3">= </span><span class="s1">get_standard_typevars_map</span><span class="s3">(</span><span class="s1">tuple_type</span><span class="s3">)</span>
        <span class="s1">params </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_args_resolving_forward_refs</span><span class="s3">(</span><span class="s1">tuple_type</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">typevars_map </span><span class="s2">and </span><span class="s1">params</span><span class="s3">:</span>
            <span class="s1">params </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">replace_types</span><span class="s3">(</span><span class="s1">param</span><span class="s3">, </span><span class="s1">typevars_map</span><span class="s3">) </span><span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">params</span><span class="s3">)</span>

        <span class="s6"># NOTE: subtle difference: `tuple[()]` gives `params=()`, whereas `typing.Tuple[()]` gives `params=((),)`</span>
        <span class="s6"># This is only true for &lt;3.11, on Python 3.11+ `typing.Tuple[()]` gives `params=()`</span>
        <span class="s2">if not </span><span class="s1">params</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">tuple_type </span><span class="s2">in </span><span class="s1">TUPLE_TYPES</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">tuple_schema</span><span class="s3">([</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">any_schema</span><span class="s3">()], </span><span class="s1">variadic_item_index</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s6"># special case for `tuple[()]` which means `tuple[]` - an empty tuple</span>
                <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">tuple_schema</span><span class="s3">([])</span>
        <span class="s2">elif </span><span class="s1">params</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">] </span><span class="s2">is </span><span class="s1">Ellipsis</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">params</span><span class="s3">) == </span><span class="s4">2</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">tuple_schema</span><span class="s3">([</span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">params</span><span class="s3">[</span><span class="s4">0</span><span class="s3">])], </span><span class="s1">variadic_item_index</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s6"># TODO: something like https://github.com/pydantic/pydantic/issues/5952</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">'Variable tuples can only have one type'</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">params</span><span class="s3">) == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">params</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] == ():</span>
            <span class="s6"># special case for `tuple[()]` which means `tuple[]` - an empty tuple</span>
            <span class="s6"># NOTE: This conditional can be removed when we drop support for Python 3.10.</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">tuple_schema</span><span class="s3">([])</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">tuple_schema</span><span class="s3">([</span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">param</span><span class="s3">) </span><span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">params</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">_type_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">custom_error_schema</span><span class="s3">(</span>
            <span class="s1">core_schema</span><span class="s3">.</span><span class="s1">is_instance_schema</span><span class="s3">(</span><span class="s1">type</span><span class="s3">),</span>
            <span class="s1">custom_error_type</span><span class="s3">=</span><span class="s5">'is_type'</span><span class="s3">,</span>
            <span class="s1">custom_error_message</span><span class="s3">=</span><span class="s5">'Input should be a type'</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_zoneinfo_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generate schema for a zone_info.ZoneInfo object&quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s3">.</span><span class="s1">_validators </span><span class="s2">import </span><span class="s1">validate_str_is_valid_iana_tz</span>

        <span class="s1">metadata </span><span class="s3">= {</span><span class="s5">'pydantic_js_functions'</span><span class="s3">: [</span><span class="s2">lambda </span><span class="s1">_1</span><span class="s3">, </span><span class="s1">_2</span><span class="s3">: {</span><span class="s5">'type'</span><span class="s3">: </span><span class="s5">'string'</span><span class="s3">, </span><span class="s5">'format'</span><span class="s3">: </span><span class="s5">'zoneinfo'</span><span class="s3">}]}</span>
        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">no_info_plain_validator_function</span><span class="s3">(</span>
            <span class="s1">validate_str_is_valid_iana_tz</span><span class="s3">,</span>
            <span class="s1">serialization</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">to_string_ser_schema</span><span class="s3">(),</span>
            <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_union_is_subclass_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">union_type</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generate schema for `type[Union[X, ...]]`.&quot;&quot;&quot;</span>
        <span class="s1">args </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_args_resolving_forward_refs</span><span class="s3">(</span><span class="s1">union_type</span><span class="s3">, </span><span class="s1">required</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">union_schema</span><span class="s3">([</span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">type</span><span class="s3">[</span><span class="s1">args</span><span class="s3">]) </span><span class="s2">for </span><span class="s1">args </span><span class="s2">in </span><span class="s1">args</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">_subclass_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">type_</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generate schema for a type, e.g. `type[int]`.&quot;&quot;&quot;</span>
        <span class="s1">type_param </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_first_arg_or_any</span><span class="s3">(</span><span class="s1">type_</span><span class="s3">)</span>

        <span class="s6"># Assume `type[Annotated[&lt;typ&gt;, ...]]` is equivalent to `type[&lt;typ&gt;]`:</span>
        <span class="s1">type_param </span><span class="s3">= </span><span class="s1">_typing_extra</span><span class="s3">.</span><span class="s1">annotated_type</span><span class="s3">(</span><span class="s1">type_param</span><span class="s3">) </span><span class="s2">or </span><span class="s1">type_param</span>

        <span class="s2">if </span><span class="s1">typing_objects</span><span class="s3">.</span><span class="s1">is_any</span><span class="s3">(</span><span class="s1">type_param</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type_schema</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">typing_objects</span><span class="s3">.</span><span class="s1">is_typealiastype</span><span class="s3">(</span><span class="s1">type_param</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">type</span><span class="s3">[</span><span class="s1">type_param</span><span class="s3">.</span><span class="s1">__value__</span><span class="s3">])</span>
        <span class="s2">elif </span><span class="s1">typing_objects</span><span class="s3">.</span><span class="s1">is_typevar</span><span class="s3">(</span><span class="s1">type_param</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">type_param</span><span class="s3">.</span><span class="s1">__bound__</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">is_union_origin</span><span class="s3">(</span><span class="s1">get_origin</span><span class="s3">(</span><span class="s1">type_param</span><span class="s3">.</span><span class="s1">__bound__</span><span class="s3">)):</span>
                    <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_union_is_subclass_schema</span><span class="s3">(</span><span class="s1">type_param</span><span class="s3">.</span><span class="s1">__bound__</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">is_subclass_schema</span><span class="s3">(</span><span class="s1">type_param</span><span class="s3">.</span><span class="s1">__bound__</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">type_param</span><span class="s3">.</span><span class="s1">__constraints__</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">union_schema</span><span class="s3">([</span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">type</span><span class="s3">[</span><span class="s1">c</span><span class="s3">]) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">type_param</span><span class="s3">.</span><span class="s1">__constraints__</span><span class="s3">])</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type_schema</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">is_union_origin</span><span class="s3">(</span><span class="s1">get_origin</span><span class="s3">(</span><span class="s1">type_param</span><span class="s3">)):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_union_is_subclass_schema</span><span class="s3">(</span><span class="s1">type_param</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">typing_objects</span><span class="s3">.</span><span class="s1">is_self</span><span class="s3">(</span><span class="s1">type_param</span><span class="s3">):</span>
                <span class="s1">type_param </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_resolve_self_type</span><span class="s3">(</span><span class="s1">type_param</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">_typing_extra</span><span class="s3">.</span><span class="s1">is_generic_alias</span><span class="s3">(</span><span class="s1">type_param</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">PydanticUserError</span><span class="s3">(</span>
                    <span class="s5">'Subscripting `type[]` with an already parametrized type is not supported. '</span>
                    <span class="s5">f'Instead of using type[</span><span class="s2">{</span><span class="s1">type_param</span><span class="s2">!r}</span><span class="s5">], use type[</span><span class="s2">{</span><span class="s1">_repr</span><span class="s3">.</span><span class="s1">display_as_type</span><span class="s3">(</span><span class="s1">get_origin</span><span class="s3">(</span><span class="s1">type_param</span><span class="s3">))</span><span class="s2">}</span><span class="s5">].'</span><span class="s3">,</span>
                    <span class="s1">code</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                <span class="s3">)</span>
            <span class="s2">if not </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">isclass</span><span class="s3">(</span><span class="s1">type_param</span><span class="s3">):</span>
                <span class="s6"># when using type[None], this doesn't type convert to type[NoneType], and None isn't a class</span>
                <span class="s6"># so we handle it manually here</span>
                <span class="s2">if </span><span class="s1">type_param </span><span class="s2">is None</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">is_subclass_schema</span><span class="s3">(</span><span class="s1">_typing_extra</span><span class="s3">.</span><span class="s1">NoneType</span><span class="s3">)</span>
                <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s5">f'Expected a class, got </span><span class="s2">{</span><span class="s1">type_param</span><span class="s2">!r}</span><span class="s5">'</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">is_subclass_schema</span><span class="s3">(</span><span class="s1">type_param</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_sequence_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">items_type</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generate schema for a Sequence, e.g. `Sequence[int]`.&quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s3">.</span><span class="s1">_serializers </span><span class="s2">import </span><span class="s1">serialize_sequence_via_list</span>

        <span class="s1">item_type_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">items_type</span><span class="s3">)</span>
        <span class="s1">list_schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">list_schema</span><span class="s3">(</span><span class="s1">item_type_schema</span><span class="s3">)</span>

        <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">smart_deepcopy</span><span class="s3">(</span><span class="s1">list_schema</span><span class="s3">)</span>
        <span class="s1">python_schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">is_instance_schema</span><span class="s3">(</span><span class="s1">typing</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">, </span><span class="s1">cls_repr</span><span class="s3">=</span><span class="s5">'Sequence'</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">typing_objects</span><span class="s3">.</span><span class="s1">is_any</span><span class="s3">(</span><span class="s1">items_type</span><span class="s3">):</span>
            <span class="s2">from </span><span class="s3">.</span><span class="s1">_validators </span><span class="s2">import </span><span class="s1">sequence_validator</span>

            <span class="s1">python_schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">chain_schema</span><span class="s3">(</span>
                <span class="s3">[</span><span class="s1">python_schema</span><span class="s3">, </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">no_info_wrap_validator_function</span><span class="s3">(</span><span class="s1">sequence_validator</span><span class="s3">, </span><span class="s1">list_schema</span><span class="s3">)],</span>
            <span class="s3">)</span>

        <span class="s1">serialization </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">wrap_serializer_function_ser_schema</span><span class="s3">(</span>
            <span class="s1">serialize_sequence_via_list</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">=</span><span class="s1">item_type_schema</span><span class="s3">, </span><span class="s1">info_arg</span><span class="s3">=</span><span class="s2">True</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">json_or_python_schema</span><span class="s3">(</span>
            <span class="s1">json_schema</span><span class="s3">=</span><span class="s1">json_schema</span><span class="s3">, </span><span class="s1">python_schema</span><span class="s3">=</span><span class="s1">python_schema</span><span class="s3">, </span><span class="s1">serialization</span><span class="s3">=</span><span class="s1">serialization</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_iterable_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">type_</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">GeneratorSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generate a schema for an `Iterable`.&quot;&quot;&quot;</span>
        <span class="s1">item_type </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_first_arg_or_any</span><span class="s3">(</span><span class="s1">type_</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">generator_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">item_type</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_pattern_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pattern_type</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">_validators</span>

        <span class="s1">metadata </span><span class="s3">= {</span><span class="s5">'pydantic_js_functions'</span><span class="s3">: [</span><span class="s2">lambda </span><span class="s1">_1</span><span class="s3">, </span><span class="s1">_2</span><span class="s3">: {</span><span class="s5">'type'</span><span class="s3">: </span><span class="s5">'string'</span><span class="s3">, </span><span class="s5">'format'</span><span class="s3">: </span><span class="s5">'regex'</span><span class="s3">}]}</span>
        <span class="s1">ser </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">plain_serializer_function_ser_schema</span><span class="s3">(</span>
            <span class="s1">attrgetter</span><span class="s3">(</span><span class="s5">'pattern'</span><span class="s3">), </span><span class="s1">when_used</span><span class="s3">=</span><span class="s5">'json'</span><span class="s3">, </span><span class="s1">return_schema</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">str_schema</span><span class="s3">()</span>
        <span class="s3">)</span>
        <span class="s2">if </span><span class="s1">pattern_type </span><span class="s2">is </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">Pattern </span><span class="s2">or </span><span class="s1">pattern_type </span><span class="s2">is </span><span class="s1">re</span><span class="s3">.</span><span class="s1">Pattern</span><span class="s3">:</span>
            <span class="s6"># bare type</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">no_info_plain_validator_function</span><span class="s3">(</span>
                <span class="s1">_validators</span><span class="s3">.</span><span class="s1">pattern_either_validator</span><span class="s3">, </span><span class="s1">serialization</span><span class="s3">=</span><span class="s1">ser</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span>
            <span class="s3">)</span>

        <span class="s1">param </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_args_resolving_forward_refs</span><span class="s3">(</span>
            <span class="s1">pattern_type</span><span class="s3">,</span>
            <span class="s1">required</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s3">)[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">param </span><span class="s2">is </span><span class="s1">str</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">no_info_plain_validator_function</span><span class="s3">(</span>
                <span class="s1">_validators</span><span class="s3">.</span><span class="s1">pattern_str_validator</span><span class="s3">, </span><span class="s1">serialization</span><span class="s3">=</span><span class="s1">ser</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span>
            <span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">param </span><span class="s2">is </span><span class="s1">bytes</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">no_info_plain_validator_function</span><span class="s3">(</span>
                <span class="s1">_validators</span><span class="s3">.</span><span class="s1">pattern_bytes_validator</span><span class="s3">, </span><span class="s1">serialization</span><span class="s3">=</span><span class="s1">ser</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span>
            <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">PydanticSchemaGenerationError</span><span class="s3">(</span><span class="s5">f'Unable to generate pydantic-core schema for </span><span class="s2">{</span><span class="s1">pattern_type</span><span class="s2">!r}</span><span class="s5">.'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_hashable_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">custom_error_schema</span><span class="s3">(</span>
            <span class="s1">schema</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">json_or_python_schema</span><span class="s3">(</span>
                <span class="s1">json_schema</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">chain_schema</span><span class="s3">(</span>
                    <span class="s3">[</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">any_schema</span><span class="s3">(), </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">is_instance_schema</span><span class="s3">(</span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">Hashable</span><span class="s3">)]</span>
                <span class="s3">),</span>
                <span class="s1">python_schema</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">is_instance_schema</span><span class="s3">(</span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">Hashable</span><span class="s3">),</span>
            <span class="s3">),</span>
            <span class="s1">custom_error_type</span><span class="s3">=</span><span class="s5">'is_hashable'</span><span class="s3">,</span>
            <span class="s1">custom_error_message</span><span class="s3">=</span><span class="s5">'Input should be hashable'</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_dataclass_schema</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">dataclass</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">StandardDataclass</span><span class="s3">], </span><span class="s1">origin</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">StandardDataclass</span><span class="s3">] | </span><span class="s2">None</span>
    <span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generate schema for a dataclass.&quot;&quot;&quot;</span>
        <span class="s2">with </span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">model_type_stack</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">dataclass</span><span class="s3">),</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">.</span><span class="s1">get_schema_or_ref</span><span class="s3">(</span><span class="s1">dataclass</span><span class="s3">) </span><span class="s2">as </span><span class="s3">(</span>
                <span class="s1">dataclass_ref</span><span class="s3">,</span>
                <span class="s1">maybe_schema</span><span class="s3">,</span>
            <span class="s3">),</span>
        <span class="s3">):</span>
            <span class="s2">if </span><span class="s1">maybe_schema </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">maybe_schema</span>

            <span class="s1">schema </span><span class="s3">= </span><span class="s1">dataclass</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'__pydantic_core_schema__'</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">schema </span><span class="s2">is not None and not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">MockCoreSchema</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">schema</span><span class="s3">[</span><span class="s5">'type'</span><span class="s3">] == </span><span class="s5">'definitions'</span><span class="s3">:</span>
                    <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">.</span><span class="s1">unpack_definitions</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>
                <span class="s1">ref </span><span class="s3">= </span><span class="s1">get_ref</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">ref</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">.</span><span class="s1">create_definition_reference_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s1">schema</span>

            <span class="s1">typevars_map </span><span class="s3">= </span><span class="s1">get_standard_typevars_map</span><span class="s3">(</span><span class="s1">dataclass</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">origin </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">dataclass </span><span class="s3">= </span><span class="s1">origin</span>

            <span class="s6"># if (plain) dataclass doesn't have config, we use the parent's config, hence a default of `None`</span>
            <span class="s6"># (Pydantic dataclasses have an empty dict config by default).</span>
            <span class="s6"># see https://github.com/pydantic/pydantic/issues/10917</span>
            <span class="s1">config </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">dataclass</span><span class="s3">, </span><span class="s5">'__pydantic_config__'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

            <span class="s2">from </span><span class="s3">..</span><span class="s1">dataclasses </span><span class="s2">import </span><span class="s1">is_pydantic_dataclass</span>

            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ns_resolver</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">dataclass</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper_stack</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">config</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">is_pydantic_dataclass</span><span class="s3">(</span><span class="s1">dataclass</span><span class="s3">):</span>
                    <span class="s6"># Copy the field info instances to avoid mutating the `FieldInfo` instances</span>
                    <span class="s6"># of the generic dataclass generic origin (e.g. `apply_typevars_map` below).</span>
                    <span class="s6"># Note that we don't apply `deepcopy` on `__pydantic_fields__` because we</span>
                    <span class="s6"># don't want to copy the `FieldInfo` attributes:</span>
                    <span class="s1">fields </span><span class="s3">= {</span><span class="s1">f_name</span><span class="s3">: </span><span class="s1">copy</span><span class="s3">(</span><span class="s1">field_info</span><span class="s3">) </span><span class="s2">for </span><span class="s1">f_name</span><span class="s3">, </span><span class="s1">field_info </span><span class="s2">in </span><span class="s1">dataclass</span><span class="s3">.</span><span class="s1">__pydantic_fields__</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()}</span>
                    <span class="s2">if </span><span class="s1">typevars_map</span><span class="s3">:</span>
                        <span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s1">fields</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
                            <span class="s1">field</span><span class="s3">.</span><span class="s1">apply_typevars_map</span><span class="s3">(</span><span class="s1">typevars_map</span><span class="s3">, *</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_types_namespace</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">fields </span><span class="s3">= </span><span class="s1">collect_dataclass_fields</span><span class="s3">(</span>
                        <span class="s1">dataclass</span><span class="s3">,</span>
                        <span class="s1">typevars_map</span><span class="s3">=</span><span class="s1">typevars_map</span><span class="s3">,</span>
                        <span class="s1">config_wrapper</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper</span><span class="s3">,</span>
                    <span class="s3">)</span>

                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper</span><span class="s3">.</span><span class="s1">extra </span><span class="s3">== </span><span class="s5">'allow'</span><span class="s3">:</span>
                    <span class="s6"># disallow combination of init=False on a dataclass field and extra='allow' on a dataclass</span>
                    <span class="s2">for </span><span class="s1">field_name</span><span class="s3">, </span><span class="s1">field </span><span class="s2">in </span><span class="s1">fields</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                        <span class="s2">if </span><span class="s1">field</span><span class="s3">.</span><span class="s1">init </span><span class="s2">is False</span><span class="s3">:</span>
                            <span class="s2">raise </span><span class="s1">PydanticUserError</span><span class="s3">(</span>
                                <span class="s5">f'Field </span><span class="s2">{</span><span class="s1">field_name</span><span class="s2">} </span><span class="s5">has `init=False` and dataclass has config setting `extra=&quot;allow&quot;`. '</span>
                                <span class="s5">f'This combination is not allowed.'</span><span class="s3">,</span>
                                <span class="s1">code</span><span class="s3">=</span><span class="s5">'dataclass-init-false-extra-allow'</span><span class="s3">,</span>
                            <span class="s3">)</span>

                <span class="s1">decorators </span><span class="s3">= </span><span class="s1">dataclass</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'__pydantic_decorators__'</span><span class="s3">) </span><span class="s2">or </span><span class="s1">DecoratorInfos</span><span class="s3">.</span><span class="s1">build</span><span class="s3">(</span><span class="s1">dataclass</span><span class="s3">)</span>
                <span class="s6"># Move kw_only=False args to the start of the list, as this is how vanilla dataclasses work.</span>
                <span class="s6"># Note that when kw_only is missing or None, it is treated as equivalent to kw_only=True</span>
                <span class="s1">args </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">(</span>
                    <span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_dc_field_schema</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">decorators</span><span class="s3">) </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">fields</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()),</span>
                    <span class="s1">key</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">a</span><span class="s3">: </span><span class="s1">a</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'kw_only'</span><span class="s3">) </span><span class="s2">is not False</span><span class="s3">,</span>
                <span class="s3">)</span>
                <span class="s1">has_post_init </span><span class="s3">= </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">dataclass</span><span class="s3">, </span><span class="s5">'__post_init__'</span><span class="s3">)</span>
                <span class="s1">has_slots </span><span class="s3">= </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">dataclass</span><span class="s3">, </span><span class="s5">'__slots__'</span><span class="s3">)</span>

                <span class="s1">args_schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">dataclass_args_schema</span><span class="s3">(</span>
                    <span class="s1">dataclass</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">,</span>
                    <span class="s1">args</span><span class="s3">,</span>
                    <span class="s1">computed_fields</span><span class="s3">=[</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">_computed_field_schema</span><span class="s3">(</span><span class="s1">d</span><span class="s3">, </span><span class="s1">decorators</span><span class="s3">.</span><span class="s1">field_serializers</span><span class="s3">)</span>
                        <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">decorators</span><span class="s3">.</span><span class="s1">computed_fields</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()</span>
                    <span class="s3">],</span>
                    <span class="s1">collect_init_only</span><span class="s3">=</span><span class="s1">has_post_init</span><span class="s3">,</span>
                <span class="s3">)</span>

                <span class="s1">inner_schema </span><span class="s3">= </span><span class="s1">apply_validators</span><span class="s3">(</span><span class="s1">args_schema</span><span class="s3">, </span><span class="s1">decorators</span><span class="s3">.</span><span class="s1">root_validators</span><span class="s3">.</span><span class="s1">values</span><span class="s3">(), </span><span class="s2">None</span><span class="s3">)</span>

                <span class="s1">model_validators </span><span class="s3">= </span><span class="s1">decorators</span><span class="s3">.</span><span class="s1">model_validators</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()</span>
                <span class="s1">inner_schema </span><span class="s3">= </span><span class="s1">apply_model_validators</span><span class="s3">(</span><span class="s1">inner_schema</span><span class="s3">, </span><span class="s1">model_validators</span><span class="s3">, </span><span class="s5">'inner'</span><span class="s3">)</span>

                <span class="s1">core_config </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper</span><span class="s3">.</span><span class="s1">core_config</span><span class="s3">(</span><span class="s1">title</span><span class="s3">=</span><span class="s1">dataclass</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">)</span>

                <span class="s1">dc_schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">dataclass_schema</span><span class="s3">(</span>
                    <span class="s1">dataclass</span><span class="s3">,</span>
                    <span class="s1">inner_schema</span><span class="s3">,</span>
                    <span class="s1">generic_origin</span><span class="s3">=</span><span class="s1">origin</span><span class="s3">,</span>
                    <span class="s1">post_init</span><span class="s3">=</span><span class="s1">has_post_init</span><span class="s3">,</span>
                    <span class="s1">ref</span><span class="s3">=</span><span class="s1">dataclass_ref</span><span class="s3">,</span>
                    <span class="s1">fields</span><span class="s3">=[</span><span class="s1">field</span><span class="s3">.</span><span class="s1">name </span><span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s1">dataclasses</span><span class="s3">.</span><span class="s1">fields</span><span class="s3">(</span><span class="s1">dataclass</span><span class="s3">)],</span>
                    <span class="s1">slots</span><span class="s3">=</span><span class="s1">has_slots</span><span class="s3">,</span>
                    <span class="s1">config</span><span class="s3">=</span><span class="s1">core_config</span><span class="s3">,</span>
                    <span class="s6"># we don't use a custom __setattr__ for dataclasses, so we must</span>
                    <span class="s6"># pass along the frozen config setting to the pydantic-core schema</span>
                    <span class="s1">frozen</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper_stack</span><span class="s3">.</span><span class="s1">tail</span><span class="s3">.</span><span class="s1">frozen</span><span class="s3">,</span>
                <span class="s3">)</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_apply_model_serializers</span><span class="s3">(</span><span class="s1">dc_schema</span><span class="s3">, </span><span class="s1">decorators</span><span class="s3">.</span><span class="s1">model_serializers</span><span class="s3">.</span><span class="s1">values</span><span class="s3">())</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">apply_model_validators</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">model_validators</span><span class="s3">, </span><span class="s5">'outer'</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">.</span><span class="s1">create_definition_reference_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_call_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">function</span><span class="s3">: </span><span class="s1">ValidateCallSupportedTypes</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CallSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generate schema for a Callable. 
 
        TODO support functional validators once we support them in Config 
        &quot;&quot;&quot;</span>
        <span class="s1">arguments_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_arguments_schema</span><span class="s3">(</span><span class="s1">function</span><span class="s3">)</span>

        <span class="s1">return_schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">config_wrapper </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper</span>
        <span class="s2">if </span><span class="s1">config_wrapper</span><span class="s3">.</span><span class="s1">validate_return</span><span class="s3">:</span>
            <span class="s1">sig </span><span class="s3">= </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">function</span><span class="s3">)</span>
            <span class="s1">return_hint </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_annotation</span>
            <span class="s2">if </span><span class="s1">return_hint </span><span class="s2">is not </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">:</span>
                <span class="s1">globalns</span><span class="s3">, </span><span class="s1">localns </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_types_namespace</span>
                <span class="s1">type_hints </span><span class="s3">= </span><span class="s1">_typing_extra</span><span class="s3">.</span><span class="s1">get_function_type_hints</span><span class="s3">(</span>
                    <span class="s1">function</span><span class="s3">, </span><span class="s1">globalns</span><span class="s3">=</span><span class="s1">globalns</span><span class="s3">, </span><span class="s1">localns</span><span class="s3">=</span><span class="s1">localns</span><span class="s3">, </span><span class="s1">include_keys</span><span class="s3">={</span><span class="s5">'return'</span><span class="s3">}</span>
                <span class="s3">)</span>
                <span class="s1">return_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">type_hints</span><span class="s3">[</span><span class="s5">'return'</span><span class="s3">])</span>

        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">call_schema</span><span class="s3">(</span>
            <span class="s1">arguments_schema</span><span class="s3">,</span>
            <span class="s1">function</span><span class="s3">,</span>
            <span class="s1">return_schema</span><span class="s3">=</span><span class="s1">return_schema</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_arguments_schema</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">function</span><span class="s3">: </span><span class="s1">ValidateCallSupportedTypes</span><span class="s3">, </span><span class="s1">parameters_callback</span><span class="s3">: </span><span class="s1">ParametersCallback </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">ArgumentsSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generate schema for a Signature.&quot;&quot;&quot;</span>
        <span class="s1">mode_lookup</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">_ParameterKind</span><span class="s3">, </span><span class="s1">Literal</span><span class="s3">[</span><span class="s5">'positional_only'</span><span class="s3">, </span><span class="s5">'positional_or_keyword'</span><span class="s3">, </span><span class="s5">'keyword_only'</span><span class="s3">]] = {</span>
            <span class="s1">Parameter</span><span class="s3">.</span><span class="s1">POSITIONAL_ONLY</span><span class="s3">: </span><span class="s5">'positional_only'</span><span class="s3">,</span>
            <span class="s1">Parameter</span><span class="s3">.</span><span class="s1">POSITIONAL_OR_KEYWORD</span><span class="s3">: </span><span class="s5">'positional_or_keyword'</span><span class="s3">,</span>
            <span class="s1">Parameter</span><span class="s3">.</span><span class="s1">KEYWORD_ONLY</span><span class="s3">: </span><span class="s5">'keyword_only'</span><span class="s3">,</span>
        <span class="s3">}</span>

        <span class="s1">sig </span><span class="s3">= </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">function</span><span class="s3">)</span>
        <span class="s1">globalns</span><span class="s3">, </span><span class="s1">localns </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_types_namespace</span>
        <span class="s1">type_hints </span><span class="s3">= </span><span class="s1">_typing_extra</span><span class="s3">.</span><span class="s1">get_function_type_hints</span><span class="s3">(</span><span class="s1">function</span><span class="s3">, </span><span class="s1">globalns</span><span class="s3">=</span><span class="s1">globalns</span><span class="s3">, </span><span class="s1">localns</span><span class="s3">=</span><span class="s1">localns</span><span class="s3">)</span>

        <span class="s1">arguments_list</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">ArgumentsParameter</span><span class="s3">] = []</span>
        <span class="s1">var_args_schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">var_kwargs_schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">var_kwargs_mode</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">VarKwargsMode </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s2">for </span><span class="s1">i</span><span class="s3">, (</span><span class="s1">name</span><span class="s3">, </span><span class="s1">p</span><span class="s3">) </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">parameters</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()):</span>
            <span class="s2">if </span><span class="s1">p</span><span class="s3">.</span><span class="s1">annotation </span><span class="s2">is </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">:</span>
                <span class="s1">annotation </span><span class="s3">= </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">annotation </span><span class="s3">= </span><span class="s1">type_hints</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>

            <span class="s2">if </span><span class="s1">parameters_callback </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">result </span><span class="s3">= </span><span class="s1">parameters_callback</span><span class="s3">(</span><span class="s1">i</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">annotation</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">result </span><span class="s3">== </span><span class="s5">'skip'</span><span class="s3">:</span>
                    <span class="s2">continue</span>

            <span class="s1">parameter_mode </span><span class="s3">= </span><span class="s1">mode_lookup</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">p</span><span class="s3">.</span><span class="s1">kind</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">parameter_mode </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">arg_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_parameter_schema</span><span class="s3">(</span>
                    <span class="s1">name</span><span class="s3">, </span><span class="s1">annotation</span><span class="s3">, </span><span class="s1">AnnotationSource</span><span class="s3">.</span><span class="s1">FUNCTION</span><span class="s3">, </span><span class="s1">p</span><span class="s3">.</span><span class="s1">default</span><span class="s3">, </span><span class="s1">parameter_mode</span>
                <span class="s3">)</span>
                <span class="s1">arguments_list</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">arg_schema</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">p</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s1">Parameter</span><span class="s3">.</span><span class="s1">VAR_POSITIONAL</span><span class="s3">:</span>
                <span class="s1">var_args_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">annotation</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">assert </span><span class="s1">p</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s1">Parameter</span><span class="s3">.</span><span class="s1">VAR_KEYWORD</span><span class="s3">, </span><span class="s1">p</span><span class="s3">.</span><span class="s1">kind</span>

                <span class="s1">unpack_type </span><span class="s3">= </span><span class="s1">_typing_extra</span><span class="s3">.</span><span class="s1">unpack_type</span><span class="s3">(</span><span class="s1">annotation</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">unpack_type </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">origin </span><span class="s3">= </span><span class="s1">get_origin</span><span class="s3">(</span><span class="s1">unpack_type</span><span class="s3">) </span><span class="s2">or </span><span class="s1">unpack_type</span>
                    <span class="s2">if not </span><span class="s1">is_typeddict</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">):</span>
                        <span class="s2">raise </span><span class="s1">PydanticUserError</span><span class="s3">(</span>
                            <span class="s5">f'Expected a `TypedDict` class inside `Unpack[...]`, got </span><span class="s2">{</span><span class="s1">unpack_type</span><span class="s2">!r}</span><span class="s5">'</span><span class="s3">,</span>
                            <span class="s1">code</span><span class="s3">=</span><span class="s5">'unpack-typed-dict'</span><span class="s3">,</span>
                        <span class="s3">)</span>
                    <span class="s1">non_pos_only_param_names </span><span class="s3">= {</span>
                        <span class="s1">name </span><span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">p </span><span class="s2">in </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">parameters</span><span class="s3">.</span><span class="s1">items</span><span class="s3">() </span><span class="s2">if </span><span class="s1">p</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">!= </span><span class="s1">Parameter</span><span class="s3">.</span><span class="s1">POSITIONAL_ONLY</span>
                    <span class="s3">}</span>
                    <span class="s1">overlapping_params </span><span class="s3">= </span><span class="s1">non_pos_only_param_names</span><span class="s3">.</span><span class="s1">intersection</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">.</span><span class="s1">__annotations__</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">overlapping_params</span><span class="s3">:</span>
                        <span class="s2">raise </span><span class="s1">PydanticUserError</span><span class="s3">(</span>
                            <span class="s5">f'Typed dictionary </span><span class="s2">{</span><span class="s1">origin</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">!r} </span><span class="s5">overlaps with parameter'</span>
                            <span class="s5">f'</span><span class="s2">{</span><span class="s5">&quot;s&quot; </span><span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">overlapping_params</span><span class="s3">) &gt;= </span><span class="s4">2 </span><span class="s2">else </span><span class="s5">&quot;&quot;</span><span class="s2">} </span><span class="s5">'</span>
                            <span class="s5">f'</span><span class="s2">{</span><span class="s5">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">repr</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">overlapping_params</span><span class="s3">))</span><span class="s2">}</span><span class="s5">'</span><span class="s3">,</span>
                            <span class="s1">code</span><span class="s3">=</span><span class="s5">'overlapping-unpack-typed-dict'</span><span class="s3">,</span>
                        <span class="s3">)</span>

                    <span class="s1">var_kwargs_mode </span><span class="s3">= </span><span class="s5">'unpacked-typed-dict'</span>
                    <span class="s1">var_kwargs_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_typed_dict_schema</span><span class="s3">(</span><span class="s1">unpack_type</span><span class="s3">, </span><span class="s1">get_origin</span><span class="s3">(</span><span class="s1">unpack_type</span><span class="s3">))</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">var_kwargs_mode </span><span class="s3">= </span><span class="s5">'uniform'</span>
                    <span class="s1">var_kwargs_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">annotation</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">arguments_schema</span><span class="s3">(</span>
            <span class="s1">arguments_list</span><span class="s3">,</span>
            <span class="s1">var_args_schema</span><span class="s3">=</span><span class="s1">var_args_schema</span><span class="s3">,</span>
            <span class="s1">var_kwargs_mode</span><span class="s3">=</span><span class="s1">var_kwargs_mode</span><span class="s3">,</span>
            <span class="s1">var_kwargs_schema</span><span class="s3">=</span><span class="s1">var_kwargs_schema</span><span class="s3">,</span>
            <span class="s1">validate_by_name</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper</span><span class="s3">.</span><span class="s1">validate_by_name</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_arguments_v3_schema</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">function</span><span class="s3">: </span><span class="s1">ValidateCallSupportedTypes</span><span class="s3">, </span><span class="s1">parameters_callback</span><span class="s3">: </span><span class="s1">ParametersCallback </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">ArgumentsV3Schema</span><span class="s3">:</span>
        <span class="s1">mode_lookup</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span>
            <span class="s1">_ParameterKind</span><span class="s3">, </span><span class="s1">Literal</span><span class="s3">[</span><span class="s5">'positional_only'</span><span class="s3">, </span><span class="s5">'positional_or_keyword'</span><span class="s3">, </span><span class="s5">'var_args'</span><span class="s3">, </span><span class="s5">'keyword_only'</span><span class="s3">]</span>
        <span class="s3">] = {</span>
            <span class="s1">Parameter</span><span class="s3">.</span><span class="s1">POSITIONAL_ONLY</span><span class="s3">: </span><span class="s5">'positional_only'</span><span class="s3">,</span>
            <span class="s1">Parameter</span><span class="s3">.</span><span class="s1">POSITIONAL_OR_KEYWORD</span><span class="s3">: </span><span class="s5">'positional_or_keyword'</span><span class="s3">,</span>
            <span class="s1">Parameter</span><span class="s3">.</span><span class="s1">VAR_POSITIONAL</span><span class="s3">: </span><span class="s5">'var_args'</span><span class="s3">,</span>
            <span class="s1">Parameter</span><span class="s3">.</span><span class="s1">KEYWORD_ONLY</span><span class="s3">: </span><span class="s5">'keyword_only'</span><span class="s3">,</span>
        <span class="s3">}</span>

        <span class="s1">sig </span><span class="s3">= </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">function</span><span class="s3">)</span>
        <span class="s1">globalns</span><span class="s3">, </span><span class="s1">localns </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_types_namespace</span>
        <span class="s1">type_hints </span><span class="s3">= </span><span class="s1">_typing_extra</span><span class="s3">.</span><span class="s1">get_function_type_hints</span><span class="s3">(</span><span class="s1">function</span><span class="s3">, </span><span class="s1">globalns</span><span class="s3">=</span><span class="s1">globalns</span><span class="s3">, </span><span class="s1">localns</span><span class="s3">=</span><span class="s1">localns</span><span class="s3">)</span>

        <span class="s1">parameters_list</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">ArgumentsV3Parameter</span><span class="s3">] = []</span>

        <span class="s2">for </span><span class="s1">i</span><span class="s3">, (</span><span class="s1">name</span><span class="s3">, </span><span class="s1">p</span><span class="s3">) </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">parameters</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()):</span>
            <span class="s2">if </span><span class="s1">parameters_callback </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">result </span><span class="s3">= </span><span class="s1">parameters_callback</span><span class="s3">(</span><span class="s1">i</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">p</span><span class="s3">.</span><span class="s1">annotation</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">result </span><span class="s3">== </span><span class="s5">'skip'</span><span class="s3">:</span>
                    <span class="s2">continue</span>

            <span class="s2">if </span><span class="s1">p</span><span class="s3">.</span><span class="s1">annotation </span><span class="s2">is </span><span class="s1">Parameter</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">:</span>
                <span class="s1">annotation </span><span class="s3">= </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">annotation </span><span class="s3">= </span><span class="s1">type_hints</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>

            <span class="s1">parameter_mode </span><span class="s3">= </span><span class="s1">mode_lookup</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">p</span><span class="s3">.</span><span class="s1">kind</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">parameter_mode </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">assert </span><span class="s1">p</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s1">Parameter</span><span class="s3">.</span><span class="s1">VAR_KEYWORD</span><span class="s3">, </span><span class="s1">p</span><span class="s3">.</span><span class="s1">kind</span>

                <span class="s1">unpack_type </span><span class="s3">= </span><span class="s1">_typing_extra</span><span class="s3">.</span><span class="s1">unpack_type</span><span class="s3">(</span><span class="s1">annotation</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">unpack_type </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">origin </span><span class="s3">= </span><span class="s1">get_origin</span><span class="s3">(</span><span class="s1">unpack_type</span><span class="s3">) </span><span class="s2">or </span><span class="s1">unpack_type</span>
                    <span class="s2">if not </span><span class="s1">is_typeddict</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">):</span>
                        <span class="s2">raise </span><span class="s1">PydanticUserError</span><span class="s3">(</span>
                            <span class="s5">f'Expected a `TypedDict` class inside `Unpack[...]`, got </span><span class="s2">{</span><span class="s1">unpack_type</span><span class="s2">!r}</span><span class="s5">'</span><span class="s3">,</span>
                            <span class="s1">code</span><span class="s3">=</span><span class="s5">'unpack-typed-dict'</span><span class="s3">,</span>
                        <span class="s3">)</span>
                    <span class="s1">non_pos_only_param_names </span><span class="s3">= {</span>
                        <span class="s1">name </span><span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">p </span><span class="s2">in </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">parameters</span><span class="s3">.</span><span class="s1">items</span><span class="s3">() </span><span class="s2">if </span><span class="s1">p</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">!= </span><span class="s1">Parameter</span><span class="s3">.</span><span class="s1">POSITIONAL_ONLY</span>
                    <span class="s3">}</span>
                    <span class="s1">overlapping_params </span><span class="s3">= </span><span class="s1">non_pos_only_param_names</span><span class="s3">.</span><span class="s1">intersection</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">.</span><span class="s1">__annotations__</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">overlapping_params</span><span class="s3">:</span>
                        <span class="s2">raise </span><span class="s1">PydanticUserError</span><span class="s3">(</span>
                            <span class="s5">f'Typed dictionary </span><span class="s2">{</span><span class="s1">origin</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">!r} </span><span class="s5">overlaps with parameter'</span>
                            <span class="s5">f'</span><span class="s2">{</span><span class="s5">&quot;s&quot; </span><span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">overlapping_params</span><span class="s3">) &gt;= </span><span class="s4">2 </span><span class="s2">else </span><span class="s5">&quot;&quot;</span><span class="s2">} </span><span class="s5">'</span>
                            <span class="s5">f'</span><span class="s2">{</span><span class="s5">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">repr</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">overlapping_params</span><span class="s3">))</span><span class="s2">}</span><span class="s5">'</span><span class="s3">,</span>
                            <span class="s1">code</span><span class="s3">=</span><span class="s5">'overlapping-unpack-typed-dict'</span><span class="s3">,</span>
                        <span class="s3">)</span>
                    <span class="s1">parameter_mode </span><span class="s3">= </span><span class="s5">'var_kwargs_unpacked_typed_dict'</span>
                    <span class="s1">annotation </span><span class="s3">= </span><span class="s1">unpack_type</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">parameter_mode </span><span class="s3">= </span><span class="s5">'var_kwargs_uniform'</span>

            <span class="s1">parameters_list</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_parameter_v3_schema</span><span class="s3">(</span>
                    <span class="s1">name</span><span class="s3">, </span><span class="s1">annotation</span><span class="s3">, </span><span class="s1">AnnotationSource</span><span class="s3">.</span><span class="s1">FUNCTION</span><span class="s3">, </span><span class="s1">parameter_mode</span><span class="s3">, </span><span class="s1">default</span><span class="s3">=</span><span class="s1">p</span><span class="s3">.</span><span class="s1">default</span>
                <span class="s3">)</span>
            <span class="s3">)</span>

        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">arguments_v3_schema</span><span class="s3">(</span>
            <span class="s1">parameters_list</span><span class="s3">,</span>
            <span class="s1">validate_by_name</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper</span><span class="s3">.</span><span class="s1">validate_by_name</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_unsubstituted_typevar_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typevar</span><span class="s3">: </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">TypeVar</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">has_default </span><span class="s3">= </span><span class="s1">typevar</span><span class="s3">.</span><span class="s1">has_default</span><span class="s3">()</span>
        <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
            <span class="s6"># Happens if using `typing.TypeVar` (and not `typing_extensions`) on Python &lt; 3.13</span>
            <span class="s2">pass</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">has_default</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">typevar</span><span class="s3">.</span><span class="s1">__default__</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">constraints </span><span class="s3">:= </span><span class="s1">typevar</span><span class="s3">.</span><span class="s1">__constraints__</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_union_schema</span><span class="s3">(</span><span class="s1">typing</span><span class="s3">.</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">constraints</span><span class="s3">])</span>

        <span class="s2">if </span><span class="s1">bound </span><span class="s3">:= </span><span class="s1">typevar</span><span class="s3">.</span><span class="s1">__bound__</span><span class="s3">:</span>
            <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">bound</span><span class="s3">)</span>
            <span class="s1">schema</span><span class="s3">[</span><span class="s5">'serialization'</span><span class="s3">] = </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">wrap_serializer_function_ser_schema</span><span class="s3">(</span>
                <span class="s2">lambda </span><span class="s1">x</span><span class="s3">, </span><span class="s1">h</span><span class="s3">: </span><span class="s1">h</span><span class="s3">(</span><span class="s1">x</span><span class="s3">),</span>
                <span class="s1">schema</span><span class="s3">=</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">any_schema</span><span class="s3">(),</span>
            <span class="s3">)</span>
            <span class="s2">return </span><span class="s1">schema</span>

        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">any_schema</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_computed_field_schema</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">d</span><span class="s3">: </span><span class="s1">Decorator</span><span class="s3">[</span><span class="s1">ComputedFieldInfo</span><span class="s3">],</span>
        <span class="s1">field_serializers</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Decorator</span><span class="s3">[</span><span class="s1">FieldSerializerDecoratorInfo</span><span class="s3">]],</span>
    <span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">ComputedField</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">d</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">return_type </span><span class="s2">is not </span><span class="s1">PydanticUndefined</span><span class="s3">:</span>
            <span class="s1">return_type </span><span class="s3">= </span><span class="s1">d</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">return_type</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s6"># Do not pass in globals as the function could be defined in a different module.</span>
                <span class="s6"># Instead, let `get_callable_return_type` infer the globals to use, but still pass</span>
                <span class="s6"># in locals that may contain a parent/rebuild namespace:</span>
                <span class="s1">return_type </span><span class="s3">= </span><span class="s1">_decorators</span><span class="s3">.</span><span class="s1">get_callable_return_type</span><span class="s3">(</span><span class="s1">d</span><span class="s3">.</span><span class="s1">func</span><span class="s3">, </span><span class="s1">localns</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_types_namespace</span><span class="s3">.</span><span class="s1">locals</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">NameError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">PydanticUndefinedAnnotation</span><span class="s3">.</span><span class="s1">from_name_error</span><span class="s3">(</span><span class="s1">e</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>
        <span class="s2">if </span><span class="s1">return_type </span><span class="s2">is </span><span class="s1">PydanticUndefined</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">PydanticUserError</span><span class="s3">(</span>
                <span class="s5">'Computed field is missing return type annotation or specifying `return_type`'</span>
                <span class="s5">' to the `@computed_field` decorator (e.g. `@computed_field(return_type=int | str)`)'</span><span class="s3">,</span>
                <span class="s1">code</span><span class="s3">=</span><span class="s5">'model-field-missing-annotation'</span><span class="s3">,</span>
            <span class="s3">)</span>

        <span class="s1">return_type </span><span class="s3">= </span><span class="s1">replace_types</span><span class="s3">(</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_typevars_map</span><span class="s3">)</span>
        <span class="s6"># Create a new ComputedFieldInfo so that different type parametrizations of the same</span>
        <span class="s6"># generic model's computed field can have different return types.</span>
        <span class="s1">d</span><span class="s3">.</span><span class="s1">info </span><span class="s3">= </span><span class="s1">dataclasses</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">d</span><span class="s3">.</span><span class="s1">info</span><span class="s3">, </span><span class="s1">return_type</span><span class="s3">=</span><span class="s1">return_type</span><span class="s3">)</span>
        <span class="s1">return_type_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">return_type</span><span class="s3">)</span>
        <span class="s6"># Apply serializers to computed field if there exist</span>
        <span class="s1">return_type_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_apply_field_serializers</span><span class="s3">(</span>
            <span class="s1">return_type_schema</span><span class="s3">,</span>
            <span class="s1">filter_field_decorator_info_by_field</span><span class="s3">(</span><span class="s1">field_serializers</span><span class="s3">.</span><span class="s1">values</span><span class="s3">(), </span><span class="s1">d</span><span class="s3">.</span><span class="s1">cls_var_name</span><span class="s3">),</span>
        <span class="s3">)</span>

        <span class="s1">alias_generator </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper</span><span class="s3">.</span><span class="s1">alias_generator</span>
        <span class="s2">if </span><span class="s1">alias_generator </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_apply_alias_generator_to_computed_field_info</span><span class="s3">(</span>
                <span class="s1">alias_generator</span><span class="s3">=</span><span class="s1">alias_generator</span><span class="s3">, </span><span class="s1">computed_field_info</span><span class="s3">=</span><span class="s1">d</span><span class="s3">.</span><span class="s1">info</span><span class="s3">, </span><span class="s1">computed_field_name</span><span class="s3">=</span><span class="s1">d</span><span class="s3">.</span><span class="s1">cls_var_name</span>
            <span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_apply_field_title_generator_to_field_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper</span><span class="s3">, </span><span class="s1">d</span><span class="s3">.</span><span class="s1">info</span><span class="s3">, </span><span class="s1">d</span><span class="s3">.</span><span class="s1">cls_var_name</span><span class="s3">)</span>

        <span class="s1">pydantic_js_updates</span><span class="s3">, </span><span class="s1">pydantic_js_extra </span><span class="s3">= </span><span class="s1">_extract_json_schema_info_from_field_info</span><span class="s3">(</span><span class="s1">d</span><span class="s3">.</span><span class="s1">info</span><span class="s3">)</span>
        <span class="s1">core_metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] = {}</span>
        <span class="s1">update_core_metadata</span><span class="s3">(</span>
            <span class="s1">core_metadata</span><span class="s3">,</span>
            <span class="s1">pydantic_js_updates</span><span class="s3">={</span><span class="s5">'readOnly'</span><span class="s3">: </span><span class="s2">True</span><span class="s3">, **(</span><span class="s1">pydantic_js_updates </span><span class="s2">if </span><span class="s1">pydantic_js_updates </span><span class="s2">else </span><span class="s3">{})},</span>
            <span class="s1">pydantic_js_extra</span><span class="s3">=</span><span class="s1">pydantic_js_extra</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">computed_field</span><span class="s3">(</span>
            <span class="s1">d</span><span class="s3">.</span><span class="s1">cls_var_name</span><span class="s3">, </span><span class="s1">return_schema</span><span class="s3">=</span><span class="s1">return_type_schema</span><span class="s3">, </span><span class="s1">alias</span><span class="s3">=</span><span class="s1">d</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">alias</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">=</span><span class="s1">core_metadata</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_annotated_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">annotated_type</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generate schema for an Annotated type, e.g. `Annotated[int, Field(...)]` or `Annotated[int, Gt(0)]`.&quot;&quot;&quot;</span>
        <span class="s1">FieldInfo </span><span class="s3">= </span><span class="s1">import_cached_field_info</span><span class="s3">()</span>
        <span class="s1">source_type</span><span class="s3">, *</span><span class="s1">annotations </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_args_resolving_forward_refs</span><span class="s3">(</span>
            <span class="s1">annotated_type</span><span class="s3">,</span>
            <span class="s1">required</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_apply_annotations</span><span class="s3">(</span><span class="s1">source_type</span><span class="s3">, </span><span class="s1">annotations</span><span class="s3">)</span>
        <span class="s6"># put the default validator last so that TypeAdapter.get_default_value() works</span>
        <span class="s6"># even if there are function validators involved</span>
        <span class="s2">for </span><span class="s1">annotation </span><span class="s2">in </span><span class="s1">annotations</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">annotation</span><span class="s3">, </span><span class="s1">FieldInfo</span><span class="s3">):</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">wrap_default</span><span class="s3">(</span><span class="s1">annotation</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">schema</span>

    <span class="s2">def </span><span class="s1">_apply_annotations</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">source_type</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
        <span class="s1">annotations</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">],</span>
        <span class="s1">transform_inner_schema</span><span class="s3">: </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">CoreSchema</span><span class="s3">], </span><span class="s1">CoreSchema</span><span class="s3">] = </span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">x</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Apply arguments from `Annotated` or from `FieldInfo` to a schema. 
 
        This gets called by `GenerateSchema._annotated_schema` but differs from it in that it does 
        not expect `source_type` to be an `Annotated` object, it expects it to be  the first argument of that 
        (in other words, `GenerateSchema._annotated_schema` just unpacks `Annotated`, this process it). 
        &quot;&quot;&quot;</span>
        <span class="s1">annotations </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">_known_annotated_metadata</span><span class="s3">.</span><span class="s1">expand_grouped_metadata</span><span class="s3">(</span><span class="s1">annotations</span><span class="s3">))</span>

        <span class="s1">pydantic_js_annotation_functions</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">GetJsonSchemaFunction</span><span class="s3">] = []</span>

        <span class="s2">def </span><span class="s1">inner_handler</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:</span>
            <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_schema_from_get_schema_method</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">source_type</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">schema </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_schema_inner</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>

            <span class="s1">metadata_js_function </span><span class="s3">= </span><span class="s1">_extract_get_pydantic_json_schema</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">metadata_js_function </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">metadata_schema </span><span class="s3">= </span><span class="s1">resolve_original_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">metadata_schema </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">_add_js_function</span><span class="s3">(</span><span class="s1">metadata_schema</span><span class="s3">, </span><span class="s1">metadata_js_function</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">transform_inner_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>

        <span class="s1">get_inner_schema </span><span class="s3">= </span><span class="s1">CallbackGetCoreSchemaHandler</span><span class="s3">(</span><span class="s1">inner_handler</span><span class="s3">, </span><span class="s1">self</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">annotation </span><span class="s2">in </span><span class="s1">annotations</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">annotation </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">continue</span>
            <span class="s1">get_inner_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_wrapped_inner_schema</span><span class="s3">(</span>
                <span class="s1">get_inner_schema</span><span class="s3">, </span><span class="s1">annotation</span><span class="s3">, </span><span class="s1">pydantic_js_annotation_functions</span>
            <span class="s3">)</span>

        <span class="s1">schema </span><span class="s3">= </span><span class="s1">get_inner_schema</span><span class="s3">(</span><span class="s1">source_type</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">pydantic_js_annotation_functions</span><span class="s3">:</span>
            <span class="s1">core_metadata </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">setdefault</span><span class="s3">(</span><span class="s5">'metadata'</span><span class="s3">, {})</span>
            <span class="s1">update_core_metadata</span><span class="s3">(</span><span class="s1">core_metadata</span><span class="s3">, </span><span class="s1">pydantic_js_annotation_functions</span><span class="s3">=</span><span class="s1">pydantic_js_annotation_functions</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">_add_custom_serialization_from_json_encoders</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper</span><span class="s3">.</span><span class="s1">json_encoders</span><span class="s3">, </span><span class="s1">source_type</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_apply_single_annotation</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s1">FieldInfo </span><span class="s3">= </span><span class="s1">import_cached_field_info</span><span class="s3">()</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">FieldInfo</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">field_metadata </span><span class="s2">in </span><span class="s1">metadata</span><span class="s3">.</span><span class="s1">metadata</span><span class="s3">:</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_apply_single_annotation</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">field_metadata</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">metadata</span><span class="s3">.</span><span class="s1">discriminator </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_apply_discriminator_to_union</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">.</span><span class="s1">discriminator</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">schema</span>

        <span class="s2">if </span><span class="s1">schema</span><span class="s3">[</span><span class="s5">'type'</span><span class="s3">] == </span><span class="s5">'nullable'</span><span class="s3">:</span>
            <span class="s6"># for nullable schemas, metadata is automatically applied to the inner schema</span>
            <span class="s1">inner </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'schema'</span><span class="s3">, </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">any_schema</span><span class="s3">())</span>
            <span class="s1">inner </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_apply_single_annotation</span><span class="s3">(</span><span class="s1">inner</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">inner</span><span class="s3">:</span>
                <span class="s1">schema</span><span class="s3">[</span><span class="s5">'schema'</span><span class="s3">] = </span><span class="s1">inner</span>
            <span class="s2">return </span><span class="s1">schema</span>

        <span class="s1">original_schema </span><span class="s3">= </span><span class="s1">schema</span>
        <span class="s1">ref </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'ref'</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">ref </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">schema </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s1">new_ref </span><span class="s3">= </span><span class="s1">ref </span><span class="s3">+ </span><span class="s5">f'_</span><span class="s2">{</span><span class="s1">repr</span><span class="s3">(</span><span class="s1">metadata</span><span class="s3">)</span><span class="s2">}</span><span class="s5">'</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">existing </span><span class="s3">:= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">.</span><span class="s1">get_schema_from_ref</span><span class="s3">(</span><span class="s1">new_ref</span><span class="s3">)) </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">existing</span>
            <span class="s1">schema</span><span class="s3">[</span><span class="s5">'ref'</span><span class="s3">] = </span><span class="s1">new_ref  </span><span class="s6"># pyright: ignore[reportGeneralTypeIssues]</span>
        <span class="s2">elif </span><span class="s1">schema</span><span class="s3">[</span><span class="s5">'type'</span><span class="s3">] == </span><span class="s5">'definition-ref'</span><span class="s3">:</span>
            <span class="s1">ref </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">[</span><span class="s5">'schema_ref'</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">referenced_schema </span><span class="s3">:= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">.</span><span class="s1">get_schema_from_ref</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">)) </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">referenced_schema</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
                <span class="s1">new_ref </span><span class="s3">= </span><span class="s1">ref </span><span class="s3">+ </span><span class="s5">f'_</span><span class="s2">{</span><span class="s1">repr</span><span class="s3">(</span><span class="s1">metadata</span><span class="s3">)</span><span class="s2">}</span><span class="s5">'</span>
                <span class="s2">if </span><span class="s3">(</span><span class="s1">existing </span><span class="s3">:= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">.</span><span class="s1">get_schema_from_ref</span><span class="s3">(</span><span class="s1">new_ref</span><span class="s3">)) </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s1">existing</span>
                <span class="s1">schema</span><span class="s3">[</span><span class="s5">'ref'</span><span class="s3">] = </span><span class="s1">new_ref  </span><span class="s6"># pyright: ignore[reportGeneralTypeIssues]</span>

        <span class="s1">maybe_updated_schema </span><span class="s3">= </span><span class="s1">_known_annotated_metadata</span><span class="s3">.</span><span class="s1">apply_known_metadata</span><span class="s3">(</span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">maybe_updated_schema </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">maybe_updated_schema</span>
        <span class="s2">return </span><span class="s1">original_schema</span>

    <span class="s2">def </span><span class="s1">_apply_single_annotation_json_schema</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">: </span><span class="s1">Any</span>
    <span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s1">FieldInfo </span><span class="s3">= </span><span class="s1">import_cached_field_info</span><span class="s3">()</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">FieldInfo</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">field_metadata </span><span class="s2">in </span><span class="s1">metadata</span><span class="s3">.</span><span class="s1">metadata</span><span class="s3">:</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_apply_single_annotation_json_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">field_metadata</span><span class="s3">)</span>

            <span class="s1">pydantic_js_updates</span><span class="s3">, </span><span class="s1">pydantic_js_extra </span><span class="s3">= </span><span class="s1">_extract_json_schema_info_from_field_info</span><span class="s3">(</span><span class="s1">metadata</span><span class="s3">)</span>
            <span class="s1">core_metadata </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">setdefault</span><span class="s3">(</span><span class="s5">'metadata'</span><span class="s3">, {})</span>
            <span class="s1">update_core_metadata</span><span class="s3">(</span>
                <span class="s1">core_metadata</span><span class="s3">, </span><span class="s1">pydantic_js_updates</span><span class="s3">=</span><span class="s1">pydantic_js_updates</span><span class="s3">, </span><span class="s1">pydantic_js_extra</span><span class="s3">=</span><span class="s1">pydantic_js_extra</span>
            <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">schema</span>

    <span class="s2">def </span><span class="s1">_get_wrapped_inner_schema</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">get_inner_schema</span><span class="s3">: </span><span class="s1">GetCoreSchemaHandler</span><span class="s3">,</span>
        <span class="s1">annotation</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
        <span class="s1">pydantic_js_annotation_functions</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">GetJsonSchemaFunction</span><span class="s3">],</span>
    <span class="s3">) </span><span class="s1">-&gt; CallbackGetCoreSchemaHandler</span><span class="s3">:</span>
        <span class="s1">annotation_get_schema</span><span class="s3">: </span><span class="s1">GetCoreSchemaFunction </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">annotation</span><span class="s3">, </span><span class="s5">'__get_pydantic_core_schema__'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">new_handler</span><span class="s3">(</span><span class="s1">source</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">annotation_get_schema </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">annotation_get_schema</span><span class="s3">(</span><span class="s1">source</span><span class="s3">, </span><span class="s1">get_inner_schema</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">get_inner_schema</span><span class="s3">(</span><span class="s1">source</span><span class="s3">)</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_apply_single_annotation</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">annotation</span><span class="s3">)</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_apply_single_annotation_json_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">annotation</span><span class="s3">)</span>

            <span class="s1">metadata_js_function </span><span class="s3">= </span><span class="s1">_extract_get_pydantic_json_schema</span><span class="s3">(</span><span class="s1">annotation</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">metadata_js_function </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">pydantic_js_annotation_functions</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">metadata_js_function</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">schema</span>

        <span class="s2">return </span><span class="s1">CallbackGetCoreSchemaHandler</span><span class="s3">(</span><span class="s1">new_handler</span><span class="s3">, </span><span class="s1">self</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_apply_field_serializers</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">,</span>
        <span class="s1">serializers</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">Decorator</span><span class="s3">[</span><span class="s1">FieldSerializerDecoratorInfo</span><span class="s3">]],</span>
    <span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Apply field serializers to a schema.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">serializers</span><span class="s3">:</span>
            <span class="s1">schema </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">schema</span><span class="s3">[</span><span class="s5">'type'</span><span class="s3">] == </span><span class="s5">'definitions'</span><span class="s3">:</span>
                <span class="s1">inner_schema </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">[</span><span class="s5">'schema'</span><span class="s3">]</span>
                <span class="s1">schema</span><span class="s3">[</span><span class="s5">'schema'</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_apply_field_serializers</span><span class="s3">(</span><span class="s1">inner_schema</span><span class="s3">, </span><span class="s1">serializers</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">schema</span>
            <span class="s2">elif </span><span class="s5">'ref' </span><span class="s2">in </span><span class="s1">schema</span><span class="s3">:</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defs</span><span class="s3">.</span><span class="s1">create_definition_reference_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>

            <span class="s6"># use the last serializer to make it easy to override a serializer set on a parent model</span>
            <span class="s1">serializer </span><span class="s3">= </span><span class="s1">serializers</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
            <span class="s1">is_field_serializer</span><span class="s3">, </span><span class="s1">info_arg </span><span class="s3">= </span><span class="s1">inspect_field_serializer</span><span class="s3">(</span><span class="s1">serializer</span><span class="s3">.</span><span class="s1">func</span><span class="s3">, </span><span class="s1">serializer</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">mode</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">serializer</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">return_type </span><span class="s2">is not </span><span class="s1">PydanticUndefined</span><span class="s3">:</span>
                <span class="s1">return_type </span><span class="s3">= </span><span class="s1">serializer</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">return_type</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s6"># Do not pass in globals as the function could be defined in a different module.</span>
                    <span class="s6"># Instead, let `get_callable_return_type` infer the globals to use, but still pass</span>
                    <span class="s6"># in locals that may contain a parent/rebuild namespace:</span>
                    <span class="s1">return_type </span><span class="s3">= </span><span class="s1">_decorators</span><span class="s3">.</span><span class="s1">get_callable_return_type</span><span class="s3">(</span>
                        <span class="s1">serializer</span><span class="s3">.</span><span class="s1">func</span><span class="s3">, </span><span class="s1">localns</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_types_namespace</span><span class="s3">.</span><span class="s1">locals</span>
                    <span class="s3">)</span>
                <span class="s2">except </span><span class="s1">NameError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">PydanticUndefinedAnnotation</span><span class="s3">.</span><span class="s1">from_name_error</span><span class="s3">(</span><span class="s1">e</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>

            <span class="s2">if </span><span class="s1">return_type </span><span class="s2">is </span><span class="s1">PydanticUndefined</span><span class="s3">:</span>
                <span class="s1">return_schema </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">return_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">return_type</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">serializer</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s5">'wrap'</span><span class="s3">:</span>
                <span class="s1">schema</span><span class="s3">[</span><span class="s5">'serialization'</span><span class="s3">] = </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">wrap_serializer_function_ser_schema</span><span class="s3">(</span>
                    <span class="s1">serializer</span><span class="s3">.</span><span class="s1">func</span><span class="s3">,</span>
                    <span class="s1">is_field_serializer</span><span class="s3">=</span><span class="s1">is_field_serializer</span><span class="s3">,</span>
                    <span class="s1">info_arg</span><span class="s3">=</span><span class="s1">info_arg</span><span class="s3">,</span>
                    <span class="s1">return_schema</span><span class="s3">=</span><span class="s1">return_schema</span><span class="s3">,</span>
                    <span class="s1">when_used</span><span class="s3">=</span><span class="s1">serializer</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">when_used</span><span class="s3">,</span>
                <span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">assert </span><span class="s1">serializer</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s5">'plain'</span>
                <span class="s1">schema</span><span class="s3">[</span><span class="s5">'serialization'</span><span class="s3">] = </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">plain_serializer_function_ser_schema</span><span class="s3">(</span>
                    <span class="s1">serializer</span><span class="s3">.</span><span class="s1">func</span><span class="s3">,</span>
                    <span class="s1">is_field_serializer</span><span class="s3">=</span><span class="s1">is_field_serializer</span><span class="s3">,</span>
                    <span class="s1">info_arg</span><span class="s3">=</span><span class="s1">info_arg</span><span class="s3">,</span>
                    <span class="s1">return_schema</span><span class="s3">=</span><span class="s1">return_schema</span><span class="s3">,</span>
                    <span class="s1">when_used</span><span class="s3">=</span><span class="s1">serializer</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">when_used</span><span class="s3">,</span>
                <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">schema</span>

    <span class="s2">def </span><span class="s1">_apply_model_serializers</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">, </span><span class="s1">serializers</span><span class="s3">: </span><span class="s1">Iterable</span><span class="s3">[</span><span class="s1">Decorator</span><span class="s3">[</span><span class="s1">ModelSerializerDecoratorInfo</span><span class="s3">]]</span>
    <span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Apply model serializers to a schema.&quot;&quot;&quot;</span>
        <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">'ref'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)  </span><span class="s6"># type: ignore</span>
        <span class="s2">if </span><span class="s1">serializers</span><span class="s3">:</span>
            <span class="s1">serializer </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">serializers</span><span class="s3">)[-</span><span class="s4">1</span><span class="s3">]</span>
            <span class="s1">info_arg </span><span class="s3">= </span><span class="s1">inspect_model_serializer</span><span class="s3">(</span><span class="s1">serializer</span><span class="s3">.</span><span class="s1">func</span><span class="s3">, </span><span class="s1">serializer</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">mode</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">serializer</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">return_type </span><span class="s2">is not </span><span class="s1">PydanticUndefined</span><span class="s3">:</span>
                <span class="s1">return_type </span><span class="s3">= </span><span class="s1">serializer</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">return_type</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s6"># Do not pass in globals as the function could be defined in a different module.</span>
                    <span class="s6"># Instead, let `get_callable_return_type` infer the globals to use, but still pass</span>
                    <span class="s6"># in locals that may contain a parent/rebuild namespace:</span>
                    <span class="s1">return_type </span><span class="s3">= </span><span class="s1">_decorators</span><span class="s3">.</span><span class="s1">get_callable_return_type</span><span class="s3">(</span>
                        <span class="s1">serializer</span><span class="s3">.</span><span class="s1">func</span><span class="s3">, </span><span class="s1">localns</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_types_namespace</span><span class="s3">.</span><span class="s1">locals</span>
                    <span class="s3">)</span>
                <span class="s2">except </span><span class="s1">NameError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">PydanticUndefinedAnnotation</span><span class="s3">.</span><span class="s1">from_name_error</span><span class="s3">(</span><span class="s1">e</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>

            <span class="s2">if </span><span class="s1">return_type </span><span class="s2">is </span><span class="s1">PydanticUndefined</span><span class="s3">:</span>
                <span class="s1">return_schema </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">return_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_schema</span><span class="s3">(</span><span class="s1">return_type</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">serializer</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s5">'wrap'</span><span class="s3">:</span>
                <span class="s1">ser_schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">SerSchema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">wrap_serializer_function_ser_schema</span><span class="s3">(</span>
                    <span class="s1">serializer</span><span class="s3">.</span><span class="s1">func</span><span class="s3">,</span>
                    <span class="s1">info_arg</span><span class="s3">=</span><span class="s1">info_arg</span><span class="s3">,</span>
                    <span class="s1">return_schema</span><span class="s3">=</span><span class="s1">return_schema</span><span class="s3">,</span>
                    <span class="s1">when_used</span><span class="s3">=</span><span class="s1">serializer</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">when_used</span><span class="s3">,</span>
                <span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s6"># plain</span>
                <span class="s1">ser_schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">plain_serializer_function_ser_schema</span><span class="s3">(</span>
                    <span class="s1">serializer</span><span class="s3">.</span><span class="s1">func</span><span class="s3">,</span>
                    <span class="s1">info_arg</span><span class="s3">=</span><span class="s1">info_arg</span><span class="s3">,</span>
                    <span class="s1">return_schema</span><span class="s3">=</span><span class="s1">return_schema</span><span class="s3">,</span>
                    <span class="s1">when_used</span><span class="s3">=</span><span class="s1">serializer</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">when_used</span><span class="s3">,</span>
                <span class="s3">)</span>
            <span class="s1">schema</span><span class="s3">[</span><span class="s5">'serialization'</span><span class="s3">] = </span><span class="s1">ser_schema</span>
        <span class="s2">if </span><span class="s1">ref</span><span class="s3">:</span>
            <span class="s1">schema</span><span class="s3">[</span><span class="s5">'ref'</span><span class="s3">] = </span><span class="s1">ref  </span><span class="s6"># type: ignore</span>
        <span class="s2">return </span><span class="s1">schema</span>


<span class="s1">_VALIDATOR_F_MATCH</span><span class="s3">: </span><span class="s1">Mapping</span><span class="s3">[</span>
    <span class="s1">tuple</span><span class="s3">[</span><span class="s1">FieldValidatorModes</span><span class="s3">, </span><span class="s1">Literal</span><span class="s3">[</span><span class="s5">'no-info'</span><span class="s3">, </span><span class="s5">'with-info'</span><span class="s3">]],</span>
    <span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Callable</span><span class="s3">[..., </span><span class="s1">Any</span><span class="s3">], </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">, </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None</span><span class="s3">], </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">],</span>
<span class="s3">] = {</span>
    <span class="s3">(</span><span class="s5">'before'</span><span class="s3">, </span><span class="s5">'no-info'</span><span class="s3">): </span><span class="s2">lambda </span><span class="s1">f</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">_</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">no_info_before_validator_function</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s5">'after'</span><span class="s3">, </span><span class="s5">'no-info'</span><span class="s3">): </span><span class="s2">lambda </span><span class="s1">f</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">_</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">no_info_after_validator_function</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s5">'plain'</span><span class="s3">, </span><span class="s5">'no-info'</span><span class="s3">): </span><span class="s2">lambda </span><span class="s1">f</span><span class="s3">, </span><span class="s1">_1</span><span class="s3">, </span><span class="s1">_2</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">no_info_plain_validator_function</span><span class="s3">(</span><span class="s1">f</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s5">'wrap'</span><span class="s3">, </span><span class="s5">'no-info'</span><span class="s3">): </span><span class="s2">lambda </span><span class="s1">f</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">_</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">no_info_wrap_validator_function</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s5">'before'</span><span class="s3">, </span><span class="s5">'with-info'</span><span class="s3">): </span><span class="s2">lambda </span><span class="s1">f</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">with_info_before_validator_function</span><span class="s3">(</span>
        <span class="s1">f</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">=</span><span class="s1">field_name</span>
    <span class="s3">),</span>
    <span class="s3">(</span><span class="s5">'after'</span><span class="s3">, </span><span class="s5">'with-info'</span><span class="s3">): </span><span class="s2">lambda </span><span class="s1">f</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">with_info_after_validator_function</span><span class="s3">(</span>
        <span class="s1">f</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">=</span><span class="s1">field_name</span>
    <span class="s3">),</span>
    <span class="s3">(</span><span class="s5">'plain'</span><span class="s3">, </span><span class="s5">'with-info'</span><span class="s3">): </span><span class="s2">lambda </span><span class="s1">f</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">with_info_plain_validator_function</span><span class="s3">(</span>
        <span class="s1">f</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">=</span><span class="s1">field_name</span>
    <span class="s3">),</span>
    <span class="s3">(</span><span class="s5">'wrap'</span><span class="s3">, </span><span class="s5">'with-info'</span><span class="s3">): </span><span class="s2">lambda </span><span class="s1">f</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">with_info_wrap_validator_function</span><span class="s3">(</span>
        <span class="s1">f</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">=</span><span class="s1">field_name</span>
    <span class="s3">),</span>
<span class="s3">}</span>


<span class="s6"># TODO V3: this function is only used for deprecated decorators. It should</span>
<span class="s6"># be removed once we drop support for those.</span>
<span class="s2">def </span><span class="s1">apply_validators</span><span class="s3">(</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s1">validators</span><span class="s3">: </span><span class="s1">Iterable</span><span class="s3">[</span><span class="s1">Decorator</span><span class="s3">[</span><span class="s1">RootValidatorDecoratorInfo</span><span class="s3">]]</span>
    <span class="s3">| </span><span class="s1">Iterable</span><span class="s3">[</span><span class="s1">Decorator</span><span class="s3">[</span><span class="s1">ValidatorDecoratorInfo</span><span class="s3">]]</span>
    <span class="s3">| </span><span class="s1">Iterable</span><span class="s3">[</span><span class="s1">Decorator</span><span class="s3">[</span><span class="s1">FieldValidatorDecoratorInfo</span><span class="s3">]],</span>
    <span class="s1">field_name</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Apply validators to a schema. 
 
    Args: 
        schema: The schema to apply validators on. 
        validators: An iterable of validators. 
        field_name: The name of the field if validators are being applied to a model field. 
 
    Returns: 
        The updated schema. 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">validator </span><span class="s2">in </span><span class="s1">validators</span><span class="s3">:</span>
        <span class="s1">info_arg </span><span class="s3">= </span><span class="s1">inspect_validator</span><span class="s3">(</span><span class="s1">validator</span><span class="s3">.</span><span class="s1">func</span><span class="s3">, </span><span class="s1">validator</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">mode</span><span class="s3">)</span>
        <span class="s1">val_type </span><span class="s3">= </span><span class="s5">'with-info' </span><span class="s2">if </span><span class="s1">info_arg </span><span class="s2">else </span><span class="s5">'no-info'</span>

        <span class="s1">schema </span><span class="s3">= </span><span class="s1">_VALIDATOR_F_MATCH</span><span class="s3">[(</span><span class="s1">validator</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">val_type</span><span class="s3">)](</span><span class="s1">validator</span><span class="s3">.</span><span class="s1">func</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">schema</span>


<span class="s2">def </span><span class="s1">_validators_require_validate_default</span><span class="s3">(</span><span class="s1">validators</span><span class="s3">: </span><span class="s1">Iterable</span><span class="s3">[</span><span class="s1">Decorator</span><span class="s3">[</span><span class="s1">ValidatorDecoratorInfo</span><span class="s3">]]) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;In v1, if any of the validators for a field had `always=True`, the default value would be validated. 
 
    This serves as an auxiliary function for re-implementing that logic, by looping over a provided 
    collection of (v1-style) ValidatorDecoratorInfo's and checking if any of them have `always=True`. 
 
    We should be able to drop this function and the associated logic calling it once we drop support 
    for v1-style validator decorators. (Or we can extend it and keep it if we add something equivalent 
    to the v1-validator `always` kwarg to `field_validator`.) 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">validator </span><span class="s2">in </span><span class="s1">validators</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">validator</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">always</span><span class="s3">:</span>
            <span class="s2">return True</span>
    <span class="s2">return False</span>


<span class="s2">def </span><span class="s1">apply_model_validators</span><span class="s3">(</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s1">validators</span><span class="s3">: </span><span class="s1">Iterable</span><span class="s3">[</span><span class="s1">Decorator</span><span class="s3">[</span><span class="s1">ModelValidatorDecoratorInfo</span><span class="s3">]],</span>
    <span class="s1">mode</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s5">'inner'</span><span class="s3">, </span><span class="s5">'outer'</span><span class="s3">, </span><span class="s5">'all'</span><span class="s3">],</span>
<span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Apply model validators to a schema. 
 
    If mode == 'inner', only &quot;before&quot; validators are applied 
    If mode == 'outer', validators other than &quot;before&quot; are applied 
    If mode == 'all', all validators are applied 
 
    Args: 
        schema: The schema to apply validators on. 
        validators: An iterable of validators. 
        mode: The validator mode. 
 
    Returns: 
        The updated schema. 
    &quot;&quot;&quot;</span>
    <span class="s1">ref</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">'ref'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)  </span><span class="s6"># type: ignore</span>
    <span class="s2">for </span><span class="s1">validator </span><span class="s2">in </span><span class="s1">validators</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">mode </span><span class="s3">== </span><span class="s5">'inner' </span><span class="s2">and </span><span class="s1">validator</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">!= </span><span class="s5">'before'</span><span class="s3">:</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">mode </span><span class="s3">== </span><span class="s5">'outer' </span><span class="s2">and </span><span class="s1">validator</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s5">'before'</span><span class="s3">:</span>
            <span class="s2">continue</span>
        <span class="s1">info_arg </span><span class="s3">= </span><span class="s1">inspect_validator</span><span class="s3">(</span><span class="s1">validator</span><span class="s3">.</span><span class="s1">func</span><span class="s3">, </span><span class="s1">validator</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">mode</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">validator</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s5">'wrap'</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">info_arg</span><span class="s3">:</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">with_info_wrap_validator_function</span><span class="s3">(</span><span class="s1">function</span><span class="s3">=</span><span class="s1">validator</span><span class="s3">.</span><span class="s1">func</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">no_info_wrap_validator_function</span><span class="s3">(</span><span class="s1">function</span><span class="s3">=</span><span class="s1">validator</span><span class="s3">.</span><span class="s1">func</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">validator</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s5">'before'</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">info_arg</span><span class="s3">:</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">with_info_before_validator_function</span><span class="s3">(</span><span class="s1">function</span><span class="s3">=</span><span class="s1">validator</span><span class="s3">.</span><span class="s1">func</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">no_info_before_validator_function</span><span class="s3">(</span><span class="s1">function</span><span class="s3">=</span><span class="s1">validator</span><span class="s3">.</span><span class="s1">func</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">validator</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s5">'after'</span>
            <span class="s2">if </span><span class="s1">info_arg</span><span class="s3">:</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">with_info_after_validator_function</span><span class="s3">(</span><span class="s1">function</span><span class="s3">=</span><span class="s1">validator</span><span class="s3">.</span><span class="s1">func</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">no_info_after_validator_function</span><span class="s3">(</span><span class="s1">function</span><span class="s3">=</span><span class="s1">validator</span><span class="s3">.</span><span class="s1">func</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">ref</span><span class="s3">:</span>
        <span class="s1">schema</span><span class="s3">[</span><span class="s5">'ref'</span><span class="s3">] = </span><span class="s1">ref  </span><span class="s6"># type: ignore</span>
    <span class="s2">return </span><span class="s1">schema</span>


<span class="s2">def </span><span class="s1">wrap_default</span><span class="s3">(</span><span class="s1">field_info</span><span class="s3">: </span><span class="s1">FieldInfo</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Wrap schema with default schema if default value or `default_factory` are available. 
 
    Args: 
        field_info: The field info object. 
        schema: The schema to apply default on. 
 
    Returns: 
        Updated schema by default value or `default_factory`. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">default_factory</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">with_default_schema</span><span class="s3">(</span>
            <span class="s1">schema</span><span class="s3">,</span>
            <span class="s1">default_factory</span><span class="s3">=</span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">default_factory</span><span class="s3">,</span>
            <span class="s1">default_factory_takes_data</span><span class="s3">=</span><span class="s1">takes_validated_data_argument</span><span class="s3">(</span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">default_factory</span><span class="s3">),</span>
            <span class="s1">validate_default</span><span class="s3">=</span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">validate_default</span><span class="s3">,</span>
        <span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">default </span><span class="s2">is not </span><span class="s1">PydanticUndefined</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">with_default_schema</span><span class="s3">(</span>
            <span class="s1">schema</span><span class="s3">, </span><span class="s1">default</span><span class="s3">=</span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">default</span><span class="s3">, </span><span class="s1">validate_default</span><span class="s3">=</span><span class="s1">field_info</span><span class="s3">.</span><span class="s1">validate_default</span>
        <span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">schema</span>


<span class="s2">def </span><span class="s1">_extract_get_pydantic_json_schema</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; GetJsonSchemaFunction </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Extract `__get_pydantic_json_schema__` from a type, handling the deprecated `__modify_schema__`.&quot;&quot;&quot;</span>
    <span class="s1">js_modify_function </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s5">'__get_pydantic_json_schema__'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s5">'__modify_schema__'</span><span class="s3">):</span>
        <span class="s1">BaseModel </span><span class="s3">= </span><span class="s1">import_cached_base_model</span><span class="s3">()</span>

        <span class="s1">has_custom_v2_modify_js_func </span><span class="s3">= (</span>
            <span class="s1">js_modify_function </span><span class="s2">is not None</span>
            <span class="s2">and </span><span class="s1">BaseModel</span><span class="s3">.</span><span class="s1">__get_pydantic_json_schema__</span><span class="s3">.</span><span class="s1">__func__  </span><span class="s6"># type: ignore</span>
            <span class="s2">not in </span><span class="s3">(</span><span class="s1">js_modify_function</span><span class="s3">, </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">js_modify_function</span><span class="s3">, </span><span class="s5">'__func__'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">))</span>
        <span class="s3">)</span>

        <span class="s2">if not </span><span class="s1">has_custom_v2_modify_js_func</span><span class="s3">:</span>
            <span class="s1">cls_name </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s5">'__name__'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">PydanticUserError</span><span class="s3">(</span>
                <span class="s5">f'The `__modify_schema__` method is not supported in Pydantic v2. '</span>
                <span class="s5">f'Use `__get_pydantic_json_schema__` instead</span><span class="s2">{</span><span class="s5">f&quot; in class `</span><span class="s2">{</span><span class="s1">cls_name</span><span class="s2">}</span><span class="s5">`&quot; </span><span class="s2">if </span><span class="s1">cls_name </span><span class="s2">else </span><span class="s5">&quot;&quot;</span><span class="s2">}</span><span class="s5">.'</span><span class="s3">,</span>
                <span class="s1">code</span><span class="s3">=</span><span class="s5">'custom-json-schema'</span><span class="s3">,</span>
            <span class="s3">)</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">origin </span><span class="s3">:= </span><span class="s1">get_origin</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)) </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s6"># Generic aliases proxy attribute access to the origin, *except* dunder attributes,</span>
        <span class="s6"># such as `__get_pydantic_json_schema__`, hence the explicit check.</span>
        <span class="s2">return </span><span class="s1">_extract_get_pydantic_json_schema</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">js_modify_function </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return None</span>

    <span class="s2">return </span><span class="s1">js_modify_function</span>


<span class="s2">class </span><span class="s1">_CommonField</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">):</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span>
    <span class="s1">validation_alias</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s1">list</span><span class="s3">[</span><span class="s1">str </span><span class="s3">| </span><span class="s1">int</span><span class="s3">] | </span><span class="s1">list</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">str </span><span class="s3">| </span><span class="s1">int</span><span class="s3">]] | </span><span class="s2">None</span>
    <span class="s1">serialization_alias</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None</span>
    <span class="s1">serialization_exclude</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None</span>
    <span class="s1">frozen</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">_common_field</span><span class="s3">(</span>
    <span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">validation_alias</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s1">list</span><span class="s3">[</span><span class="s1">str </span><span class="s3">| </span><span class="s1">int</span><span class="s3">] | </span><span class="s1">list</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">str </span><span class="s3">| </span><span class="s1">int</span><span class="s3">]] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization_alias</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">serialization_exclude</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">frozen</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">: </span><span class="s1">Any </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; _CommonField</span><span class="s3">:</span>
    <span class="s2">return </span><span class="s3">{</span>
        <span class="s5">'schema'</span><span class="s3">: </span><span class="s1">schema</span><span class="s3">,</span>
        <span class="s5">'validation_alias'</span><span class="s3">: </span><span class="s1">validation_alias</span><span class="s3">,</span>
        <span class="s5">'serialization_alias'</span><span class="s3">: </span><span class="s1">serialization_alias</span><span class="s3">,</span>
        <span class="s5">'serialization_exclude'</span><span class="s3">: </span><span class="s1">serialization_exclude</span><span class="s3">,</span>
        <span class="s5">'frozen'</span><span class="s3">: </span><span class="s1">frozen</span><span class="s3">,</span>
        <span class="s5">'metadata'</span><span class="s3">: </span><span class="s1">metadata</span><span class="s3">,</span>
    <span class="s3">}</span>


<span class="s2">def </span><span class="s1">resolve_original_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">, </span><span class="s1">definitions</span><span class="s3">: </span><span class="s1">_Definitions</span><span class="s3">) </span><span class="s1">-&gt; CoreSchema </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
    <span class="s2">if </span><span class="s1">schema</span><span class="s3">[</span><span class="s5">'type'</span><span class="s3">] == </span><span class="s5">'definition-ref'</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">definitions</span><span class="s3">.</span><span class="s1">get_schema_from_ref</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s5">'schema_ref'</span><span class="s3">])</span>
    <span class="s2">elif </span><span class="s1">schema</span><span class="s3">[</span><span class="s5">'type'</span><span class="s3">] == </span><span class="s5">'definitions'</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">schema</span><span class="s3">[</span><span class="s5">'schema'</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">schema</span>


<span class="s2">def </span><span class="s1">_inlining_behavior</span><span class="s3">(</span>
    <span class="s1">def_ref</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">DefinitionReferenceSchema</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; Literal</span><span class="s3">[</span><span class="s5">'inline'</span><span class="s3">, </span><span class="s5">'keep'</span><span class="s3">, </span><span class="s5">'preserve_metadata'</span><span class="s3">]:</span>
    <span class="s0">&quot;&quot;&quot;Determine the inlining behavior of the `'definition-ref'` schema. 
 
    - If no `'serialization'` schema and no metadata is attached, the schema can safely be inlined. 
    - If it has metadata but only related to the deferred discriminator application, it can be inlined 
      provided that such metadata is kept. 
    - Otherwise, the schema should not be inlined. Doing so would remove the `'serialization'` schema or metadata. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s5">'serialization' </span><span class="s2">in </span><span class="s1">def_ref</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s5">'keep'</span>
    <span class="s1">metadata </span><span class="s3">= </span><span class="s1">def_ref</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'metadata'</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">metadata</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s5">'inline'</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">metadata</span><span class="s3">) == </span><span class="s4">1 </span><span class="s2">and </span><span class="s5">'pydantic_internal_union_discriminator' </span><span class="s2">in </span><span class="s1">metadata</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s5">'preserve_metadata'</span>
    <span class="s2">return </span><span class="s5">'keep'</span>


<span class="s2">class </span><span class="s1">_Definitions</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Keeps track of references and definitions.&quot;&quot;&quot;</span>

    <span class="s1">_recursively_seen</span><span class="s3">: </span><span class="s1">set</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]</span>
    <span class="s5">&quot;&quot;&quot;A set of recursively seen references. 
 
    When a referenceable type is encountered, the `get_schema_or_ref` context manager is 
    entered to compute the reference. If the type references itself by some way (e.g. for 
    a dataclass a Pydantic model, the class can be referenced as a field annotation), 
    entering the context manager again will yield a `'definition-ref'` schema that should 
    short-circuit the normal generation process, as the reference was already in this set. 
    &quot;&quot;&quot;</span>

    <span class="s1">_definitions</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">]</span>
    <span class="s5">&quot;&quot;&quot;A mapping of references to their corresponding schema. 
 
    When a schema for a referenceable type is generated, it is stored in this mapping. If the 
    same type is encountered again, the reference is yielded by the `get_schema_or_ref` context 
    manager. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_recursively_seen </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_definitions </span><span class="s3">= {}</span>

    <span class="s3">@</span><span class="s1">contextmanager</span>
    <span class="s2">def </span><span class="s1">get_schema_or_ref</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, /) </span><span class="s1">-&gt; Generator</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">DefinitionReferenceSchema </span><span class="s3">| </span><span class="s2">None</span><span class="s3">]]:</span>
        <span class="s0">&quot;&quot;&quot;Get a definition for `tp` if one exists. 
 
        If a definition exists, a tuple of `(ref_string, CoreSchema)` is returned. 
        If no definition exists yet, a tuple of `(ref_string, None)` is returned. 
 
        Note that the returned `CoreSchema` will always be a `DefinitionReferenceSchema`, 
        not the actual definition itself. 
 
        This should be called for any type that can be identified by reference. 
        This includes any recursive types. 
 
        At present the following types can be named/recursive: 
 
        - Pydantic model 
        - Pydantic and stdlib dataclasses 
        - Typed dictionaries 
        - Named tuples 
        - `TypeAliasType` instances 
        - Enums 
        &quot;&quot;&quot;</span>
        <span class="s1">ref </span><span class="s3">= </span><span class="s1">get_type_ref</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>
        <span class="s6"># return the reference if we're either (1) in a cycle or (2) it the reference was already encountered:</span>
        <span class="s2">if </span><span class="s1">ref </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_recursively_seen </span><span class="s2">or </span><span class="s1">ref </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_definitions</span><span class="s3">:</span>
            <span class="s2">yield </span><span class="s3">(</span><span class="s1">ref</span><span class="s3">, </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">definition_reference_schema</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_recursively_seen</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">)</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s2">yield </span><span class="s3">(</span><span class="s1">ref</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s2">finally</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_recursively_seen</span><span class="s3">.</span><span class="s1">discard</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_schema_from_ref</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; CoreSchema </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Resolve the schema from the given reference.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_definitions</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">create_definition_reference_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">) </span><span class="s1">-&gt; core_schema</span><span class="s3">.</span><span class="s1">DefinitionReferenceSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Store the schema as a definition and return a `'definition-reference'` schema pointing to it. 
 
        The schema must have a reference attached to it. 
        &quot;&quot;&quot;</span>
        <span class="s1">ref </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">[</span><span class="s5">'ref'</span><span class="s3">]  </span><span class="s6"># pyright: ignore</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_definitions</span><span class="s3">[</span><span class="s1">ref</span><span class="s3">] = </span><span class="s1">schema</span>
        <span class="s2">return </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">definition_reference_schema</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">unpack_definitions</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">DefinitionsSchema</span><span class="s3">) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Store the definitions of the `'definitions'` core schema and return the inner core schema.&quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">def_schema </span><span class="s2">in </span><span class="s1">schema</span><span class="s3">[</span><span class="s5">'definitions'</span><span class="s3">]:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_definitions</span><span class="s3">[</span><span class="s1">def_schema</span><span class="s3">[</span><span class="s5">'ref'</span><span class="s3">]] = </span><span class="s1">def_schema  </span><span class="s6"># pyright: ignore</span>
        <span class="s2">return </span><span class="s1">schema</span><span class="s3">[</span><span class="s5">'schema'</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">finalize_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Finalize the core schema. 
 
        This traverses the core schema and referenced definitions, replaces `'definition-ref'` schemas 
        by the referenced definition if possible, and applies deferred discriminators. 
        &quot;&quot;&quot;</span>
        <span class="s1">definitions </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_definitions</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">gather_result </span><span class="s3">= </span><span class="s1">gather_schemas_for_cleaning</span><span class="s3">(</span>
                <span class="s1">schema</span><span class="s3">,</span>
                <span class="s1">definitions</span><span class="s3">=</span><span class="s1">definitions</span><span class="s3">,</span>
            <span class="s3">)</span>
        <span class="s2">except </span><span class="s1">MissingDefinitionError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">InvalidSchemaError </span><span class="s2">from </span><span class="s1">e</span>

        <span class="s1">remaining_defs</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">CoreSchema</span><span class="s3">] = {}</span>

        <span class="s6"># Note: this logic doesn't play well when core schemas with deferred discriminator metadata</span>
        <span class="s6"># and references are encountered. See the `test_deferred_discriminated_union_and_references()` test.</span>
        <span class="s2">for </span><span class="s1">ref</span><span class="s3">, </span><span class="s1">inlinable_def_ref </span><span class="s2">in </span><span class="s1">gather_result</span><span class="s3">[</span><span class="s5">'collected_references'</span><span class="s3">].</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s1">inlinable_def_ref </span><span class="s2">is not None and </span><span class="s3">(</span><span class="s1">inlining_behavior </span><span class="s3">:= </span><span class="s1">_inlining_behavior</span><span class="s3">(</span><span class="s1">inlinable_def_ref</span><span class="s3">)) != </span><span class="s5">'keep'</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">inlining_behavior </span><span class="s3">== </span><span class="s5">'inline'</span><span class="s3">:</span>
                    <span class="s6"># `ref` was encountered, and only once:</span>
                    <span class="s6">#  - `inlinable_def_ref` is a `'definition-ref'` schema and is guaranteed to be</span>
                    <span class="s6">#    the only one. Transform it into the definition it points to.</span>
                    <span class="s6">#  - Do not store the definition in the `remaining_defs`.</span>
                    <span class="s1">inlinable_def_ref</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">()  </span><span class="s6"># pyright: ignore[reportAttributeAccessIssue]</span>
                    <span class="s1">inlinable_def_ref</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_resolve_definition</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">, </span><span class="s1">definitions</span><span class="s3">))  </span><span class="s6"># pyright: ignore</span>
                <span class="s2">elif </span><span class="s1">inlining_behavior </span><span class="s3">== </span><span class="s5">'preserve_metadata'</span><span class="s3">:</span>
                    <span class="s6"># `ref` was encountered, and only once, but contains discriminator metadata.</span>
                    <span class="s6"># We will do the same thing as if `inlining_behavior` was `'inline'`, but make</span>
                    <span class="s6"># sure to keep the metadata for the deferred discriminator application logic below.</span>
                    <span class="s1">meta </span><span class="s3">= </span><span class="s1">inlinable_def_ref</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">'metadata'</span><span class="s3">)</span>
                    <span class="s1">inlinable_def_ref</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">()  </span><span class="s6"># pyright: ignore[reportAttributeAccessIssue]</span>
                    <span class="s1">inlinable_def_ref</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_resolve_definition</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">, </span><span class="s1">definitions</span><span class="s3">))  </span><span class="s6"># pyright: ignore</span>
                    <span class="s1">inlinable_def_ref</span><span class="s3">[</span><span class="s5">'metadata'</span><span class="s3">] = </span><span class="s1">meta</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s6"># `ref` was encountered, at least two times (or only once, but with metadata or a serialization schema):</span>
                <span class="s6"># - Do not inline the `'definition-ref'` schemas (they are not provided in the gather result anyway).</span>
                <span class="s6"># - Store the the definition in the `remaining_defs`</span>
                <span class="s1">remaining_defs</span><span class="s3">[</span><span class="s1">ref</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_resolve_definition</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">, </span><span class="s1">definitions</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">cs </span><span class="s2">in </span><span class="s1">gather_result</span><span class="s3">[</span><span class="s5">'deferred_discriminator_schemas'</span><span class="s3">]:</span>
            <span class="s1">discriminator</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s1">cs</span><span class="s3">[</span><span class="s5">'metadata'</span><span class="s3">].</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">'pydantic_internal_union_discriminator'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)  </span><span class="s6"># pyright: ignore[reportTypedDictNotRequiredAccess]</span>
            <span class="s2">if </span><span class="s1">discriminator </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s6"># This can happen in rare scenarios, when a deferred schema is present multiple times in the</span>
                <span class="s6"># gather result (e.g. when using the `Sequence` type -- see `test_sequence_discriminated_union()`).</span>
                <span class="s6"># In this case, a previous loop iteration applied the discriminator and so we can just skip it here.</span>
                <span class="s2">continue</span>
            <span class="s1">applied </span><span class="s3">= </span><span class="s1">_discriminated_union</span><span class="s3">.</span><span class="s1">apply_discriminator</span><span class="s3">(</span><span class="s1">cs</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(), </span><span class="s1">discriminator</span><span class="s3">, </span><span class="s1">remaining_defs</span><span class="s3">)</span>
            <span class="s6"># Mutate the schema directly to have the discriminator applied</span>
            <span class="s1">cs</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">()  </span><span class="s6"># pyright: ignore[reportAttributeAccessIssue]</span>
            <span class="s1">cs</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">applied</span><span class="s3">)  </span><span class="s6"># pyright: ignore</span>

        <span class="s2">if </span><span class="s1">remaining_defs</span><span class="s3">:</span>
            <span class="s1">schema </span><span class="s3">= </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">definitions_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">definitions</span><span class="s3">=[*</span><span class="s1">remaining_defs</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()])</span>
        <span class="s2">return </span><span class="s1">schema</span>

    <span class="s2">def </span><span class="s1">_resolve_definition</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">definitions</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">CoreSchema</span><span class="s3">]) </span><span class="s1">-&gt; CoreSchema</span><span class="s3">:</span>
        <span class="s1">definition </span><span class="s3">= </span><span class="s1">definitions</span><span class="s3">[</span><span class="s1">ref</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">definition</span><span class="s3">[</span><span class="s5">'type'</span><span class="s3">] != </span><span class="s5">'definition-ref'</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">definition</span>

        <span class="s6"># Some `'definition-ref'` schemas might act as &quot;intermediate&quot; references (e.g. when using</span>
        <span class="s6"># a PEP 695 type alias (which is referenceable) that references another PEP 695 type alias):</span>
        <span class="s1">visited</span><span class="s3">: </span><span class="s1">set</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s2">while </span><span class="s1">definition</span><span class="s3">[</span><span class="s5">'type'</span><span class="s3">] == </span><span class="s5">'definition-ref' </span><span class="s2">and </span><span class="s1">_inlining_behavior</span><span class="s3">(</span><span class="s1">definition</span><span class="s3">) == </span><span class="s5">'inline'</span><span class="s3">:</span>
            <span class="s1">schema_ref </span><span class="s3">= </span><span class="s1">definition</span><span class="s3">[</span><span class="s5">'schema_ref'</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">schema_ref </span><span class="s2">in </span><span class="s1">visited</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">PydanticUserError</span><span class="s3">(</span>
                    <span class="s5">f'</span><span class="s2">{</span><span class="s1">ref</span><span class="s2">} </span><span class="s5">contains a circular reference to itself.'</span><span class="s3">, </span><span class="s1">code</span><span class="s3">=</span><span class="s5">'circular-reference-schema'</span>
                <span class="s3">)</span>
            <span class="s1">visited</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">schema_ref</span><span class="s3">)</span>
            <span class="s1">definition </span><span class="s3">= </span><span class="s1">definitions</span><span class="s3">[</span><span class="s1">schema_ref</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s3">{**</span><span class="s1">definition</span><span class="s3">, </span><span class="s5">'ref'</span><span class="s3">: </span><span class="s1">ref</span><span class="s3">}  </span><span class="s6"># pyright: ignore[reportReturnType]</span>


<span class="s2">class </span><span class="s1">_FieldNameStack</span><span class="s3">:</span>
    <span class="s1">__slots__ </span><span class="s3">= (</span><span class="s5">'_stack'</span><span class="s3">,)</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_stack</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = []</span>

    <span class="s3">@</span><span class="s1">contextmanager</span>
    <span class="s2">def </span><span class="s1">push</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; Iterator</span><span class="s3">[</span><span class="s2">None</span><span class="s3">]:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_stack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">field_name</span><span class="s3">)</span>
        <span class="s2">yield</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_stack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">get</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; str </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_stack</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_stack</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return None</span>


<span class="s2">class </span><span class="s1">_ModelTypeStack</span><span class="s3">:</span>
    <span class="s1">__slots__ </span><span class="s3">= (</span><span class="s5">'_stack'</span><span class="s3">,)</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_stack</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">type</span><span class="s3">] = []</span>

    <span class="s3">@</span><span class="s1">contextmanager</span>
    <span class="s2">def </span><span class="s1">push</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">type_obj</span><span class="s3">: </span><span class="s1">type</span><span class="s3">) </span><span class="s1">-&gt; Iterator</span><span class="s3">[</span><span class="s2">None</span><span class="s3">]:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_stack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">type_obj</span><span class="s3">)</span>
        <span class="s2">yield</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_stack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">get</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; type </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_stack</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_stack</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return None</span>
</pre>
</body>
</html>