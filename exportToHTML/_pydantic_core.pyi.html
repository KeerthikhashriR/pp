<html>
<head>
<title>_pydantic_core.pyi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_pydantic_core.pyi</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">datetime</span>
<span class="s0">from </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc </span><span class="s0">import </span><span class="s1">Mapping</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">Generic</span><span class="s2">, </span><span class="s1">Literal</span><span class="s2">, </span><span class="s1">TypeVar</span><span class="s2">, </span><span class="s1">final</span>

<span class="s0">from </span><span class="s1">_typeshed </span><span class="s0">import </span><span class="s1">SupportsAllComparisons</span>
<span class="s0">from </span><span class="s1">typing_extensions </span><span class="s0">import </span><span class="s1">LiteralString</span><span class="s2">, </span><span class="s1">Self</span><span class="s2">, </span><span class="s1">TypeAlias</span>

<span class="s0">from </span><span class="s1">pydantic_core </span><span class="s0">import </span><span class="s1">ErrorDetails</span><span class="s2">, </span><span class="s1">ErrorTypeInfo</span><span class="s2">, </span><span class="s1">InitErrorDetails</span><span class="s2">, </span><span class="s1">MultiHostHost</span>
<span class="s0">from </span><span class="s1">pydantic_core</span><span class="s2">.</span><span class="s1">core_schema </span><span class="s0">import </span><span class="s1">CoreConfig</span><span class="s2">, </span><span class="s1">CoreSchema</span><span class="s2">, </span><span class="s1">ErrorType</span>

<span class="s1">__all__ </span><span class="s2">= [</span>
    <span class="s3">'__version__'</span><span class="s2">,</span>
    <span class="s3">'build_profile'</span><span class="s2">,</span>
    <span class="s3">'build_info'</span><span class="s2">,</span>
    <span class="s3">'_recursion_limit'</span><span class="s2">,</span>
    <span class="s3">'ArgsKwargs'</span><span class="s2">,</span>
    <span class="s3">'SchemaValidator'</span><span class="s2">,</span>
    <span class="s3">'SchemaSerializer'</span><span class="s2">,</span>
    <span class="s3">'Url'</span><span class="s2">,</span>
    <span class="s3">'MultiHostUrl'</span><span class="s2">,</span>
    <span class="s3">'SchemaError'</span><span class="s2">,</span>
    <span class="s3">'ValidationError'</span><span class="s2">,</span>
    <span class="s3">'PydanticCustomError'</span><span class="s2">,</span>
    <span class="s3">'PydanticKnownError'</span><span class="s2">,</span>
    <span class="s3">'PydanticOmit'</span><span class="s2">,</span>
    <span class="s3">'PydanticUseDefault'</span><span class="s2">,</span>
    <span class="s3">'PydanticSerializationError'</span><span class="s2">,</span>
    <span class="s3">'PydanticSerializationUnexpectedValue'</span><span class="s2">,</span>
    <span class="s3">'PydanticUndefined'</span><span class="s2">,</span>
    <span class="s3">'PydanticUndefinedType'</span><span class="s2">,</span>
    <span class="s3">'Some'</span><span class="s2">,</span>
    <span class="s3">'to_json'</span><span class="s2">,</span>
    <span class="s3">'from_json'</span><span class="s2">,</span>
    <span class="s3">'to_jsonable_python'</span><span class="s2">,</span>
    <span class="s3">'list_all_errors'</span><span class="s2">,</span>
    <span class="s3">'TzInfo'</span><span class="s2">,</span>
    <span class="s3">'validate_core_schema'</span><span class="s2">,</span>
<span class="s2">]</span>
<span class="s1">__version__</span><span class="s2">: </span><span class="s1">str</span>
<span class="s1">build_profile</span><span class="s2">: </span><span class="s1">str</span>
<span class="s1">build_info</span><span class="s2">: </span><span class="s1">str</span>
<span class="s1">_recursion_limit</span><span class="s2">: </span><span class="s1">int</span>

<span class="s1">_T </span><span class="s2">= </span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s3">'_T'</span><span class="s2">, </span><span class="s1">default</span><span class="s2">=</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">covariant</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

<span class="s1">_StringInput</span><span class="s2">: </span><span class="s1">TypeAlias </span><span class="s2">= </span><span class="s3">'dict[str, _StringInput]'</span>

<span class="s2">@</span><span class="s1">final</span>
<span class="s0">class </span><span class="s1">Some</span><span class="s2">(</span><span class="s1">Generic</span><span class="s2">[</span><span class="s1">_T</span><span class="s2">]):</span>
    <span class="s4">&quot;&quot;&quot; 
    Similar to Rust's [`Option::Some`](https://doc.rust-lang.org/std/option/enum.Option.html) type, this 
    identifies a value as being present, and provides a way to access it. 
 
    Generally used in a union with `None` to different between &quot;some value which could be None&quot; and no value. 
    &quot;&quot;&quot;</span>

    <span class="s1">__match_args__ </span><span class="s2">= (</span><span class="s3">'value'</span><span class="s2">,)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; _T</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Returns the value wrapped by `Some`. 
        &quot;&quot;&quot;</span>
    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">__class_getitem__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">item</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">, /) </span><span class="s1">-&gt; type</span><span class="s2">[</span><span class="s1">Self</span><span class="s2">]: ...</span>

<span class="s2">@</span><span class="s1">final</span>
<span class="s0">class </span><span class="s1">SchemaValidator</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    `SchemaValidator` is the Python wrapper for `pydantic-core`'s Rust validation logic, internally it owns one 
    `CombinedValidator` which may in turn own more `CombinedValidator`s which make up the full schema validator. 
    &quot;&quot;&quot;</span>

    <span class="s5"># note: pyo3 currently supports __new__, but not __init__, though we include __init__ stubs</span>
    <span class="s5"># and docstrings here (and in the following classes) for documentation purposes</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">schema</span><span class="s2">: </span><span class="s1">CoreSchema</span><span class="s2">, </span><span class="s1">config</span><span class="s2">: </span><span class="s1">CoreConfig </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot;Initializes the `SchemaValidator`. 
 
        Arguments: 
            schema: The `CoreSchema` to use for validation. 
            config: Optionally a [`CoreConfig`][pydantic_core.core_schema.CoreConfig] to configure validation. 
        &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">schema</span><span class="s2">: </span><span class="s1">CoreSchema</span><span class="s2">, </span><span class="s1">config</span><span class="s2">: </span><span class="s1">CoreConfig </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">: ...</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">title</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot; 
        The title of the schema, as used in the heading of [`ValidationError.__str__()`][pydantic_core.ValidationError]. 
        &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">validate_python</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">input</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">strict</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">from_attributes</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">context</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">self_instance</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">allow_partial</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s1">Literal</span><span class="s2">[</span><span class="s3">'off'</span><span class="s2">, </span><span class="s3">'on'</span><span class="s2">, </span><span class="s3">'trailing-strings'</span><span class="s2">] = </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">by_alias</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">by_name</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Validate a Python object against the schema and return the validated object. 
 
        Arguments: 
            input: The Python object to validate. 
            strict: Whether to validate the object in strict mode. 
                If `None`, the value of [`CoreConfig.strict`][pydantic_core.core_schema.CoreConfig] is used. 
            from_attributes: Whether to validate objects as inputs to models by extracting attributes. 
                If `None`, the value of [`CoreConfig.from_attributes`][pydantic_core.core_schema.CoreConfig] is used. 
            context: The context to use for validation, this is passed to functional validators as 
                [`info.context`][pydantic_core.core_schema.ValidationInfo.context]. 
            self_instance: An instance of a model set attributes on from validation, this is used when running 
                validation from the `__init__` method of a model. 
            allow_partial: Whether to allow partial validation; if `True` errors in the last element of sequences 
                and mappings are ignored. 
                `'trailing-strings'` means any final unfinished JSON string is included in the result. 
            by_alias: Whether to use the field's alias when validating against the provided input data. 
            by_name: Whether to use the field's name when validating against the provided input data. 
 
        Raises: 
            ValidationError: If validation fails. 
            Exception: Other error types maybe raised if internal errors occur. 
 
        Returns: 
            The validated object. 
        &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">isinstance_python</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">input</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">strict</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">from_attributes</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">context</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">self_instance</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">by_alias</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">by_name</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Similar to [`validate_python()`][pydantic_core.SchemaValidator.validate_python] but returns a boolean. 
 
        Arguments match `validate_python()`. This method will not raise `ValidationError`s but will raise internal 
        errors. 
 
        Returns: 
            `True` if validation succeeds, `False` if validation fails. 
        &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">validate_json</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">input</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s1">bytes </span><span class="s2">| </span><span class="s1">bytearray</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">strict</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">context</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">self_instance</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">allow_partial</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s1">Literal</span><span class="s2">[</span><span class="s3">'off'</span><span class="s2">, </span><span class="s3">'on'</span><span class="s2">, </span><span class="s3">'trailing-strings'</span><span class="s2">] = </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">by_alias</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">by_name</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Validate JSON data directly against the schema and return the validated Python object. 
 
        This method should be significantly faster than `validate_python(json.loads(json_data))` as it avoids the 
        need to create intermediate Python objects 
 
        It also handles constructing the correct Python type even in strict mode, where 
        `validate_python(json.loads(json_data))` would fail validation. 
 
        Arguments: 
            input: The JSON data to validate. 
            strict: Whether to validate the object in strict mode. 
                If `None`, the value of [`CoreConfig.strict`][pydantic_core.core_schema.CoreConfig] is used. 
            context: The context to use for validation, this is passed to functional validators as 
                [`info.context`][pydantic_core.core_schema.ValidationInfo.context]. 
            self_instance: An instance of a model set attributes on from validation. 
            allow_partial: Whether to allow partial validation; if `True` incomplete JSON will be parsed successfully 
                and errors in the last element of sequences and mappings are ignored. 
                `'trailing-strings'` means any final unfinished JSON string is included in the result. 
            by_alias: Whether to use the field's alias when validating against the provided input data. 
            by_name: Whether to use the field's name when validating against the provided input data. 
 
        Raises: 
            ValidationError: If validation fails or if the JSON data is invalid. 
            Exception: Other error types maybe raised if internal errors occur. 
 
        Returns: 
            The validated Python object. 
        &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">validate_strings</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">input</span><span class="s2">: </span><span class="s1">_StringInput</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">strict</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">context</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">allow_partial</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s1">Literal</span><span class="s2">[</span><span class="s3">'off'</span><span class="s2">, </span><span class="s3">'on'</span><span class="s2">, </span><span class="s3">'trailing-strings'</span><span class="s2">] = </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">by_alias</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">by_name</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Validate a string against the schema and return the validated Python object. 
 
        This is similar to `validate_json` but applies to scenarios where the input will be a string but not 
        JSON data, e.g. URL fragments, query parameters, etc. 
 
        Arguments: 
            input: The input as a string, or bytes/bytearray if `strict=False`. 
            strict: Whether to validate the object in strict mode. 
                If `None`, the value of [`CoreConfig.strict`][pydantic_core.core_schema.CoreConfig] is used. 
            context: The context to use for validation, this is passed to functional validators as 
                [`info.context`][pydantic_core.core_schema.ValidationInfo.context]. 
            allow_partial: Whether to allow partial validation; if `True` errors in the last element of sequences 
                and mappings are ignored. 
                `'trailing-strings'` means any final unfinished JSON string is included in the result. 
            by_alias: Whether to use the field's alias when validating against the provided input data. 
            by_name: Whether to use the field's name when validating against the provided input data. 
 
        Raises: 
            ValidationError: If validation fails or if the JSON data is invalid. 
            Exception: Other error types maybe raised if internal errors occur. 
 
        Returns: 
            The validated Python object. 
        &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">validate_assignment</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">obj</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
        <span class="s1">field_name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
        <span class="s1">field_value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">strict</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">from_attributes</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">context</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">by_alias</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">by_name</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] | </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] | </span><span class="s0">None</span><span class="s2">, </span><span class="s1">set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]]:</span>
        <span class="s4">&quot;&quot;&quot; 
        Validate an assignment to a field on a model. 
 
        Arguments: 
            obj: The model instance being assigned to. 
            field_name: The name of the field to validate assignment for. 
            field_value: The value to assign to the field. 
            strict: Whether to validate the object in strict mode. 
                If `None`, the value of [`CoreConfig.strict`][pydantic_core.core_schema.CoreConfig] is used. 
            from_attributes: Whether to validate objects as inputs to models by extracting attributes. 
                If `None`, the value of [`CoreConfig.from_attributes`][pydantic_core.core_schema.CoreConfig] is used. 
            context: The context to use for validation, this is passed to functional validators as 
                [`info.context`][pydantic_core.core_schema.ValidationInfo.context]. 
            by_alias: Whether to use the field's alias when validating against the provided input data. 
            by_name: Whether to use the field's name when validating against the provided input data. 
 
        Raises: 
            ValidationError: If validation fails. 
            Exception: Other error types maybe raised if internal errors occur. 
 
        Returns: 
            Either the model dict or a tuple of `(model_data, model_extra, fields_set)` 
        &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">get_default_value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *, </span><span class="s1">strict</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">, </span><span class="s1">context</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">= </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; Some </span><span class="s2">| </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Get the default value for the schema, including running default value validation. 
 
        Arguments: 
            strict: Whether to validate the default value in strict mode. 
                If `None`, the value of [`CoreConfig.strict`][pydantic_core.core_schema.CoreConfig] is used. 
            context: The context to use for validation, this is passed to functional validators as 
                [`info.context`][pydantic_core.core_schema.ValidationInfo.context]. 
 
        Raises: 
            ValidationError: If validation fails. 
            Exception: Other error types maybe raised if internal errors occur. 
 
        Returns: 
            `None` if the schema has no default value, otherwise a [`Some`][pydantic_core.Some] containing the default. 
        &quot;&quot;&quot;</span>

<span class="s5"># In reality, `bool` should be replaced by `Literal[True]` but mypy fails to correctly apply bidirectional type inference</span>
<span class="s5"># (e.g. when using `{'a': {'b': True}}`).</span>
<span class="s1">_IncEx</span><span class="s2">: </span><span class="s1">TypeAlias </span><span class="s2">= </span><span class="s1">set</span><span class="s2">[</span><span class="s1">int</span><span class="s2">] | </span><span class="s1">set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] | </span><span class="s1">Mapping</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, </span><span class="s1">_IncEx </span><span class="s2">| </span><span class="s1">bool</span><span class="s2">] | </span><span class="s1">Mapping</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">_IncEx </span><span class="s2">| </span><span class="s1">bool</span><span class="s2">]</span>

<span class="s2">@</span><span class="s1">final</span>
<span class="s0">class </span><span class="s1">SchemaSerializer</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    `SchemaSerializer` is the Python wrapper for `pydantic-core`'s Rust serialization logic, internally it owns one 
    `CombinedSerializer` which may in turn own more `CombinedSerializer`s which make up the full schema serializer. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">schema</span><span class="s2">: </span><span class="s1">CoreSchema</span><span class="s2">, </span><span class="s1">config</span><span class="s2">: </span><span class="s1">CoreConfig </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot;Initializes the `SchemaSerializer`. 
 
        Arguments: 
            schema: The `CoreSchema` to use for serialization. 
            config: Optionally a [`CoreConfig`][pydantic_core.core_schema.CoreConfig] to to configure serialization. 
        &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">schema</span><span class="s2">: </span><span class="s1">CoreSchema</span><span class="s2">, </span><span class="s1">config</span><span class="s2">: </span><span class="s1">CoreConfig </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">: ...</span>
    <span class="s0">def </span><span class="s1">to_python</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">mode</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">include</span><span class="s2">: </span><span class="s1">_IncEx </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">exclude</span><span class="s2">: </span><span class="s1">_IncEx </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">by_alias</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">exclude_unset</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">exclude_defaults</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">exclude_none</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">round_trip</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">warnings</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s1">Literal</span><span class="s2">[</span><span class="s3">'none'</span><span class="s2">, </span><span class="s3">'warn'</span><span class="s2">, </span><span class="s3">'error'</span><span class="s2">] = </span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">fallback</span><span class="s2">: </span><span class="s1">Callable</span><span class="s2">[[</span><span class="s1">Any</span><span class="s2">], </span><span class="s1">Any</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">serialize_as_any</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">context</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Serialize/marshal a Python object to a Python object including transforming and filtering data. 
 
        Arguments: 
            value: The Python object to serialize. 
            mode: The serialization mode to use, either `'python'` or `'json'`, defaults to `'python'`. In JSON mode, 
                all values are converted to JSON compatible types, e.g. `None`, `int`, `float`, `str`, `list`, `dict`. 
            include: A set of fields to include, if `None` all fields are included. 
            exclude: A set of fields to exclude, if `None` no fields are excluded. 
            by_alias: Whether to use the alias names of fields. 
            exclude_unset: Whether to exclude fields that are not set, 
                e.g. are not included in `__pydantic_fields_set__`. 
            exclude_defaults: Whether to exclude fields that are equal to their default value. 
            exclude_none: Whether to exclude fields that have a value of `None`. 
            round_trip: Whether to enable serialization and validation round-trip support. 
            warnings: How to handle invalid fields. False/&quot;none&quot; ignores them, True/&quot;warn&quot; logs errors, 
                &quot;error&quot; raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError]. 
            fallback: A function to call when an unknown value is encountered, 
                if `None` a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised. 
            serialize_as_any: Whether to serialize fields with duck-typing serialization behavior. 
            context: The context to use for serialization, this is passed to functional serializers as 
                [`info.context`][pydantic_core.core_schema.SerializationInfo.context]. 
 
        Raises: 
            PydanticSerializationError: If serialization fails and no `fallback` function is provided. 
 
        Returns: 
            The serialized Python object. 
        &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">to_json</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">indent</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">include</span><span class="s2">: </span><span class="s1">_IncEx </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">exclude</span><span class="s2">: </span><span class="s1">_IncEx </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">by_alias</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">exclude_unset</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">exclude_defaults</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">exclude_none</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">round_trip</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">warnings</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s1">Literal</span><span class="s2">[</span><span class="s3">'none'</span><span class="s2">, </span><span class="s3">'warn'</span><span class="s2">, </span><span class="s3">'error'</span><span class="s2">] = </span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">fallback</span><span class="s2">: </span><span class="s1">Callable</span><span class="s2">[[</span><span class="s1">Any</span><span class="s2">], </span><span class="s1">Any</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">serialize_as_any</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">context</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; bytes</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Serialize a Python object to JSON including transforming and filtering data. 
 
        Arguments: 
            value: The Python object to serialize. 
            indent: If `None`, the JSON will be compact, otherwise it will be pretty-printed with the indent provided. 
            include: A set of fields to include, if `None` all fields are included. 
            exclude: A set of fields to exclude, if `None` no fields are excluded. 
            by_alias: Whether to use the alias names of fields. 
            exclude_unset: Whether to exclude fields that are not set, 
                e.g. are not included in `__pydantic_fields_set__`. 
            exclude_defaults: Whether to exclude fields that are equal to their default value. 
            exclude_none: Whether to exclude fields that have a value of `None`. 
            round_trip: Whether to enable serialization and validation round-trip support. 
            warnings: How to handle invalid fields. False/&quot;none&quot; ignores them, True/&quot;warn&quot; logs errors, 
                &quot;error&quot; raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError]. 
            fallback: A function to call when an unknown value is encountered, 
                if `None` a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised. 
            serialize_as_any: Whether to serialize fields with duck-typing serialization behavior. 
            context: The context to use for serialization, this is passed to functional serializers as 
                [`info.context`][pydantic_core.core_schema.SerializationInfo.context]. 
 
        Raises: 
            PydanticSerializationError: If serialization fails and no `fallback` function is provided. 
 
        Returns: 
           JSON bytes. 
        &quot;&quot;&quot;</span>

<span class="s0">def </span><span class="s1">to_json</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s2">*,</span>
    <span class="s1">indent</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">include</span><span class="s2">: </span><span class="s1">_IncEx </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">exclude</span><span class="s2">: </span><span class="s1">_IncEx </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s5"># Note: In Pydantic 2.11, the default value of `by_alias` on `SchemaSerializer` was changed from `True` to `None`,</span>
    <span class="s5"># to be consistent with the Pydantic &quot;dump&quot; methods. However, the default of `True` was kept here for</span>
    <span class="s5"># backwards compatibility. In Pydantic V3, `by_alias` is expected to default to `True` everywhere:</span>
    <span class="s1">by_alias</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
    <span class="s1">exclude_none</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s1">round_trip</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s1">timedelta_mode</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s3">'iso8601'</span><span class="s2">, </span><span class="s3">'float'</span><span class="s2">] = </span><span class="s3">'iso8601'</span><span class="s2">,</span>
    <span class="s1">bytes_mode</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s3">'utf8'</span><span class="s2">, </span><span class="s3">'base64'</span><span class="s2">, </span><span class="s3">'hex'</span><span class="s2">] = </span><span class="s3">'utf8'</span><span class="s2">,</span>
    <span class="s1">inf_nan_mode</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s3">'null'</span><span class="s2">, </span><span class="s3">'constants'</span><span class="s2">, </span><span class="s3">'strings'</span><span class="s2">] = </span><span class="s3">'constants'</span><span class="s2">,</span>
    <span class="s1">serialize_unknown</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s1">fallback</span><span class="s2">: </span><span class="s1">Callable</span><span class="s2">[[</span><span class="s1">Any</span><span class="s2">], </span><span class="s1">Any</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">serialize_as_any</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s1">context</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; bytes</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Serialize a Python object to JSON including transforming and filtering data. 
 
    This is effectively a standalone version of [`SchemaSerializer.to_json`][pydantic_core.SchemaSerializer.to_json]. 
 
    Arguments: 
        value: The Python object to serialize. 
        indent: If `None`, the JSON will be compact, otherwise it will be pretty-printed with the indent provided. 
        include: A set of fields to include, if `None` all fields are included. 
        exclude: A set of fields to exclude, if `None` no fields are excluded. 
        by_alias: Whether to use the alias names of fields. 
        exclude_none: Whether to exclude fields that have a value of `None`. 
        round_trip: Whether to enable serialization and validation round-trip support. 
        timedelta_mode: How to serialize `timedelta` objects, either `'iso8601'` or `'float'`. 
        bytes_mode: How to serialize `bytes` objects, either `'utf8'`, `'base64'`, or `'hex'`. 
        inf_nan_mode: How to serialize `Infinity`, `-Infinity` and `NaN` values, either `'null'`, `'constants'`, or `'strings'`. 
        serialize_unknown: Attempt to serialize unknown types, `str(value)` will be used, if that fails 
            `&quot;&lt;Unserializable {value_type} object&gt;&quot;` will be used. 
        fallback: A function to call when an unknown value is encountered, 
            if `None` a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised. 
        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior. 
        context: The context to use for serialization, this is passed to functional serializers as 
            [`info.context`][pydantic_core.core_schema.SerializationInfo.context]. 
 
    Raises: 
        PydanticSerializationError: If serialization fails and no `fallback` function is provided. 
 
    Returns: 
       JSON bytes. 
    &quot;&quot;&quot;</span>

<span class="s0">def </span><span class="s1">from_json</span><span class="s2">(</span>
    <span class="s1">data</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s1">bytes </span><span class="s2">| </span><span class="s1">bytearray</span><span class="s2">,</span>
    <span class="s2">*,</span>
    <span class="s1">allow_inf_nan</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
    <span class="s1">cache_strings</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s1">Literal</span><span class="s2">[</span><span class="s3">'all'</span><span class="s2">, </span><span class="s3">'keys'</span><span class="s2">, </span><span class="s3">'none'</span><span class="s2">] = </span><span class="s0">True</span><span class="s2">,</span>
    <span class="s1">allow_partial</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s1">Literal</span><span class="s2">[</span><span class="s3">'off'</span><span class="s2">, </span><span class="s3">'on'</span><span class="s2">, </span><span class="s3">'trailing-strings'</span><span class="s2">] = </span><span class="s0">False</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Deserialize JSON data to a Python object. 
 
    This is effectively a faster version of `json.loads()`, with some extra functionality. 
 
    Arguments: 
        data: The JSON data to deserialize. 
        allow_inf_nan: Whether to allow `Infinity`, `-Infinity` and `NaN` values as `json.loads()` does by default. 
        cache_strings: Whether to cache strings to avoid constructing new Python objects, 
            this should have a significant impact on performance while increasing memory usage slightly, 
            `all/True` means cache all strings, `keys` means cache only dict keys, `none/False` means no caching. 
        allow_partial: Whether to allow partial deserialization, if `True` JSON data is returned if the end of the 
            input is reached before the full object is deserialized, e.g. `[&quot;aa&quot;, &quot;bb&quot;, &quot;c` would return `['aa', 'bb']`. 
            `'trailing-strings'` means any final unfinished JSON string is included in the result. 
 
    Raises: 
        ValueError: If deserialization fails. 
 
    Returns: 
        The deserialized Python object. 
    &quot;&quot;&quot;</span>

<span class="s0">def </span><span class="s1">to_jsonable_python</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s2">*,</span>
    <span class="s1">include</span><span class="s2">: </span><span class="s1">_IncEx </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">exclude</span><span class="s2">: </span><span class="s1">_IncEx </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s5"># Note: In Pydantic 2.11, the default value of `by_alias` on `SchemaSerializer` was changed from `True` to `None`,</span>
    <span class="s5"># to be consistent with the Pydantic &quot;dump&quot; methods. However, the default of `True` was kept here for</span>
    <span class="s5"># backwards compatibility. In Pydantic V3, `by_alias` is expected to default to `True` everywhere:</span>
    <span class="s1">by_alias</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
    <span class="s1">exclude_none</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s1">round_trip</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s1">timedelta_mode</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s3">'iso8601'</span><span class="s2">, </span><span class="s3">'float'</span><span class="s2">] = </span><span class="s3">'iso8601'</span><span class="s2">,</span>
    <span class="s1">bytes_mode</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s3">'utf8'</span><span class="s2">, </span><span class="s3">'base64'</span><span class="s2">, </span><span class="s3">'hex'</span><span class="s2">] = </span><span class="s3">'utf8'</span><span class="s2">,</span>
    <span class="s1">inf_nan_mode</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s3">'null'</span><span class="s2">, </span><span class="s3">'constants'</span><span class="s2">, </span><span class="s3">'strings'</span><span class="s2">] = </span><span class="s3">'constants'</span><span class="s2">,</span>
    <span class="s1">serialize_unknown</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s1">fallback</span><span class="s2">: </span><span class="s1">Callable</span><span class="s2">[[</span><span class="s1">Any</span><span class="s2">], </span><span class="s1">Any</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">serialize_as_any</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s1">context</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Serialize/marshal a Python object to a JSON-serializable Python object including transforming and filtering data. 
 
    This is effectively a standalone version of 
    [`SchemaSerializer.to_python(mode='json')`][pydantic_core.SchemaSerializer.to_python]. 
 
    Args: 
        value: The Python object to serialize. 
        include: A set of fields to include, if `None` all fields are included. 
        exclude: A set of fields to exclude, if `None` no fields are excluded. 
        by_alias: Whether to use the alias names of fields. 
        exclude_none: Whether to exclude fields that have a value of `None`. 
        round_trip: Whether to enable serialization and validation round-trip support. 
        timedelta_mode: How to serialize `timedelta` objects, either `'iso8601'` or `'float'`. 
        bytes_mode: How to serialize `bytes` objects, either `'utf8'`, `'base64'`, or `'hex'`. 
        inf_nan_mode: How to serialize `Infinity`, `-Infinity` and `NaN` values, either `'null'`, `'constants'`, or `'strings'`. 
        serialize_unknown: Attempt to serialize unknown types, `str(value)` will be used, if that fails 
            `&quot;&lt;Unserializable {value_type} object&gt;&quot;` will be used. 
        fallback: A function to call when an unknown value is encountered, 
            if `None` a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised. 
        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior. 
        context: The context to use for serialization, this is passed to functional serializers as 
            [`info.context`][pydantic_core.core_schema.SerializationInfo.context]. 
 
    Raises: 
        PydanticSerializationError: If serialization fails and no `fallback` function is provided. 
 
    Returns: 
        The serialized Python object. 
    &quot;&quot;&quot;</span>

<span class="s0">class </span><span class="s1">Url</span><span class="s2">(</span><span class="s1">SupportsAllComparisons</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    A URL type, internal logic uses the [url rust crate](https://docs.rs/url/latest/url/) originally developed 
    by Mozilla. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">: ...</span>
    <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">url</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">: ...</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">scheme</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">: ...</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">username</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str </span><span class="s2">| </span><span class="s0">None</span><span class="s2">: ...</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">password</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str </span><span class="s2">| </span><span class="s0">None</span><span class="s2">: ...</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">host</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str </span><span class="s2">| </span><span class="s0">None</span><span class="s2">: ...</span>
    <span class="s0">def </span><span class="s1">unicode_host</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str </span><span class="s2">| </span><span class="s0">None</span><span class="s2">: ...</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">port</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; int </span><span class="s2">| </span><span class="s0">None</span><span class="s2">: ...</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">path</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str </span><span class="s2">| </span><span class="s0">None</span><span class="s2">: ...</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">query</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str </span><span class="s2">| </span><span class="s0">None</span><span class="s2">: ...</span>
    <span class="s0">def </span><span class="s1">query_params</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">]]: ...</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">fragment</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str </span><span class="s2">| </span><span class="s0">None</span><span class="s2">: ...</span>
    <span class="s0">def </span><span class="s1">unicode_string</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">: ...</span>
    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">: ...</span>
    <span class="s0">def </span><span class="s1">__str__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">: ...</span>
    <span class="s0">def </span><span class="s1">__deepcopy__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">: ...</span>
    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">build</span><span class="s2">(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">scheme</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
        <span class="s1">username</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">password</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">host</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
        <span class="s1">port</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">path</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">query</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">fragment</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">: ...</span>

<span class="s0">class </span><span class="s1">MultiHostUrl</span><span class="s2">(</span><span class="s1">SupportsAllComparisons</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    A URL type with support for multiple hosts, as used by some databases for DSNs, e.g. `https://foo.com,bar.com/path`. 
 
    Internal URL logic uses the [url rust crate](https://docs.rs/url/latest/url/) originally developed 
    by Mozilla. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">: ...</span>
    <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">url</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">: ...</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">scheme</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">: ...</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">path</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str </span><span class="s2">| </span><span class="s0">None</span><span class="s2">: ...</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">query</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str </span><span class="s2">| </span><span class="s0">None</span><span class="s2">: ...</span>
    <span class="s0">def </span><span class="s1">query_params</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">]]: ...</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">fragment</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str </span><span class="s2">| </span><span class="s0">None</span><span class="s2">: ...</span>
    <span class="s0">def </span><span class="s1">hosts</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">MultiHostHost</span><span class="s2">]: ...</span>
    <span class="s0">def </span><span class="s1">unicode_string</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">: ...</span>
    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">: ...</span>
    <span class="s0">def </span><span class="s1">__str__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">: ...</span>
    <span class="s0">def </span><span class="s1">__deepcopy__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">: ...</span>
    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">build</span><span class="s2">(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">scheme</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
        <span class="s1">hosts</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">MultiHostHost</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">username</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">password</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">host</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">port</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">path</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">query</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">fragment</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">: ...</span>

<span class="s2">@</span><span class="s1">final</span>
<span class="s0">class </span><span class="s1">SchemaError</span><span class="s2">(</span><span class="s1">Exception</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Information about errors that occur while building a [`SchemaValidator`][pydantic_core.SchemaValidator] 
    or [`SchemaSerializer`][pydantic_core.SchemaSerializer]. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">error_count</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; int</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Returns: 
            The number of errors in the schema. 
        &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">errors</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">ErrorDetails</span><span class="s2">]:</span>
        <span class="s4">&quot;&quot;&quot; 
        Returns: 
            A list of [`ErrorDetails`][pydantic_core.ErrorDetails] for each error in the schema. 
        &quot;&quot;&quot;</span>

<span class="s0">class </span><span class="s1">ValidationError</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    `ValidationError` is the exception raised by `pydantic-core` when validation fails, it contains a list of errors 
    which detail why validation failed. 
    &quot;&quot;&quot;</span>
    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">from_exception_data</span><span class="s2">(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">title</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
        <span class="s1">line_errors</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">InitErrorDetails</span><span class="s2">],</span>
        <span class="s1">input_type</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s3">'python'</span><span class="s2">, </span><span class="s3">'json'</span><span class="s2">] = </span><span class="s3">'python'</span><span class="s2">,</span>
        <span class="s1">hide_input</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Python constructor for a Validation Error. 
 
        The API for constructing validation errors will probably change in the future, 
        hence the static method rather than `__init__`. 
 
        Arguments: 
            title: The title of the error, as used in the heading of `str(validation_error)` 
            line_errors: A list of [`InitErrorDetails`][pydantic_core.InitErrorDetails] which contain information 
                about errors that occurred during validation. 
            input_type: Whether the error is for a Python object or JSON. 
            hide_input: Whether to hide the input value in the error message. 
        &quot;&quot;&quot;</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">title</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot; 
        The title of the error, as used in the heading of `str(validation_error)`. 
        &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">error_count</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; int</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Returns: 
            The number of errors in the validation error. 
        &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">errors</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, *, </span><span class="s1">include_url</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">, </span><span class="s1">include_context</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">, </span><span class="s1">include_input</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span>
    <span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">ErrorDetails</span><span class="s2">]:</span>
        <span class="s4">&quot;&quot;&quot; 
        Details about each error in the validation error. 
 
        Args: 
            include_url: Whether to include a URL to documentation on the error each error. 
            include_context: Whether to include the context of each error. 
            include_input: Whether to include the input value of each error. 
 
        Returns: 
            A list of [`ErrorDetails`][pydantic_core.ErrorDetails] for each error in the validation error. 
        &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">json</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">indent</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">include_url</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">include_context</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">include_input</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Same as [`errors()`][pydantic_core.ValidationError.errors] but returns a JSON string. 
 
        Args: 
            indent: The number of spaces to indent the JSON by, or `None` for no indentation - compact JSON. 
            include_url: Whether to include a URL to documentation on the error each error. 
            include_context: Whether to include the context of each error. 
            include_input: Whether to include the input value of each error. 
 
        Returns: 
            a JSON string. 
        &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot; 
        A string representation of the validation error. 
 
        Whether or not documentation URLs are included in the repr is controlled by the 
        environment variable `PYDANTIC_ERRORS_INCLUDE_URL` being set to `1` or 
        `true`; by default, URLs are shown. 
 
        Due to implementation details, this environment variable can only be set once, 
        before the first validation error is created. 
        &quot;&quot;&quot;</span>

<span class="s0">class </span><span class="s1">PydanticCustomError</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;A custom exception providing flexible error handling for Pydantic validators. 
 
    You can raise this error in custom validators when you'd like flexibility in regards to the error type, message, and context. 
 
    Example: 
        ```py 
        from pydantic_core import PydanticCustomError 
 
        def custom_validator(v) -&gt; None: 
            if v &lt;= 10: 
                raise PydanticCustomError('custom_value_error', 'Value must be greater than {value}', {'value': 10, 'extra_context': 'extra_data'}) 
            return v 
        ``` 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">error_type</span><span class="s2">: </span><span class="s1">LiteralString</span><span class="s2">, </span><span class="s1">message_template</span><span class="s2">: </span><span class="s1">LiteralString</span><span class="s2">, </span><span class="s1">context</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot;Initializes the `PydanticCustomError`. 
 
        Arguments: 
            error_type: The error type. 
            message_template: The message template. 
            context: The data to inject into the message template. 
        &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span>
        <span class="s1">cls</span><span class="s2">, </span><span class="s1">error_type</span><span class="s2">: </span><span class="s1">LiteralString</span><span class="s2">, </span><span class="s1">message_template</span><span class="s2">: </span><span class="s1">LiteralString</span><span class="s2">, </span><span class="s1">context</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">: ...</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">context</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] | </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot;Values which are required to render the error message, and could hence be useful in passing error data forward.&quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot;The error type associated with the error. For consistency with Pydantic, this is typically a snake_case string.&quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">message_template</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot;The message template associated with the error. This is a string that can be formatted with context variables in `{curly_braces}`.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">message</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot;The formatted message associated with the error. This presents as the message template with context variables appropriately injected.&quot;&quot;&quot;</span>

<span class="s2">@</span><span class="s1">final</span>
<span class="s0">class </span><span class="s1">PydanticKnownError</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;A helper class for raising exceptions that mimic Pydantic's built-in exceptions, with more flexibility in regards to context. 
 
    Unlike [`PydanticCustomError`][pydantic_core.PydanticCustomError], the `error_type` argument must be a known `ErrorType`. 
 
    Example: 
        ```py 
        from pydantic_core import PydanticKnownError 
 
        def custom_validator(v) -&gt; None: 
            if v &lt;= 10: 
                raise PydanticKnownError(error_type='greater_than', context={'gt': 10}) 
            return v 
        ``` 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">error_type</span><span class="s2">: </span><span class="s1">ErrorType</span><span class="s2">, </span><span class="s1">context</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot;Initializes the `PydanticKnownError`. 
 
        Arguments: 
            error_type: The error type. 
            context: The data to inject into the message template. 
        &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">error_type</span><span class="s2">: </span><span class="s1">ErrorType</span><span class="s2">, </span><span class="s1">context</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">: ...</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">context</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] | </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot;Values which are required to render the error message, and could hence be useful in passing error data forward.&quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; ErrorType</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot;The type of the error.&quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">message_template</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot;The message template associated with the provided error type. This is a string that can be formatted with context variables in `{curly_braces}`.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">message</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot;The formatted message associated with the error. This presents as the message template with context variables appropriately injected.&quot;&quot;&quot;</span>

<span class="s2">@</span><span class="s1">final</span>
<span class="s0">class </span><span class="s1">PydanticOmit</span><span class="s2">(</span><span class="s1">Exception</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;An exception to signal that a field should be omitted from a generated result. 
 
    This could span from omitting a field from a JSON Schema to omitting a field from a serialized result. 
    Upcoming: more robust support for using PydanticOmit in custom serializers is still in development. 
    Right now, this is primarily used in the JSON Schema generation process. 
 
    Example: 
        ```py 
        from typing import Callable 
 
        from pydantic_core import PydanticOmit 
 
        from pydantic import BaseModel 
        from pydantic.json_schema import GenerateJsonSchema, JsonSchemaValue 
 
 
        class MyGenerateJsonSchema(GenerateJsonSchema): 
            def handle_invalid_for_json_schema(self, schema, error_info) -&gt; JsonSchemaValue: 
                raise PydanticOmit 
 
 
        class Predicate(BaseModel): 
            name: str = 'no-op' 
            func: Callable = lambda x: x 
 
 
        instance_example = Predicate() 
 
        validation_schema = instance_example.model_json_schema(schema_generator=MyGenerateJsonSchema, mode='validation') 
        print(validation_schema) 
        ''' 
        {'properties': {'name': {'default': 'no-op', 'title': 'Name', 'type': 'string'}}, 'title': 'Predicate', 'type': 'object'} 
        ''' 
        ``` 
 
    For a more in depth example / explanation, see the [customizing JSON schema](../concepts/json_schema.md#customizing-the-json-schema-generation-process) docs. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">: ...</span>

<span class="s2">@</span><span class="s1">final</span>
<span class="s0">class </span><span class="s1">PydanticUseDefault</span><span class="s2">(</span><span class="s1">Exception</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;An exception to signal that standard validation either failed or should be skipped, and the default value should be used instead. 
 
    This warning can be raised in custom valiation functions to redirect the flow of validation. 
 
    Example: 
        ```py 
        from pydantic_core import PydanticUseDefault 
        from datetime import datetime 
        from pydantic import BaseModel, field_validator 
 
 
        class Event(BaseModel): 
            name: str = 'meeting' 
            time: datetime 
 
            @field_validator('name', mode='plain') 
            def name_must_be_present(cls, v) -&gt; str: 
                if not v or not isinstance(v, str): 
                    raise PydanticUseDefault() 
                return v 
 
 
        event1 = Event(name='party', time=datetime(2024, 1, 1, 12, 0, 0)) 
        print(repr(event1)) 
        # &gt; Event(name='party', time=datetime.datetime(2024, 1, 1, 12, 0)) 
        event2 = Event(time=datetime(2024, 1, 1, 12, 0, 0)) 
        print(repr(event2)) 
        # &gt; Event(name='meeting', time=datetime.datetime(2024, 1, 1, 12, 0)) 
        ``` 
 
    For an additional example, see the [validating partial json data](../concepts/json.md#partial-json-parsing) section of the Pydantic documentation. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">: ...</span>

<span class="s2">@</span><span class="s1">final</span>
<span class="s0">class </span><span class="s1">PydanticSerializationError</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;An error raised when an issue occurs during serialization. 
 
    In custom serializers, this error can be used to indicate that serialization has failed. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">message</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot;Initializes the `PydanticSerializationError`. 
 
        Arguments: 
            message: The message associated with the error. 
        &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">message</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">: ...</span>

<span class="s2">@</span><span class="s1">final</span>
<span class="s0">class </span><span class="s1">PydanticSerializationUnexpectedValue</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;An error raised when an unexpected value is encountered during serialization. 
 
    This error is often caught and coerced into a warning, as `pydantic-core` generally makes a best attempt 
    at serializing values, in contrast with validation where errors are eagerly raised. 
 
    Example: 
        ```py 
        from pydantic import BaseModel, field_serializer 
        from pydantic_core import PydanticSerializationUnexpectedValue 
 
        class BasicPoint(BaseModel): 
            x: int 
            y: int 
 
            @field_serializer('*') 
            def serialize(self, v): 
                if not isinstance(v, int): 
                    raise PydanticSerializationUnexpectedValue(f'Expected type `int`, got {type(v)} with value {v}') 
                return v 
 
        point = BasicPoint(x=1, y=2) 
        # some sort of mutation 
        point.x = 'a' 
 
        print(point.model_dump()) 
        ''' 
        UserWarning: Pydantic serializer warnings: 
        PydanticSerializationUnexpectedValue(Expected type `int`, got &lt;class 'str'&gt; with value a) 
        return self.__pydantic_serializer__.to_python( 
        {'x': 'a', 'y': 2} 
        ''' 
        ``` 
 
    This is often used internally in `pydantic-core` when unexpected types are encountered during serialization, 
    but it can also be used by users in custom serializers, as seen above. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">message</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot;Initializes the `PydanticSerializationUnexpectedValue`. 
 
        Arguments: 
            message: The message associated with the unexpected value. 
        &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">message</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">: ...</span>

<span class="s2">@</span><span class="s1">final</span>
<span class="s0">class </span><span class="s1">ArgsKwargs</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot;A construct used to store arguments and keyword arguments for a function call. 
 
    This data structure is generally used to store information for core schemas associated with functions (like in an arguments schema). 
    This data structure is also currently used for some validation against dataclasses. 
 
    Example: 
        ```py 
        from pydantic.dataclasses import dataclass 
        from pydantic import model_validator 
 
 
        @dataclass 
        class Model: 
            a: int 
            b: int 
 
            @model_validator(mode=&quot;before&quot;) 
            @classmethod 
            def no_op_validator(cls, values): 
                print(values) 
                return values 
 
        Model(1, b=2) 
        #&gt; ArgsKwargs((1,), {&quot;b&quot;: 2}) 
 
        Model(1, 2) 
        #&gt; ArgsKwargs((1, 2), {}) 
 
        Model(a=1, b=2) 
        #&gt; ArgsKwargs((), {&quot;a&quot;: 1, &quot;b&quot;: 2}) 
        ``` 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...], </span><span class="s1">kwargs</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot;Initializes the `ArgsKwargs`. 
 
        Arguments: 
            args: The arguments (inherently ordered) for a function call. 
            kwargs: The keyword arguments for a function call 
        &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...], </span><span class="s1">kwargs</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">: ...</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...]:</span>
        <span class="s4">&quot;&quot;&quot;The arguments (inherently ordered) for a function call.&quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">kwargs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] | </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot;The keyword arguments for a function call.&quot;&quot;&quot;</span>

<span class="s2">@</span><span class="s1">final</span>
<span class="s0">class </span><span class="s1">PydanticUndefinedType</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot;A type used as a sentinel for undefined values.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__copy__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">: ...</span>
    <span class="s0">def </span><span class="s1">__deepcopy__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">: ...</span>

<span class="s1">PydanticUndefined</span><span class="s2">: </span><span class="s1">PydanticUndefinedType</span>

<span class="s0">def </span><span class="s1">list_all_errors</span><span class="s2">() </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">ErrorTypeInfo</span><span class="s2">]:</span>
    <span class="s4">&quot;&quot;&quot; 
    Get information about all built-in errors. 
 
    Returns: 
        A list of `ErrorTypeInfo` typed dicts. 
    &quot;&quot;&quot;</span>
<span class="s2">@</span><span class="s1">final</span>
<span class="s0">class </span><span class="s1">TzInfo</span><span class="s2">(</span><span class="s1">datetime</span><span class="s2">.</span><span class="s1">tzinfo</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;An `pydantic-core` implementation of the abstract [`datetime.tzinfo`][] class.&quot;&quot;&quot;</span>

    <span class="s5"># def __new__(cls, seconds: float) -&gt; Self: ...</span>

    <span class="s5"># Docstrings for attributes sourced from the abstract base class, [`datetime.tzinfo`](https://docs.python.org/3/library/datetime.html#datetime.tzinfo).</span>

    <span class="s0">def </span><span class="s1">tzname</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">: </span><span class="s1">datetime</span><span class="s2">.</span><span class="s1">datetime </span><span class="s2">| </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; str </span><span class="s2">| </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot;Return the time zone name corresponding to the [`datetime`][datetime.datetime] object _dt_, as a string. 
 
        For more info, see [`tzinfo.tzname`][datetime.tzinfo.tzname]. 
        &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">utcoffset</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">: </span><span class="s1">datetime</span><span class="s2">.</span><span class="s1">datetime </span><span class="s2">| </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; datetime</span><span class="s2">.</span><span class="s1">timedelta </span><span class="s2">| </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot;Return offset of local time from UTC, as a [`timedelta`][datetime.timedelta] object that is positive east of UTC. If local time is west of UTC, this should be negative. 
 
        More info can be found at [`tzinfo.utcoffset`][datetime.tzinfo.utcoffset]. 
        &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">dst</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">: </span><span class="s1">datetime</span><span class="s2">.</span><span class="s1">datetime </span><span class="s2">| </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; datetime</span><span class="s2">.</span><span class="s1">timedelta </span><span class="s2">| </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot;Return the daylight saving time (DST) adjustment, as a [`timedelta`][datetime.timedelta] object or `None` if DST information isn’t known. 
 
        More info can be found at[`tzinfo.dst`][datetime.tzinfo.dst].&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">fromutc</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">: </span><span class="s1">datetime</span><span class="s2">.</span><span class="s1">datetime</span><span class="s2">) </span><span class="s1">-&gt; datetime</span><span class="s2">.</span><span class="s1">datetime</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot;Adjust the date and time data associated datetime object _dt_, returning an equivalent datetime in self’s local time. 
 
        More info can be found at [`tzinfo.fromutc`][datetime.tzinfo.fromutc].&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__deepcopy__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">_memo</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]) </span><span class="s1">-&gt; TzInfo</span><span class="s2">: ...</span>

<span class="s0">def </span><span class="s1">validate_core_schema</span><span class="s2">(</span><span class="s1">schema</span><span class="s2">: </span><span class="s1">CoreSchema</span><span class="s2">, *, </span><span class="s1">strict</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; CoreSchema</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot;Validate a core schema. 
 
    This currently uses lax mode for validation (i.e. will coerce strings to dates and such) 
    but may use strict mode in the future. 
    We may also remove this function altogether, do not rely on it being present if you are 
    using pydantic-core directly. 
    &quot;&quot;&quot;</span>
</pre>
</body>
</html>