<html>
<head>
<title>_hypothesis_plugin.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_hypothesis_plugin.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Register Hypothesis strategies for Pydantic custom types. 
 
This enables fully-automatic generation of test data for most Pydantic classes. 
 
Note that this module has *no* runtime impact on Pydantic itself; instead it 
is registered as a setuptools entry point and Hypothesis will import it if 
Pydantic is installed.  See also: 
 
https://hypothesis.readthedocs.io/en/latest/strategies.html#registering-strategies-via-setuptools-entry-points 
https://hypothesis.readthedocs.io/en/latest/data.html#hypothesis.strategies.register_type_strategy 
https://hypothesis.readthedocs.io/en/latest/strategies.html#interaction-with-pytest-cov 
https://docs.pydantic.dev/usage/types/#pydantic-types 
 
Note that because our motivation is to *improve user experience*, the strategies 
are always sound (never generate invalid data) but sacrifice completeness for 
maintainability (ie may be unable to generate some tricky but valid data). 
 
Finally, this module makes liberal use of `# type: ignore[&lt;code&gt;]` pragmas. 
This is because Hypothesis annotates `register_type_strategy()` with 
`(T, SearchStrategy[T])`, but in most cases we register e.g. `ConstrainedInt` 
to generate instances of the builtin `int` type which match the constraints. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">contextlib</span>
<span class="s2">import </span><span class="s1">datetime</span>
<span class="s2">import </span><span class="s1">ipaddress</span>
<span class="s2">import </span><span class="s1">json</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">from </span><span class="s1">fractions </span><span class="s2">import </span><span class="s1">Fraction</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Callable</span><span class="s3">, </span><span class="s1">Dict</span><span class="s3">, </span><span class="s1">Type</span><span class="s3">, </span><span class="s1">Union</span><span class="s3">, </span><span class="s1">cast</span><span class="s3">, </span><span class="s1">overload</span>

<span class="s2">import </span><span class="s1">hypothesis</span><span class="s3">.</span><span class="s1">strategies </span><span class="s2">as </span><span class="s1">st</span>

<span class="s2">import </span><span class="s1">pydantic</span>
<span class="s2">import </span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">color</span>
<span class="s2">import </span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">types</span>
<span class="s2">from </span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">v1</span><span class="s3">.</span><span class="s1">utils </span><span class="s2">import </span><span class="s1">lenient_issubclass</span>

<span class="s4"># FilePath and DirectoryPath are explicitly unsupported, as we'd have to create</span>
<span class="s4"># them on-disk, and that's unsafe in general without being told *where* to do so.</span>
<span class="s4">#</span>
<span class="s4"># URLs are unsupported because it's easy for users to define their own strategy for</span>
<span class="s4"># &quot;normal&quot; URLs, and hard for us to define a general strategy which includes &quot;weird&quot;</span>
<span class="s4"># URLs but doesn't also have unpredictable performance problems.</span>
<span class="s4">#</span>
<span class="s4"># conlist() and conset() are unsupported for now, because the workarounds for</span>
<span class="s4"># Cython and Hypothesis to handle parametrized generic types are incompatible.</span>
<span class="s4"># We are rethinking Hypothesis compatibility in Pydantic v2.</span>

<span class="s4"># Emails</span>
<span class="s2">try</span><span class="s3">:</span>
    <span class="s2">import </span><span class="s1">email_validator</span>
<span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:  </span><span class="s4"># pragma: no cover</span>
    <span class="s2">pass</span>
<span class="s2">else</span><span class="s3">:</span>

    <span class="s2">def </span><span class="s1">is_valid_email</span><span class="s3">(</span><span class="s1">s</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s4"># Hypothesis' st.emails() occasionally generates emails like 0@A0--0.ac</span>
        <span class="s4"># that are invalid according to email-validator, so we filter those out.</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">email_validator</span><span class="s3">.</span><span class="s1">validate_email</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">check_deliverability</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
            <span class="s2">return True</span>
        <span class="s2">except </span><span class="s1">email_validator</span><span class="s3">.</span><span class="s1">EmailNotValidError</span><span class="s3">:  </span><span class="s4"># pragma: no cover</span>
            <span class="s2">return False</span>

    <span class="s4"># Note that these strategies deliberately stay away from any tricky Unicode</span>
    <span class="s4"># or other encoding issues; we're just trying to generate *something* valid.</span>
    <span class="s1">st</span><span class="s3">.</span><span class="s1">register_type_strategy</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">EmailStr</span><span class="s3">, </span><span class="s1">st</span><span class="s3">.</span><span class="s1">emails</span><span class="s3">().</span><span class="s1">filter</span><span class="s3">(</span><span class="s1">is_valid_email</span><span class="s3">))  </span><span class="s4"># type: ignore[arg-type]</span>
    <span class="s1">st</span><span class="s3">.</span><span class="s1">register_type_strategy</span><span class="s3">(</span>
        <span class="s1">pydantic</span><span class="s3">.</span><span class="s1">NameEmail</span><span class="s3">,</span>
        <span class="s1">st</span><span class="s3">.</span><span class="s1">builds</span><span class="s3">(</span>
            <span class="s5">'{} &lt;{}&gt;'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">,  </span><span class="s4"># type: ignore[arg-type]</span>
            <span class="s1">st</span><span class="s3">.</span><span class="s1">from_regex</span><span class="s3">(</span><span class="s5">'[A-Za-z0-9_]+( [A-Za-z0-9_]+){0,5}'</span><span class="s3">, </span><span class="s1">fullmatch</span><span class="s3">=</span><span class="s2">True</span><span class="s3">),</span>
            <span class="s1">st</span><span class="s3">.</span><span class="s1">emails</span><span class="s3">().</span><span class="s1">filter</span><span class="s3">(</span><span class="s1">is_valid_email</span><span class="s3">),</span>
        <span class="s3">),</span>
    <span class="s3">)</span>

<span class="s4"># PyObject - dotted names, in this case taken from the math module.</span>
<span class="s1">st</span><span class="s3">.</span><span class="s1">register_type_strategy</span><span class="s3">(</span>
    <span class="s1">pydantic</span><span class="s3">.</span><span class="s1">PyObject</span><span class="s3">,  </span><span class="s4"># type: ignore[arg-type]</span>
    <span class="s1">st</span><span class="s3">.</span><span class="s1">sampled_from</span><span class="s3">(</span>
        <span class="s3">[</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">PyObject</span><span class="s3">, </span><span class="s5">f'math.</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">'</span><span class="s3">) </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">vars</span><span class="s3">(</span><span class="s1">math</span><span class="s3">)) </span><span class="s2">if not </span><span class="s1">name</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">'_'</span><span class="s3">)]</span>
    <span class="s3">),</span>
<span class="s3">)</span>

<span class="s4"># CSS3 Colors; as name, hex, rgb(a) tuples or strings, or hsl strings</span>
<span class="s1">_color_regexes </span><span class="s3">= (</span>
    <span class="s5">'|'</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span>
        <span class="s3">(</span>
            <span class="s1">pydantic</span><span class="s3">.</span><span class="s1">color</span><span class="s3">.</span><span class="s1">r_hex_short</span><span class="s3">,</span>
            <span class="s1">pydantic</span><span class="s3">.</span><span class="s1">color</span><span class="s3">.</span><span class="s1">r_hex_long</span><span class="s3">,</span>
            <span class="s1">pydantic</span><span class="s3">.</span><span class="s1">color</span><span class="s3">.</span><span class="s1">r_rgb</span><span class="s3">,</span>
            <span class="s1">pydantic</span><span class="s3">.</span><span class="s1">color</span><span class="s3">.</span><span class="s1">r_rgba</span><span class="s3">,</span>
            <span class="s1">pydantic</span><span class="s3">.</span><span class="s1">color</span><span class="s3">.</span><span class="s1">r_hsl</span><span class="s3">,</span>
            <span class="s1">pydantic</span><span class="s3">.</span><span class="s1">color</span><span class="s3">.</span><span class="s1">r_hsla</span><span class="s3">,</span>
        <span class="s3">)</span>
    <span class="s3">)</span>
    <span class="s4"># Use more precise regex patterns to avoid value-out-of-range errors</span>
    <span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">color</span><span class="s3">.</span><span class="s1">_r_sl</span><span class="s3">, </span><span class="s5">r'(?:(\d\d?(?:\.\d+)?|100(?:\.0+)?)%)'</span><span class="s3">)</span>
    <span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">color</span><span class="s3">.</span><span class="s1">_r_alpha</span><span class="s3">, </span><span class="s5">r'(?:(0(?:\.\d+)?|1(?:\.0+)?|\.\d+|\d{1,2}%))'</span><span class="s3">)</span>
    <span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">color</span><span class="s3">.</span><span class="s1">_r_255</span><span class="s3">, </span><span class="s5">r'(?:((?:\d|\d\d|[01]\d\d|2[0-4]\d|25[0-4])(?:\.\d+)?|255(?:\.0+)?))'</span><span class="s3">)</span>
<span class="s3">)</span>
<span class="s1">st</span><span class="s3">.</span><span class="s1">register_type_strategy</span><span class="s3">(</span>
    <span class="s1">pydantic</span><span class="s3">.</span><span class="s1">color</span><span class="s3">.</span><span class="s1">Color</span><span class="s3">,</span>
    <span class="s1">st</span><span class="s3">.</span><span class="s1">one_of</span><span class="s3">(</span>
        <span class="s1">st</span><span class="s3">.</span><span class="s1">sampled_from</span><span class="s3">(</span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">color</span><span class="s3">.</span><span class="s1">COLORS_BY_NAME</span><span class="s3">)),</span>
        <span class="s1">st</span><span class="s3">.</span><span class="s1">tuples</span><span class="s3">(</span>
            <span class="s1">st</span><span class="s3">.</span><span class="s1">integers</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s6">255</span><span class="s3">),</span>
            <span class="s1">st</span><span class="s3">.</span><span class="s1">integers</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s6">255</span><span class="s3">),</span>
            <span class="s1">st</span><span class="s3">.</span><span class="s1">integers</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s6">255</span><span class="s3">),</span>
            <span class="s1">st</span><span class="s3">.</span><span class="s1">none</span><span class="s3">() | </span><span class="s1">st</span><span class="s3">.</span><span class="s1">floats</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s6">1</span><span class="s3">) | </span><span class="s1">st</span><span class="s3">.</span><span class="s1">floats</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s6">100</span><span class="s3">).</span><span class="s1">map</span><span class="s3">(</span><span class="s5">'{}%'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">),</span>
        <span class="s3">),</span>
        <span class="s1">st</span><span class="s3">.</span><span class="s1">from_regex</span><span class="s3">(</span><span class="s1">_color_regexes</span><span class="s3">, </span><span class="s1">fullmatch</span><span class="s3">=</span><span class="s2">True</span><span class="s3">),</span>
    <span class="s3">),</span>
<span class="s3">)</span>


<span class="s4"># Card numbers, valid according to the Luhn algorithm</span>


<span class="s2">def </span><span class="s1">add_luhn_digit</span><span class="s3">(</span><span class="s1">card_number</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
    <span class="s4"># See https://en.wikipedia.org/wiki/Luhn_algorithm</span>
    <span class="s2">for </span><span class="s1">digit </span><span class="s2">in </span><span class="s5">'0123456789'</span><span class="s3">:</span>
        <span class="s2">with </span><span class="s1">contextlib</span><span class="s3">.</span><span class="s1">suppress</span><span class="s3">(</span><span class="s1">Exception</span><span class="s3">):</span>
            <span class="s1">pydantic</span><span class="s3">.</span><span class="s1">PaymentCardNumber</span><span class="s3">.</span><span class="s1">validate_luhn_check_digit</span><span class="s3">(</span><span class="s1">card_number </span><span class="s3">+ </span><span class="s1">digit</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">card_number </span><span class="s3">+ </span><span class="s1">digit</span>
    <span class="s2">raise </span><span class="s1">AssertionError</span><span class="s3">(</span><span class="s5">'Unreachable'</span><span class="s3">)  </span><span class="s4"># pragma: no cover</span>


<span class="s1">card_patterns </span><span class="s3">= (</span>
    <span class="s4"># Note that these patterns omit the Luhn check digit; that's added by the function above</span>
    <span class="s5">'4[0-9]{14}'</span><span class="s3">,  </span><span class="s4"># Visa</span>
    <span class="s5">'5[12345][0-9]{13}'</span><span class="s3">,  </span><span class="s4"># Mastercard</span>
    <span class="s5">'3[47][0-9]{12}'</span><span class="s3">,  </span><span class="s4"># American Express</span>
    <span class="s5">'[0-26-9][0-9]{10,17}'</span><span class="s3">,  </span><span class="s4"># other (incomplete to avoid overlap)</span>
<span class="s3">)</span>
<span class="s1">st</span><span class="s3">.</span><span class="s1">register_type_strategy</span><span class="s3">(</span>
    <span class="s1">pydantic</span><span class="s3">.</span><span class="s1">PaymentCardNumber</span><span class="s3">,</span>
    <span class="s1">st</span><span class="s3">.</span><span class="s1">from_regex</span><span class="s3">(</span><span class="s5">'|'</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">card_patterns</span><span class="s3">), </span><span class="s1">fullmatch</span><span class="s3">=</span><span class="s2">True</span><span class="s3">).</span><span class="s1">map</span><span class="s3">(</span><span class="s1">add_luhn_digit</span><span class="s3">),  </span><span class="s4"># type: ignore[arg-type]</span>
<span class="s3">)</span>

<span class="s4"># UUIDs</span>
<span class="s1">st</span><span class="s3">.</span><span class="s1">register_type_strategy</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">UUID1</span><span class="s3">, </span><span class="s1">st</span><span class="s3">.</span><span class="s1">uuids</span><span class="s3">(</span><span class="s1">version</span><span class="s3">=</span><span class="s6">1</span><span class="s3">))</span>
<span class="s1">st</span><span class="s3">.</span><span class="s1">register_type_strategy</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">UUID3</span><span class="s3">, </span><span class="s1">st</span><span class="s3">.</span><span class="s1">uuids</span><span class="s3">(</span><span class="s1">version</span><span class="s3">=</span><span class="s6">3</span><span class="s3">))</span>
<span class="s1">st</span><span class="s3">.</span><span class="s1">register_type_strategy</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">UUID4</span><span class="s3">, </span><span class="s1">st</span><span class="s3">.</span><span class="s1">uuids</span><span class="s3">(</span><span class="s1">version</span><span class="s3">=</span><span class="s6">4</span><span class="s3">))</span>
<span class="s1">st</span><span class="s3">.</span><span class="s1">register_type_strategy</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">UUID5</span><span class="s3">, </span><span class="s1">st</span><span class="s3">.</span><span class="s1">uuids</span><span class="s3">(</span><span class="s1">version</span><span class="s3">=</span><span class="s6">5</span><span class="s3">))</span>

<span class="s4"># Secrets</span>
<span class="s1">st</span><span class="s3">.</span><span class="s1">register_type_strategy</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">SecretBytes</span><span class="s3">, </span><span class="s1">st</span><span class="s3">.</span><span class="s1">binary</span><span class="s3">().</span><span class="s1">map</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">SecretBytes</span><span class="s3">))</span>
<span class="s1">st</span><span class="s3">.</span><span class="s1">register_type_strategy</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">SecretStr</span><span class="s3">, </span><span class="s1">st</span><span class="s3">.</span><span class="s1">text</span><span class="s3">().</span><span class="s1">map</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">SecretStr</span><span class="s3">))</span>

<span class="s4"># IP addresses, networks, and interfaces</span>
<span class="s1">st</span><span class="s3">.</span><span class="s1">register_type_strategy</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">IPvAnyAddress</span><span class="s3">, </span><span class="s1">st</span><span class="s3">.</span><span class="s1">ip_addresses</span><span class="s3">())  </span><span class="s4"># type: ignore[arg-type]</span>
<span class="s1">st</span><span class="s3">.</span><span class="s1">register_type_strategy</span><span class="s3">(</span>
    <span class="s1">pydantic</span><span class="s3">.</span><span class="s1">IPvAnyInterface</span><span class="s3">,</span>
    <span class="s1">st</span><span class="s3">.</span><span class="s1">from_type</span><span class="s3">(</span><span class="s1">ipaddress</span><span class="s3">.</span><span class="s1">IPv4Interface</span><span class="s3">) | </span><span class="s1">st</span><span class="s3">.</span><span class="s1">from_type</span><span class="s3">(</span><span class="s1">ipaddress</span><span class="s3">.</span><span class="s1">IPv6Interface</span><span class="s3">),  </span><span class="s4"># type: ignore[arg-type]</span>
<span class="s3">)</span>
<span class="s1">st</span><span class="s3">.</span><span class="s1">register_type_strategy</span><span class="s3">(</span>
    <span class="s1">pydantic</span><span class="s3">.</span><span class="s1">IPvAnyNetwork</span><span class="s3">,</span>
    <span class="s1">st</span><span class="s3">.</span><span class="s1">from_type</span><span class="s3">(</span><span class="s1">ipaddress</span><span class="s3">.</span><span class="s1">IPv4Network</span><span class="s3">) | </span><span class="s1">st</span><span class="s3">.</span><span class="s1">from_type</span><span class="s3">(</span><span class="s1">ipaddress</span><span class="s3">.</span><span class="s1">IPv6Network</span><span class="s3">),  </span><span class="s4"># type: ignore[arg-type]</span>
<span class="s3">)</span>

<span class="s4"># We hook into the con***() functions and the ConstrainedNumberMeta metaclass,</span>
<span class="s4"># so here we only have to register subclasses for other constrained types which</span>
<span class="s4"># don't go via those mechanisms.  Then there are the registration hooks below.</span>
<span class="s1">st</span><span class="s3">.</span><span class="s1">register_type_strategy</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">StrictBool</span><span class="s3">, </span><span class="s1">st</span><span class="s3">.</span><span class="s1">booleans</span><span class="s3">())</span>
<span class="s1">st</span><span class="s3">.</span><span class="s1">register_type_strategy</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">StrictStr</span><span class="s3">, </span><span class="s1">st</span><span class="s3">.</span><span class="s1">text</span><span class="s3">())</span>


<span class="s4"># FutureDate, PastDate</span>
<span class="s1">st</span><span class="s3">.</span><span class="s1">register_type_strategy</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">FutureDate</span><span class="s3">, </span><span class="s1">st</span><span class="s3">.</span><span class="s1">dates</span><span class="s3">(</span><span class="s1">min_value</span><span class="s3">=</span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">date</span><span class="s3">.</span><span class="s1">today</span><span class="s3">() + </span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">timedelta</span><span class="s3">(</span><span class="s1">days</span><span class="s3">=</span><span class="s6">1</span><span class="s3">)))</span>
<span class="s1">st</span><span class="s3">.</span><span class="s1">register_type_strategy</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">PastDate</span><span class="s3">, </span><span class="s1">st</span><span class="s3">.</span><span class="s1">dates</span><span class="s3">(</span><span class="s1">max_value</span><span class="s3">=</span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">date</span><span class="s3">.</span><span class="s1">today</span><span class="s3">() - </span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">timedelta</span><span class="s3">(</span><span class="s1">days</span><span class="s3">=</span><span class="s6">1</span><span class="s3">)))</span>


<span class="s4"># Constrained-type resolver functions</span>
<span class="s4">#</span>
<span class="s4"># For these ones, we actually want to inspect the type in order to work out a</span>
<span class="s4"># satisfying strategy.  First up, the machinery for tracking resolver functions:</span>

<span class="s1">RESOLVERS</span><span class="s3">: </span><span class="s1">Dict</span><span class="s3">[</span><span class="s1">type</span><span class="s3">, </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">type</span><span class="s3">], </span><span class="s1">st</span><span class="s3">.</span><span class="s1">SearchStrategy</span><span class="s3">]] = {}  </span><span class="s4"># type: ignore[type-arg]</span>


<span class="s3">@</span><span class="s1">overload</span>
<span class="s2">def </span><span class="s1">_registered</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">: </span><span class="s1">Type</span><span class="s3">[</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">types</span><span class="s3">.</span><span class="s1">T</span><span class="s3">]) </span><span class="s1">-&gt; Type</span><span class="s3">[</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">types</span><span class="s3">.</span><span class="s1">T</span><span class="s3">]:</span>
    <span class="s2">pass</span>


<span class="s3">@</span><span class="s1">overload</span>
<span class="s2">def </span><span class="s1">_registered</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">: </span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">types</span><span class="s3">.</span><span class="s1">ConstrainedNumberMeta</span><span class="s3">) </span><span class="s1">-&gt; pydantic</span><span class="s3">.</span><span class="s1">types</span><span class="s3">.</span><span class="s1">ConstrainedNumberMeta</span><span class="s3">:</span>
    <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">_registered</span><span class="s3">(</span>
    <span class="s1">typ</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">Type</span><span class="s3">[</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">types</span><span class="s3">.</span><span class="s1">T</span><span class="s3">], </span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">types</span><span class="s3">.</span><span class="s1">ConstrainedNumberMeta</span><span class="s3">]</span>
<span class="s3">) </span><span class="s1">-&gt; Union</span><span class="s3">[</span><span class="s1">Type</span><span class="s3">[</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">types</span><span class="s3">.</span><span class="s1">T</span><span class="s3">], </span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">types</span><span class="s3">.</span><span class="s1">ConstrainedNumberMeta</span><span class="s3">]:</span>
    <span class="s4"># This function replaces the version in `pydantic.types`, in order to</span>
    <span class="s4"># effect the registration of new constrained types so that Hypothesis</span>
    <span class="s4"># can generate valid examples.</span>
    <span class="s1">pydantic</span><span class="s3">.</span><span class="s1">types</span><span class="s3">.</span><span class="s1">_DEFINED_TYPES</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">supertype</span><span class="s3">, </span><span class="s1">resolver </span><span class="s2">in </span><span class="s1">RESOLVERS</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s2">if </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">, </span><span class="s1">supertype</span><span class="s3">):</span>
            <span class="s1">st</span><span class="s3">.</span><span class="s1">register_type_strategy</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">, </span><span class="s1">resolver</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">))  </span><span class="s4"># type: ignore</span>
            <span class="s2">return </span><span class="s1">typ</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s5">f'Unknown type </span><span class="s2">{</span><span class="s1">typ</span><span class="s2">!r} </span><span class="s5">has no resolver to register'</span><span class="s3">)  </span><span class="s4"># pragma: no cover</span>


<span class="s2">def </span><span class="s1">resolves</span><span class="s3">(</span>
    <span class="s1">typ</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">type</span><span class="s3">, </span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">types</span><span class="s3">.</span><span class="s1">ConstrainedNumberMeta</span><span class="s3">]</span>
<span class="s3">) </span><span class="s1">-&gt; Callable</span><span class="s3">[[</span><span class="s1">Callable</span><span class="s3">[..., </span><span class="s1">st</span><span class="s3">.</span><span class="s1">SearchStrategy</span><span class="s3">]], </span><span class="s1">Callable</span><span class="s3">[..., </span><span class="s1">st</span><span class="s3">.</span><span class="s1">SearchStrategy</span><span class="s3">]]:  </span><span class="s4"># type: ignore[type-arg]</span>
    <span class="s2">def </span><span class="s1">inner</span><span class="s3">(</span><span class="s1">f</span><span class="s3">):  </span><span class="s4"># type: ignore</span>
        <span class="s2">assert </span><span class="s1">f </span><span class="s2">not in </span><span class="s1">RESOLVERS</span>
        <span class="s1">RESOLVERS</span><span class="s3">[</span><span class="s1">typ</span><span class="s3">] = </span><span class="s1">f</span>
        <span class="s2">return </span><span class="s1">f</span>

    <span class="s2">return </span><span class="s1">inner</span>


<span class="s4"># Type-to-strategy resolver functions</span>


<span class="s3">@</span><span class="s1">resolves</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">JsonWrapper</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">resolve_json</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">):  </span><span class="s4"># type: ignore[no-untyped-def]</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">inner </span><span class="s3">= </span><span class="s1">st</span><span class="s3">.</span><span class="s1">none</span><span class="s3">() </span><span class="s2">if </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">inner_type </span><span class="s2">is None else </span><span class="s1">st</span><span class="s3">.</span><span class="s1">from_type</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">inner_type</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">Exception</span><span class="s3">:  </span><span class="s4"># pragma: no cover</span>
        <span class="s1">finite </span><span class="s3">= </span><span class="s1">st</span><span class="s3">.</span><span class="s1">floats</span><span class="s3">(</span><span class="s1">allow_infinity</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">allow_nan</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s1">inner </span><span class="s3">= </span><span class="s1">st</span><span class="s3">.</span><span class="s1">recursive</span><span class="s3">(</span>
            <span class="s1">base</span><span class="s3">=</span><span class="s1">st</span><span class="s3">.</span><span class="s1">one_of</span><span class="s3">(</span><span class="s1">st</span><span class="s3">.</span><span class="s1">none</span><span class="s3">(), </span><span class="s1">st</span><span class="s3">.</span><span class="s1">booleans</span><span class="s3">(), </span><span class="s1">st</span><span class="s3">.</span><span class="s1">integers</span><span class="s3">(), </span><span class="s1">finite</span><span class="s3">, </span><span class="s1">st</span><span class="s3">.</span><span class="s1">text</span><span class="s3">()),</span>
            <span class="s1">extend</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">st</span><span class="s3">.</span><span class="s1">lists</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) | </span><span class="s1">st</span><span class="s3">.</span><span class="s1">dictionaries</span><span class="s3">(</span><span class="s1">st</span><span class="s3">.</span><span class="s1">text</span><span class="s3">(), </span><span class="s1">x</span><span class="s3">),  </span><span class="s4"># type: ignore</span>
        <span class="s3">)</span>
    <span class="s1">inner_type </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s5">'inner_type'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">st</span><span class="s3">.</span><span class="s1">builds</span><span class="s3">(</span>
        <span class="s1">cls</span><span class="s3">.</span><span class="s1">inner_type</span><span class="s3">.</span><span class="s1">json </span><span class="s2">if </span><span class="s1">lenient_issubclass</span><span class="s3">(</span><span class="s1">inner_type</span><span class="s3">, </span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">BaseModel</span><span class="s3">) </span><span class="s2">else </span><span class="s1">json</span><span class="s3">.</span><span class="s1">dumps</span><span class="s3">,</span>
        <span class="s1">inner</span><span class="s3">,</span>
        <span class="s1">ensure_ascii</span><span class="s3">=</span><span class="s1">st</span><span class="s3">.</span><span class="s1">booleans</span><span class="s3">(),</span>
        <span class="s1">indent</span><span class="s3">=</span><span class="s1">st</span><span class="s3">.</span><span class="s1">none</span><span class="s3">() | </span><span class="s1">st</span><span class="s3">.</span><span class="s1">integers</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s6">16</span><span class="s3">),</span>
        <span class="s1">sort_keys</span><span class="s3">=</span><span class="s1">st</span><span class="s3">.</span><span class="s1">booleans</span><span class="s3">(),</span>
    <span class="s3">)</span>


<span class="s3">@</span><span class="s1">resolves</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">ConstrainedBytes</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">resolve_conbytes</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">):  </span><span class="s4"># type: ignore[no-untyped-def]  # pragma: no cover</span>
    <span class="s1">min_size </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">min_length </span><span class="s2">or </span><span class="s6">0</span>
    <span class="s1">max_size </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">max_length</span>
    <span class="s2">if not </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">strip_whitespace</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">st</span><span class="s3">.</span><span class="s1">binary</span><span class="s3">(</span><span class="s1">min_size</span><span class="s3">=</span><span class="s1">min_size</span><span class="s3">, </span><span class="s1">max_size</span><span class="s3">=</span><span class="s1">max_size</span><span class="s3">)</span>
    <span class="s4"># Fun with regex to ensure we neither start nor end with whitespace</span>
    <span class="s1">repeats </span><span class="s3">= </span><span class="s5">'{{{},{}}}'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
        <span class="s1">min_size </span><span class="s3">- </span><span class="s6">2 </span><span class="s2">if </span><span class="s1">min_size </span><span class="s3">&gt; </span><span class="s6">2 </span><span class="s2">else </span><span class="s6">0</span><span class="s3">,</span>
        <span class="s1">max_size </span><span class="s3">- </span><span class="s6">2 </span><span class="s2">if </span><span class="s3">(</span><span class="s1">max_size </span><span class="s2">or </span><span class="s6">0</span><span class="s3">) &gt; </span><span class="s6">2 </span><span class="s2">else </span><span class="s5">''</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">if </span><span class="s1">min_size </span><span class="s3">&gt;= </span><span class="s6">2</span><span class="s3">:</span>
        <span class="s1">pattern </span><span class="s3">= </span><span class="s5">rf'\W.</span><span class="s2">{</span><span class="s1">repeats</span><span class="s2">}</span><span class="s5">\W'</span>
    <span class="s2">elif </span><span class="s1">min_size </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s1">pattern </span><span class="s3">= </span><span class="s5">rf'\W(.</span><span class="s2">{</span><span class="s1">repeats</span><span class="s2">}</span><span class="s5">\W)?'</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">min_size </span><span class="s3">== </span><span class="s6">0</span>
        <span class="s1">pattern </span><span class="s3">= </span><span class="s5">rf'(\W(.</span><span class="s2">{</span><span class="s1">repeats</span><span class="s2">}</span><span class="s5">\W)?)?'</span>
    <span class="s2">return </span><span class="s1">st</span><span class="s3">.</span><span class="s1">from_regex</span><span class="s3">(</span><span class="s1">pattern</span><span class="s3">.</span><span class="s1">encode</span><span class="s3">(), </span><span class="s1">fullmatch</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">resolves</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">ConstrainedDecimal</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">resolve_condecimal</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">):  </span><span class="s4"># type: ignore[no-untyped-def]</span>
    <span class="s1">min_value </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">ge</span>
    <span class="s1">max_value </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">le</span>
    <span class="s2">if </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">gt </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">min_value </span><span class="s2">is None</span><span class="s3">, </span><span class="s5">'Set `gt` or `ge`, but not both'</span>
        <span class="s1">min_value </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">gt</span>
    <span class="s2">if </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">lt </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">max_value </span><span class="s2">is None</span><span class="s3">, </span><span class="s5">'Set `lt` or `le`, but not both'</span>
        <span class="s1">max_value </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">lt</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s1">st</span><span class="s3">.</span><span class="s1">decimals</span><span class="s3">(</span><span class="s1">min_value</span><span class="s3">, </span><span class="s1">max_value</span><span class="s3">, </span><span class="s1">allow_nan</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">places</span><span class="s3">=</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">decimal_places</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">lt </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">s </span><span class="s3">= </span><span class="s1">s</span><span class="s3">.</span><span class="s1">filter</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">d</span><span class="s3">: </span><span class="s1">d </span><span class="s3">&lt; </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">lt</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">gt </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">s </span><span class="s3">= </span><span class="s1">s</span><span class="s3">.</span><span class="s1">filter</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">d</span><span class="s3">: </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">gt </span><span class="s3">&lt; </span><span class="s1">d</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">s</span>


<span class="s3">@</span><span class="s1">resolves</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">ConstrainedFloat</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">resolve_confloat</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">):  </span><span class="s4"># type: ignore[no-untyped-def]</span>
    <span class="s1">min_value </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">ge</span>
    <span class="s1">max_value </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">le</span>
    <span class="s1">exclude_min </span><span class="s3">= </span><span class="s2">False</span>
    <span class="s1">exclude_max </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s2">if </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">gt </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">min_value </span><span class="s2">is None</span><span class="s3">, </span><span class="s5">'Set `gt` or `ge`, but not both'</span>
        <span class="s1">min_value </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">gt</span>
        <span class="s1">exclude_min </span><span class="s3">= </span><span class="s2">True</span>
    <span class="s2">if </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">lt </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">max_value </span><span class="s2">is None</span><span class="s3">, </span><span class="s5">'Set `lt` or `le`, but not both'</span>
        <span class="s1">max_value </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">lt</span>
        <span class="s1">exclude_max </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s2">if </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">multiple_of </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">st</span><span class="s3">.</span><span class="s1">floats</span><span class="s3">(</span><span class="s1">min_value</span><span class="s3">, </span><span class="s1">max_value</span><span class="s3">, </span><span class="s1">exclude_min</span><span class="s3">=</span><span class="s1">exclude_min</span><span class="s3">, </span><span class="s1">exclude_max</span><span class="s3">=</span><span class="s1">exclude_max</span><span class="s3">, </span><span class="s1">allow_nan</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">min_value </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">min_value </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">min_value </span><span class="s3">/ </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">multiple_of</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">exclude_min</span><span class="s3">:</span>
            <span class="s1">min_value </span><span class="s3">= </span><span class="s1">min_value </span><span class="s3">+ </span><span class="s6">1</span>
    <span class="s2">if </span><span class="s1">max_value </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">max_value </span><span class="s3">&gt;= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">multiple_of</span><span class="s3">, </span><span class="s5">'Cannot build model with max value smaller than multiple of'</span>
        <span class="s1">max_value </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">max_value </span><span class="s3">/ </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">multiple_of</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">exclude_max</span><span class="s3">:</span>
            <span class="s1">max_value </span><span class="s3">= </span><span class="s1">max_value </span><span class="s3">- </span><span class="s6">1</span>

    <span class="s2">return </span><span class="s1">st</span><span class="s3">.</span><span class="s1">integers</span><span class="s3">(</span><span class="s1">min_value</span><span class="s3">, </span><span class="s1">max_value</span><span class="s3">).</span><span class="s1">map</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">x </span><span class="s3">* </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">multiple_of</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">resolves</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">ConstrainedInt</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">resolve_conint</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">):  </span><span class="s4"># type: ignore[no-untyped-def]</span>
    <span class="s1">min_value </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">ge</span>
    <span class="s1">max_value </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">le</span>
    <span class="s2">if </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">gt </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">min_value </span><span class="s2">is None</span><span class="s3">, </span><span class="s5">'Set `gt` or `ge`, but not both'</span>
        <span class="s1">min_value </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">gt </span><span class="s3">+ </span><span class="s6">1</span>
    <span class="s2">if </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">lt </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">max_value </span><span class="s2">is None</span><span class="s3">, </span><span class="s5">'Set `lt` or `le`, but not both'</span>
        <span class="s1">max_value </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">lt </span><span class="s3">- </span><span class="s6">1</span>

    <span class="s2">if </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">multiple_of </span><span class="s2">is None or </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">multiple_of </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">st</span><span class="s3">.</span><span class="s1">integers</span><span class="s3">(</span><span class="s1">min_value</span><span class="s3">, </span><span class="s1">max_value</span><span class="s3">)</span>

    <span class="s4"># These adjustments and the .map handle integer-valued multiples, while the</span>
    <span class="s4"># .filter handles trickier cases as for confloat.</span>
    <span class="s2">if </span><span class="s1">min_value </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">min_value </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">Fraction</span><span class="s3">(</span><span class="s1">min_value</span><span class="s3">) / </span><span class="s1">Fraction</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">multiple_of</span><span class="s3">))</span>
    <span class="s2">if </span><span class="s1">max_value </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">max_value </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">Fraction</span><span class="s3">(</span><span class="s1">max_value</span><span class="s3">) / </span><span class="s1">Fraction</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">multiple_of</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">st</span><span class="s3">.</span><span class="s1">integers</span><span class="s3">(</span><span class="s1">min_value</span><span class="s3">, </span><span class="s1">max_value</span><span class="s3">).</span><span class="s1">map</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">x </span><span class="s3">* </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">multiple_of</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">resolves</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">ConstrainedDate</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">resolve_condate</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">):  </span><span class="s4"># type: ignore[no-untyped-def]</span>
    <span class="s2">if </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">ge </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">gt </span><span class="s2">is None</span><span class="s3">, </span><span class="s5">'Set `gt` or `ge`, but not both'</span>
        <span class="s1">min_value </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">ge</span>
    <span class="s2">elif </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">gt </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">min_value </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">gt </span><span class="s3">+ </span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">timedelta</span><span class="s3">(</span><span class="s1">days</span><span class="s3">=</span><span class="s6">1</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">min_value </span><span class="s3">= </span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">date</span><span class="s3">.</span><span class="s1">min</span>
    <span class="s2">if </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">le </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">lt </span><span class="s2">is None</span><span class="s3">, </span><span class="s5">'Set `lt` or `le`, but not both'</span>
        <span class="s1">max_value </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">le</span>
    <span class="s2">elif </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">lt </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">max_value </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">lt </span><span class="s3">- </span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">timedelta</span><span class="s3">(</span><span class="s1">days</span><span class="s3">=</span><span class="s6">1</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">max_value </span><span class="s3">= </span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">date</span><span class="s3">.</span><span class="s1">max</span>
    <span class="s2">return </span><span class="s1">st</span><span class="s3">.</span><span class="s1">dates</span><span class="s3">(</span><span class="s1">min_value</span><span class="s3">, </span><span class="s1">max_value</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">resolves</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">ConstrainedStr</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">resolve_constr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">):  </span><span class="s4"># type: ignore[no-untyped-def]  # pragma: no cover</span>
    <span class="s1">min_size </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">min_length </span><span class="s2">or </span><span class="s6">0</span>
    <span class="s1">max_size </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">max_length</span>

    <span class="s2">if </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">regex </span><span class="s2">is None and not </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">strip_whitespace</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">st</span><span class="s3">.</span><span class="s1">text</span><span class="s3">(</span><span class="s1">min_size</span><span class="s3">=</span><span class="s1">min_size</span><span class="s3">, </span><span class="s1">max_size</span><span class="s3">=</span><span class="s1">max_size</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">regex </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">strategy </span><span class="s3">= </span><span class="s1">st</span><span class="s3">.</span><span class="s1">from_regex</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">regex</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">strip_whitespace</span><span class="s3">:</span>
            <span class="s1">strategy </span><span class="s3">= </span><span class="s1">strategy</span><span class="s3">.</span><span class="s1">filter</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">s</span><span class="s3">: </span><span class="s1">s </span><span class="s3">== </span><span class="s1">s</span><span class="s3">.</span><span class="s1">strip</span><span class="s3">())</span>
    <span class="s2">elif </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">strip_whitespace</span><span class="s3">:</span>
        <span class="s1">repeats </span><span class="s3">= </span><span class="s5">'{{{},{}}}'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
            <span class="s1">min_size </span><span class="s3">- </span><span class="s6">2 </span><span class="s2">if </span><span class="s1">min_size </span><span class="s3">&gt; </span><span class="s6">2 </span><span class="s2">else </span><span class="s6">0</span><span class="s3">,</span>
            <span class="s1">max_size </span><span class="s3">- </span><span class="s6">2 </span><span class="s2">if </span><span class="s3">(</span><span class="s1">max_size </span><span class="s2">or </span><span class="s6">0</span><span class="s3">) &gt; </span><span class="s6">2 </span><span class="s2">else </span><span class="s5">''</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s2">if </span><span class="s1">min_size </span><span class="s3">&gt;= </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s1">strategy </span><span class="s3">= </span><span class="s1">st</span><span class="s3">.</span><span class="s1">from_regex</span><span class="s3">(</span><span class="s5">rf'\W.</span><span class="s2">{</span><span class="s1">repeats</span><span class="s2">}</span><span class="s5">\W'</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">min_size </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s1">strategy </span><span class="s3">= </span><span class="s1">st</span><span class="s3">.</span><span class="s1">from_regex</span><span class="s3">(</span><span class="s5">rf'\W(.</span><span class="s2">{</span><span class="s1">repeats</span><span class="s2">}</span><span class="s5">\W)?'</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">min_size </span><span class="s3">== </span><span class="s6">0</span>
            <span class="s1">strategy </span><span class="s3">= </span><span class="s1">st</span><span class="s3">.</span><span class="s1">from_regex</span><span class="s3">(</span><span class="s5">rf'(\W(.</span><span class="s2">{</span><span class="s1">repeats</span><span class="s2">}</span><span class="s5">\W)?)?'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">min_size </span><span class="s3">== </span><span class="s6">0 </span><span class="s2">and </span><span class="s1">max_size </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">strategy</span>
    <span class="s2">elif </span><span class="s1">max_size </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">strategy</span><span class="s3">.</span><span class="s1">filter</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">s</span><span class="s3">: </span><span class="s1">min_size </span><span class="s3">&lt;= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">s</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">strategy</span><span class="s3">.</span><span class="s1">filter</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">s</span><span class="s3">: </span><span class="s1">min_size </span><span class="s3">&lt;= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">s</span><span class="s3">) &lt;= </span><span class="s1">max_size</span><span class="s3">)</span>


<span class="s4"># Finally, register all previously-defined types, and patch in our new function</span>
<span class="s2">for </span><span class="s1">typ </span><span class="s2">in </span><span class="s1">list</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">types</span><span class="s3">.</span><span class="s1">_DEFINED_TYPES</span><span class="s3">):</span>
    <span class="s1">_registered</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">)</span>
<span class="s1">pydantic</span><span class="s3">.</span><span class="s1">types</span><span class="s3">.</span><span class="s1">_registered </span><span class="s3">= </span><span class="s1">_registered</span>
<span class="s1">st</span><span class="s3">.</span><span class="s1">register_type_strategy</span><span class="s3">(</span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">Json</span><span class="s3">, </span><span class="s1">resolve_json</span><span class="s3">)</span>
</pre>
</body>
</html>