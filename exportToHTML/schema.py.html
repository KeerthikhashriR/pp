<html>
<head>
<title>schema.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
schema.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">defaultdict</span>
<span class="s0">from </span><span class="s1">dataclasses </span><span class="s0">import </span><span class="s1">is_dataclass</span>
<span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">date</span><span class="s2">, </span><span class="s1">datetime</span><span class="s2">, </span><span class="s1">time</span><span class="s2">, </span><span class="s1">timedelta</span>
<span class="s0">from </span><span class="s1">decimal </span><span class="s0">import </span><span class="s1">Decimal</span>
<span class="s0">from </span><span class="s1">enum </span><span class="s0">import </span><span class="s1">Enum</span>
<span class="s0">from </span><span class="s1">ipaddress </span><span class="s0">import </span><span class="s1">IPv4Address</span><span class="s2">, </span><span class="s1">IPv4Interface</span><span class="s2">, </span><span class="s1">IPv4Network</span><span class="s2">, </span><span class="s1">IPv6Address</span><span class="s2">, </span><span class="s1">IPv6Interface</span><span class="s2">, </span><span class="s1">IPv6Network</span>
<span class="s0">from </span><span class="s1">pathlib </span><span class="s0">import </span><span class="s1">Path</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">Callable</span><span class="s2">,</span>
    <span class="s1">Dict</span><span class="s2">,</span>
    <span class="s1">ForwardRef</span><span class="s2">,</span>
    <span class="s1">FrozenSet</span><span class="s2">,</span>
    <span class="s1">Generic</span><span class="s2">,</span>
    <span class="s1">Iterable</span><span class="s2">,</span>
    <span class="s1">List</span><span class="s2">,</span>
    <span class="s1">Optional</span><span class="s2">,</span>
    <span class="s1">Pattern</span><span class="s2">,</span>
    <span class="s1">Sequence</span><span class="s2">,</span>
    <span class="s1">Set</span><span class="s2">,</span>
    <span class="s1">Tuple</span><span class="s2">,</span>
    <span class="s1">Type</span><span class="s2">,</span>
    <span class="s1">TypeVar</span><span class="s2">,</span>
    <span class="s1">Union</span><span class="s2">,</span>
    <span class="s1">cast</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">uuid </span><span class="s0">import </span><span class="s1">UUID</span>

<span class="s0">from </span><span class="s1">typing_extensions </span><span class="s0">import </span><span class="s1">Annotated</span><span class="s2">, </span><span class="s1">Literal</span>

<span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">fields </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">MAPPING_LIKE_SHAPES</span><span class="s2">,</span>
    <span class="s1">SHAPE_DEQUE</span><span class="s2">,</span>
    <span class="s1">SHAPE_FROZENSET</span><span class="s2">,</span>
    <span class="s1">SHAPE_GENERIC</span><span class="s2">,</span>
    <span class="s1">SHAPE_ITERABLE</span><span class="s2">,</span>
    <span class="s1">SHAPE_LIST</span><span class="s2">,</span>
    <span class="s1">SHAPE_SEQUENCE</span><span class="s2">,</span>
    <span class="s1">SHAPE_SET</span><span class="s2">,</span>
    <span class="s1">SHAPE_SINGLETON</span><span class="s2">,</span>
    <span class="s1">SHAPE_TUPLE</span><span class="s2">,</span>
    <span class="s1">SHAPE_TUPLE_ELLIPSIS</span><span class="s2">,</span>
    <span class="s1">FieldInfo</span><span class="s2">,</span>
    <span class="s1">ModelField</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">json </span><span class="s0">import </span><span class="s1">pydantic_encoder</span>
<span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">networks </span><span class="s0">import </span><span class="s1">AnyUrl</span><span class="s2">, </span><span class="s1">EmailStr</span>
<span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">types </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">ConstrainedDecimal</span><span class="s2">,</span>
    <span class="s1">ConstrainedFloat</span><span class="s2">,</span>
    <span class="s1">ConstrainedFrozenSet</span><span class="s2">,</span>
    <span class="s1">ConstrainedInt</span><span class="s2">,</span>
    <span class="s1">ConstrainedList</span><span class="s2">,</span>
    <span class="s1">ConstrainedSet</span><span class="s2">,</span>
    <span class="s1">ConstrainedStr</span><span class="s2">,</span>
    <span class="s1">SecretBytes</span><span class="s2">,</span>
    <span class="s1">SecretStr</span><span class="s2">,</span>
    <span class="s1">StrictBytes</span><span class="s2">,</span>
    <span class="s1">StrictStr</span><span class="s2">,</span>
    <span class="s1">conbytes</span><span class="s2">,</span>
    <span class="s1">condecimal</span><span class="s2">,</span>
    <span class="s1">confloat</span><span class="s2">,</span>
    <span class="s1">confrozenset</span><span class="s2">,</span>
    <span class="s1">conint</span><span class="s2">,</span>
    <span class="s1">conlist</span><span class="s2">,</span>
    <span class="s1">conset</span><span class="s2">,</span>
    <span class="s1">constr</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">typing </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">all_literal_values</span><span class="s2">,</span>
    <span class="s1">get_args</span><span class="s2">,</span>
    <span class="s1">get_origin</span><span class="s2">,</span>
    <span class="s1">get_sub_types</span><span class="s2">,</span>
    <span class="s1">is_callable_type</span><span class="s2">,</span>
    <span class="s1">is_literal_type</span><span class="s2">,</span>
    <span class="s1">is_namedtuple</span><span class="s2">,</span>
    <span class="s1">is_none_type</span><span class="s2">,</span>
    <span class="s1">is_union</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">utils </span><span class="s0">import </span><span class="s1">ROOT_KEY</span><span class="s2">, </span><span class="s1">get_model</span><span class="s2">, </span><span class="s1">lenient_issubclass</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">dataclasses </span><span class="s0">import </span><span class="s1">Dataclass</span>
    <span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">main </span><span class="s0">import </span><span class="s1">BaseModel</span>

<span class="s1">default_prefix </span><span class="s2">= </span><span class="s3">'#/definitions/'</span>
<span class="s1">default_ref_template </span><span class="s2">= </span><span class="s3">'#/definitions/{model}'</span>

<span class="s1">TypeModelOrEnum </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">Type</span><span class="s2">[</span><span class="s3">'BaseModel'</span><span class="s2">], </span><span class="s1">Type</span><span class="s2">[</span><span class="s1">Enum</span><span class="s2">]]</span>
<span class="s1">TypeModelSet </span><span class="s2">= </span><span class="s1">Set</span><span class="s2">[</span><span class="s1">TypeModelOrEnum</span><span class="s2">]</span>


<span class="s0">def </span><span class="s1">_apply_modify_schema</span><span class="s2">(</span>
    <span class="s1">modify_schema</span><span class="s2">: </span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s0">None</span><span class="s2">], </span><span class="s1">field</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">ModelField</span><span class="s2">], </span><span class="s1">field_schema</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">inspect </span><span class="s0">import </span><span class="s1">signature</span>

    <span class="s1">sig </span><span class="s2">= </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">modify_schema</span><span class="s2">)</span>
    <span class="s1">args </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">.</span><span class="s1">parameters</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>
    <span class="s0">if </span><span class="s3">'field' </span><span class="s0">in </span><span class="s1">args </span><span class="s0">or </span><span class="s3">'kwargs' </span><span class="s0">in </span><span class="s1">args</span><span class="s2">:</span>
        <span class="s1">modify_schema</span><span class="s2">(</span><span class="s1">field_schema</span><span class="s2">, </span><span class="s1">field</span><span class="s2">=</span><span class="s1">field</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">modify_schema</span><span class="s2">(</span><span class="s1">field_schema</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">schema</span><span class="s2">(</span>
    <span class="s1">models</span><span class="s2">: </span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">Union</span><span class="s2">[</span><span class="s1">Type</span><span class="s2">[</span><span class="s3">'BaseModel'</span><span class="s2">], </span><span class="s1">Type</span><span class="s2">[</span><span class="s3">'Dataclass'</span><span class="s2">]]],</span>
    <span class="s2">*,</span>
    <span class="s1">by_alias</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
    <span class="s1">title</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">description</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">ref_prefix</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">ref_template</span><span class="s2">: </span><span class="s1">str </span><span class="s2">= </span><span class="s1">default_ref_template</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]:</span>
    <span class="s4">&quot;&quot;&quot; 
    Process a list of models and generate a single JSON Schema with all of them defined in the ``definitions`` 
    top-level JSON key, including their sub-models. 
 
    :param models: a list of models to include in the generated JSON Schema 
    :param by_alias: generate the schemas using the aliases defined, if any 
    :param title: title for the generated schema that includes the definitions 
    :param description: description for the generated schema 
    :param ref_prefix: the JSON Pointer prefix for schema references with ``$ref``, if None, will be set to the 
      default of ``#/definitions/``. Update it if you want the schemas to reference the definitions somewhere 
      else, e.g. for OpenAPI use ``#/components/schemas/``. The resulting generated schemas will still be at the 
      top-level key ``definitions``, so you can extract them from there. But all the references will have the set 
      prefix. 
    :param ref_template: Use a ``string.format()`` template for ``$ref`` instead of a prefix. This can be useful 
      for references that cannot be represented by ``ref_prefix`` such as a definition stored in another file. For 
      a sibling json file in a ``/schemas`` directory use ``&quot;/schemas/${model}.json#&quot;``. 
    :return: dict with the JSON Schema with a ``definitions`` top-level key including the schema definitions for 
      the models and sub-models passed in ``models``. 
    &quot;&quot;&quot;</span>
    <span class="s1">clean_models </span><span class="s2">= [</span><span class="s1">get_model</span><span class="s2">(</span><span class="s1">model</span><span class="s2">) </span><span class="s0">for </span><span class="s1">model </span><span class="s0">in </span><span class="s1">models</span><span class="s2">]</span>
    <span class="s1">flat_models </span><span class="s2">= </span><span class="s1">get_flat_models_from_models</span><span class="s2">(</span><span class="s1">clean_models</span><span class="s2">)</span>
    <span class="s1">model_name_map </span><span class="s2">= </span><span class="s1">get_model_name_map</span><span class="s2">(</span><span class="s1">flat_models</span><span class="s2">)</span>
    <span class="s1">definitions </span><span class="s2">= {}</span>
    <span class="s1">output_schema</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] = {}</span>
    <span class="s0">if </span><span class="s1">title</span><span class="s2">:</span>
        <span class="s1">output_schema</span><span class="s2">[</span><span class="s3">'title'</span><span class="s2">] = </span><span class="s1">title</span>
    <span class="s0">if </span><span class="s1">description</span><span class="s2">:</span>
        <span class="s1">output_schema</span><span class="s2">[</span><span class="s3">'description'</span><span class="s2">] = </span><span class="s1">description</span>
    <span class="s0">for </span><span class="s1">model </span><span class="s0">in </span><span class="s1">clean_models</span><span class="s2">:</span>
        <span class="s1">m_schema</span><span class="s2">, </span><span class="s1">m_definitions</span><span class="s2">, </span><span class="s1">m_nested_models </span><span class="s2">= </span><span class="s1">model_process_schema</span><span class="s2">(</span>
            <span class="s1">model</span><span class="s2">,</span>
            <span class="s1">by_alias</span><span class="s2">=</span><span class="s1">by_alias</span><span class="s2">,</span>
            <span class="s1">model_name_map</span><span class="s2">=</span><span class="s1">model_name_map</span><span class="s2">,</span>
            <span class="s1">ref_prefix</span><span class="s2">=</span><span class="s1">ref_prefix</span><span class="s2">,</span>
            <span class="s1">ref_template</span><span class="s2">=</span><span class="s1">ref_template</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">definitions</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">m_definitions</span><span class="s2">)</span>
        <span class="s1">model_name </span><span class="s2">= </span><span class="s1">model_name_map</span><span class="s2">[</span><span class="s1">model</span><span class="s2">]</span>
        <span class="s1">definitions</span><span class="s2">[</span><span class="s1">model_name</span><span class="s2">] = </span><span class="s1">m_schema</span>
    <span class="s0">if </span><span class="s1">definitions</span><span class="s2">:</span>
        <span class="s1">output_schema</span><span class="s2">[</span><span class="s3">'definitions'</span><span class="s2">] = </span><span class="s1">definitions</span>
    <span class="s0">return </span><span class="s1">output_schema</span>


<span class="s0">def </span><span class="s1">model_schema</span><span class="s2">(</span>
    <span class="s1">model</span><span class="s2">: </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">Type</span><span class="s2">[</span><span class="s3">'BaseModel'</span><span class="s2">], </span><span class="s1">Type</span><span class="s2">[</span><span class="s3">'Dataclass'</span><span class="s2">]],</span>
    <span class="s1">by_alias</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
    <span class="s1">ref_prefix</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">ref_template</span><span class="s2">: </span><span class="s1">str </span><span class="s2">= </span><span class="s1">default_ref_template</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]:</span>
    <span class="s4">&quot;&quot;&quot; 
    Generate a JSON Schema for one model. With all the sub-models defined in the ``definitions`` top-level 
    JSON key. 
 
    :param model: a Pydantic model (a class that inherits from BaseModel) 
    :param by_alias: generate the schemas using the aliases defined, if any 
    :param ref_prefix: the JSON Pointer prefix for schema references with ``$ref``, if None, will be set to the 
      default of ``#/definitions/``. Update it if you want the schemas to reference the definitions somewhere 
      else, e.g. for OpenAPI use ``#/components/schemas/``. The resulting generated schemas will still be at the 
      top-level key ``definitions``, so you can extract them from there. But all the references will have the set 
      prefix. 
    :param ref_template: Use a ``string.format()`` template for ``$ref`` instead of a prefix. This can be useful for 
      references that cannot be represented by ``ref_prefix`` such as a definition stored in another file. For a 
      sibling json file in a ``/schemas`` directory use ``&quot;/schemas/${model}.json#&quot;``. 
    :return: dict with the JSON Schema for the passed ``model`` 
    &quot;&quot;&quot;</span>
    <span class="s1">model </span><span class="s2">= </span><span class="s1">get_model</span><span class="s2">(</span><span class="s1">model</span><span class="s2">)</span>
    <span class="s1">flat_models </span><span class="s2">= </span><span class="s1">get_flat_models_from_model</span><span class="s2">(</span><span class="s1">model</span><span class="s2">)</span>
    <span class="s1">model_name_map </span><span class="s2">= </span><span class="s1">get_model_name_map</span><span class="s2">(</span><span class="s1">flat_models</span><span class="s2">)</span>
    <span class="s1">model_name </span><span class="s2">= </span><span class="s1">model_name_map</span><span class="s2">[</span><span class="s1">model</span><span class="s2">]</span>
    <span class="s1">m_schema</span><span class="s2">, </span><span class="s1">m_definitions</span><span class="s2">, </span><span class="s1">nested_models </span><span class="s2">= </span><span class="s1">model_process_schema</span><span class="s2">(</span>
        <span class="s1">model</span><span class="s2">, </span><span class="s1">by_alias</span><span class="s2">=</span><span class="s1">by_alias</span><span class="s2">, </span><span class="s1">model_name_map</span><span class="s2">=</span><span class="s1">model_name_map</span><span class="s2">, </span><span class="s1">ref_prefix</span><span class="s2">=</span><span class="s1">ref_prefix</span><span class="s2">, </span><span class="s1">ref_template</span><span class="s2">=</span><span class="s1">ref_template</span>
    <span class="s2">)</span>
    <span class="s0">if </span><span class="s1">model_name </span><span class="s0">in </span><span class="s1">nested_models</span><span class="s2">:</span>
        <span class="s5"># model_name is in Nested models, it has circular references</span>
        <span class="s1">m_definitions</span><span class="s2">[</span><span class="s1">model_name</span><span class="s2">] = </span><span class="s1">m_schema</span>
        <span class="s1">m_schema </span><span class="s2">= </span><span class="s1">get_schema_ref</span><span class="s2">(</span><span class="s1">model_name</span><span class="s2">, </span><span class="s1">ref_prefix</span><span class="s2">, </span><span class="s1">ref_template</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">m_definitions</span><span class="s2">:</span>
        <span class="s1">m_schema</span><span class="s2">.</span><span class="s1">update</span><span class="s2">({</span><span class="s3">'definitions'</span><span class="s2">: </span><span class="s1">m_definitions</span><span class="s2">})</span>
    <span class="s0">return </span><span class="s1">m_schema</span>


<span class="s0">def </span><span class="s1">get_field_info_schema</span><span class="s2">(</span><span class="s1">field</span><span class="s2">: </span><span class="s1">ModelField</span><span class="s2">, </span><span class="s1">schema_overrides</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">) </span><span class="s1">-&gt; Tuple</span><span class="s2">[</span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], </span><span class="s1">bool</span><span class="s2">]:</span>
    <span class="s5"># If no title is explicitly set, we don't set title in the schema for enums.</span>
    <span class="s5"># The behaviour is the same as `BaseModel` reference, where the default title</span>
    <span class="s5"># is in the definitions part of the schema.</span>
    <span class="s1">schema_</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] = {}</span>
    <span class="s0">if </span><span class="s1">field</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">title </span><span class="s0">or not </span><span class="s1">lenient_issubclass</span><span class="s2">(</span><span class="s1">field</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">Enum</span><span class="s2">):</span>
        <span class="s1">schema_</span><span class="s2">[</span><span class="s3">'title'</span><span class="s2">] = </span><span class="s1">field</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">title </span><span class="s0">or </span><span class="s1">field</span><span class="s2">.</span><span class="s1">alias</span><span class="s2">.</span><span class="s1">title</span><span class="s2">().</span><span class="s1">replace</span><span class="s2">(</span><span class="s3">'_'</span><span class="s2">, </span><span class="s3">' '</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">field</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">title</span><span class="s2">:</span>
        <span class="s1">schema_overrides </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s0">if </span><span class="s1">field</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">description</span><span class="s2">:</span>
        <span class="s1">schema_</span><span class="s2">[</span><span class="s3">'description'</span><span class="s2">] = </span><span class="s1">field</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">description</span>
        <span class="s1">schema_overrides </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s0">if not </span><span class="s1">field</span><span class="s2">.</span><span class="s1">required </span><span class="s0">and </span><span class="s1">field</span><span class="s2">.</span><span class="s1">default </span><span class="s0">is not None and not </span><span class="s1">is_callable_type</span><span class="s2">(</span><span class="s1">field</span><span class="s2">.</span><span class="s1">outer_type_</span><span class="s2">):</span>
        <span class="s1">schema_</span><span class="s2">[</span><span class="s3">'default'</span><span class="s2">] = </span><span class="s1">encode_default</span><span class="s2">(</span><span class="s1">field</span><span class="s2">.</span><span class="s1">default</span><span class="s2">)</span>
        <span class="s1">schema_overrides </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s0">return </span><span class="s1">schema_</span><span class="s2">, </span><span class="s1">schema_overrides</span>


<span class="s0">def </span><span class="s1">field_schema</span><span class="s2">(</span>
    <span class="s1">field</span><span class="s2">: </span><span class="s1">ModelField</span><span class="s2">,</span>
    <span class="s2">*,</span>
    <span class="s1">by_alias</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
    <span class="s1">model_name_map</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">TypeModelOrEnum</span><span class="s2">, </span><span class="s1">str</span><span class="s2">],</span>
    <span class="s1">ref_prefix</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">ref_template</span><span class="s2">: </span><span class="s1">str </span><span class="s2">= </span><span class="s1">default_ref_template</span><span class="s2">,</span>
    <span class="s1">known_models</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">TypeModelSet</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; Tuple</span><span class="s2">[</span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], </span><span class="s1">Set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]]:</span>
    <span class="s4">&quot;&quot;&quot; 
    Process a Pydantic field and return a tuple with a JSON Schema for it as the first item. 
    Also return a dictionary of definitions with models as keys and their schemas as values. If the passed field 
    is a model and has sub-models, and those sub-models don't have overrides (as ``title``, ``default``, etc), they 
    will be included in the definitions and referenced in the schema instead of included recursively. 
 
    :param field: a Pydantic ``ModelField`` 
    :param by_alias: use the defined alias (if any) in the returned schema 
    :param model_name_map: used to generate the JSON Schema references to other models included in the definitions 
    :param ref_prefix: the JSON Pointer prefix to use for references to other schemas, if None, the default of 
      #/definitions/ will be used 
    :param ref_template: Use a ``string.format()`` template for ``$ref`` instead of a prefix. This can be useful for 
      references that cannot be represented by ``ref_prefix`` such as a definition stored in another file. For a 
      sibling json file in a ``/schemas`` directory use ``&quot;/schemas/${model}.json#&quot;``. 
    :param known_models: used to solve circular references 
    :return: tuple of the schema for this field and additional definitions 
    &quot;&quot;&quot;</span>
    <span class="s1">s</span><span class="s2">, </span><span class="s1">schema_overrides </span><span class="s2">= </span><span class="s1">get_field_info_schema</span><span class="s2">(</span><span class="s1">field</span><span class="s2">)</span>

    <span class="s1">validation_schema </span><span class="s2">= </span><span class="s1">get_field_schema_validations</span><span class="s2">(</span><span class="s1">field</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">validation_schema</span><span class="s2">:</span>
        <span class="s1">s</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">validation_schema</span><span class="s2">)</span>
        <span class="s1">schema_overrides </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s1">f_schema</span><span class="s2">, </span><span class="s1">f_definitions</span><span class="s2">, </span><span class="s1">f_nested_models </span><span class="s2">= </span><span class="s1">field_type_schema</span><span class="s2">(</span>
        <span class="s1">field</span><span class="s2">,</span>
        <span class="s1">by_alias</span><span class="s2">=</span><span class="s1">by_alias</span><span class="s2">,</span>
        <span class="s1">model_name_map</span><span class="s2">=</span><span class="s1">model_name_map</span><span class="s2">,</span>
        <span class="s1">schema_overrides</span><span class="s2">=</span><span class="s1">schema_overrides</span><span class="s2">,</span>
        <span class="s1">ref_prefix</span><span class="s2">=</span><span class="s1">ref_prefix</span><span class="s2">,</span>
        <span class="s1">ref_template</span><span class="s2">=</span><span class="s1">ref_template</span><span class="s2">,</span>
        <span class="s1">known_models</span><span class="s2">=</span><span class="s1">known_models </span><span class="s0">or </span><span class="s1">set</span><span class="s2">(),</span>
    <span class="s2">)</span>

    <span class="s5"># $ref will only be returned when there are no schema_overrides</span>
    <span class="s0">if </span><span class="s3">'$ref' </span><span class="s0">in </span><span class="s1">f_schema</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">f_schema</span><span class="s2">, </span><span class="s1">f_definitions</span><span class="s2">, </span><span class="s1">f_nested_models</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">s</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">f_schema</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">s</span><span class="s2">, </span><span class="s1">f_definitions</span><span class="s2">, </span><span class="s1">f_nested_models</span>


<span class="s1">numeric_types </span><span class="s2">= (</span><span class="s1">int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Decimal</span><span class="s2">)</span>
<span class="s1">_str_types_attrs</span><span class="s2">: </span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">type</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">type</span><span class="s2">, ...]], </span><span class="s1">str</span><span class="s2">], ...] = (</span>
    <span class="s2">(</span><span class="s3">'max_length'</span><span class="s2">, </span><span class="s1">numeric_types</span><span class="s2">, </span><span class="s3">'maxLength'</span><span class="s2">),</span>
    <span class="s2">(</span><span class="s3">'min_length'</span><span class="s2">, </span><span class="s1">numeric_types</span><span class="s2">, </span><span class="s3">'minLength'</span><span class="s2">),</span>
    <span class="s2">(</span><span class="s3">'regex'</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s3">'pattern'</span><span class="s2">),</span>
<span class="s2">)</span>

<span class="s1">_numeric_types_attrs</span><span class="s2">: </span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">type</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">type</span><span class="s2">, ...]], </span><span class="s1">str</span><span class="s2">], ...] = (</span>
    <span class="s2">(</span><span class="s3">'gt'</span><span class="s2">, </span><span class="s1">numeric_types</span><span class="s2">, </span><span class="s3">'exclusiveMinimum'</span><span class="s2">),</span>
    <span class="s2">(</span><span class="s3">'lt'</span><span class="s2">, </span><span class="s1">numeric_types</span><span class="s2">, </span><span class="s3">'exclusiveMaximum'</span><span class="s2">),</span>
    <span class="s2">(</span><span class="s3">'ge'</span><span class="s2">, </span><span class="s1">numeric_types</span><span class="s2">, </span><span class="s3">'minimum'</span><span class="s2">),</span>
    <span class="s2">(</span><span class="s3">'le'</span><span class="s2">, </span><span class="s1">numeric_types</span><span class="s2">, </span><span class="s3">'maximum'</span><span class="s2">),</span>
    <span class="s2">(</span><span class="s3">'multiple_of'</span><span class="s2">, </span><span class="s1">numeric_types</span><span class="s2">, </span><span class="s3">'multipleOf'</span><span class="s2">),</span>
<span class="s2">)</span>


<span class="s0">def </span><span class="s1">get_field_schema_validations</span><span class="s2">(</span><span class="s1">field</span><span class="s2">: </span><span class="s1">ModelField</span><span class="s2">) </span><span class="s1">-&gt; Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]:</span>
    <span class="s4">&quot;&quot;&quot; 
    Get the JSON Schema validation keywords for a ``field`` with an annotation of 
    a Pydantic ``FieldInfo`` with validation arguments. 
    &quot;&quot;&quot;</span>
    <span class="s1">f_schema</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] = {}</span>

    <span class="s0">if </span><span class="s1">lenient_issubclass</span><span class="s2">(</span><span class="s1">field</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">Enum</span><span class="s2">):</span>
        <span class="s5"># schema is already updated by `enum_process_schema`; just update with field extra</span>
        <span class="s0">if </span><span class="s1">field</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">extra</span><span class="s2">:</span>
            <span class="s1">f_schema</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">field</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">extra</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">f_schema</span>

    <span class="s0">if </span><span class="s1">lenient_issubclass</span><span class="s2">(</span><span class="s1">field</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">, (</span><span class="s1">str</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">)):</span>
        <span class="s0">for </span><span class="s1">attr_name</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">keyword </span><span class="s0">in </span><span class="s1">_str_types_attrs</span><span class="s2">:</span>
            <span class="s1">attr </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">field</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">, </span><span class="s1">attr_name</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">, </span><span class="s1">t</span><span class="s2">):</span>
                <span class="s1">f_schema</span><span class="s2">[</span><span class="s1">keyword</span><span class="s2">] = </span><span class="s1">attr</span>
    <span class="s0">if </span><span class="s1">lenient_issubclass</span><span class="s2">(</span><span class="s1">field</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">numeric_types</span><span class="s2">) </span><span class="s0">and not </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">field</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">attr_name</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">keyword </span><span class="s0">in </span><span class="s1">_numeric_types_attrs</span><span class="s2">:</span>
            <span class="s1">attr </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">field</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">, </span><span class="s1">attr_name</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">, </span><span class="s1">t</span><span class="s2">):</span>
                <span class="s1">f_schema</span><span class="s2">[</span><span class="s1">keyword</span><span class="s2">] = </span><span class="s1">attr</span>
    <span class="s0">if </span><span class="s1">field</span><span class="s2">.</span><span class="s1">field_info </span><span class="s0">is not None and </span><span class="s1">field</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">const</span><span class="s2">:</span>
        <span class="s1">f_schema</span><span class="s2">[</span><span class="s3">'const'</span><span class="s2">] = </span><span class="s1">field</span><span class="s2">.</span><span class="s1">default</span>
    <span class="s0">if </span><span class="s1">field</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">extra</span><span class="s2">:</span>
        <span class="s1">f_schema</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">field</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">extra</span><span class="s2">)</span>
    <span class="s1">modify_schema </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">field</span><span class="s2">.</span><span class="s1">outer_type_</span><span class="s2">, </span><span class="s3">'__modify_schema__'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">modify_schema</span><span class="s2">:</span>
        <span class="s1">_apply_modify_schema</span><span class="s2">(</span><span class="s1">modify_schema</span><span class="s2">, </span><span class="s1">field</span><span class="s2">, </span><span class="s1">f_schema</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">f_schema</span>


<span class="s0">def </span><span class="s1">get_model_name_map</span><span class="s2">(</span><span class="s1">unique_models</span><span class="s2">: </span><span class="s1">TypeModelSet</span><span class="s2">) </span><span class="s1">-&gt; Dict</span><span class="s2">[</span><span class="s1">TypeModelOrEnum</span><span class="s2">, </span><span class="s1">str</span><span class="s2">]:</span>
    <span class="s4">&quot;&quot;&quot; 
    Process a set of models and generate unique names for them to be used as keys in the JSON Schema 
    definitions. By default the names are the same as the class name. But if two models in different Python 
    modules have the same name (e.g. &quot;users.Model&quot; and &quot;items.Model&quot;), the generated names will be 
    based on the Python module path for those conflicting models to prevent name collisions. 
 
    :param unique_models: a Python set of models 
    :return: dict mapping models to names 
    &quot;&quot;&quot;</span>
    <span class="s1">name_model_map </span><span class="s2">= {}</span>
    <span class="s1">conflicting_names</span><span class="s2">: </span><span class="s1">Set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s1">set</span><span class="s2">()</span>
    <span class="s0">for </span><span class="s1">model </span><span class="s0">in </span><span class="s1">unique_models</span><span class="s2">:</span>
        <span class="s1">model_name </span><span class="s2">= </span><span class="s1">normalize_name</span><span class="s2">(</span><span class="s1">model</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">model_name </span><span class="s0">in </span><span class="s1">conflicting_names</span><span class="s2">:</span>
            <span class="s1">model_name </span><span class="s2">= </span><span class="s1">get_long_model_name</span><span class="s2">(</span><span class="s1">model</span><span class="s2">)</span>
            <span class="s1">name_model_map</span><span class="s2">[</span><span class="s1">model_name</span><span class="s2">] = </span><span class="s1">model</span>
        <span class="s0">elif </span><span class="s1">model_name </span><span class="s0">in </span><span class="s1">name_model_map</span><span class="s2">:</span>
            <span class="s1">conflicting_names</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">model_name</span><span class="s2">)</span>
            <span class="s1">conflicting_model </span><span class="s2">= </span><span class="s1">name_model_map</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s1">model_name</span><span class="s2">)</span>
            <span class="s1">name_model_map</span><span class="s2">[</span><span class="s1">get_long_model_name</span><span class="s2">(</span><span class="s1">conflicting_model</span><span class="s2">)] = </span><span class="s1">conflicting_model</span>
            <span class="s1">name_model_map</span><span class="s2">[</span><span class="s1">get_long_model_name</span><span class="s2">(</span><span class="s1">model</span><span class="s2">)] = </span><span class="s1">model</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">name_model_map</span><span class="s2">[</span><span class="s1">model_name</span><span class="s2">] = </span><span class="s1">model</span>
    <span class="s0">return </span><span class="s2">{</span><span class="s1">v</span><span class="s2">: </span><span class="s1">k </span><span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">name_model_map</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()}</span>


<span class="s0">def </span><span class="s1">get_flat_models_from_model</span><span class="s2">(</span><span class="s1">model</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">[</span><span class="s3">'BaseModel'</span><span class="s2">], </span><span class="s1">known_models</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">TypeModelSet</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; TypeModelSet</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Take a single ``model`` and generate a set with itself and all the sub-models in the tree. I.e. if you pass 
    model ``Foo`` (subclass of Pydantic ``BaseModel``) as ``model``, and it has a field of type ``Bar`` (also 
    subclass of ``BaseModel``) and that model ``Bar`` has a field of type ``Baz`` (also subclass of ``BaseModel``), 
    the return value will be ``set([Foo, Bar, Baz])``. 
 
    :param model: a Pydantic ``BaseModel`` subclass 
    :param known_models: used to solve circular references 
    :return: a set with the initial model and all its sub-models 
    &quot;&quot;&quot;</span>
    <span class="s1">known_models </span><span class="s2">= </span><span class="s1">known_models </span><span class="s0">or </span><span class="s1">set</span><span class="s2">()</span>
    <span class="s1">flat_models</span><span class="s2">: </span><span class="s1">TypeModelSet </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
    <span class="s1">flat_models</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">model</span><span class="s2">)</span>
    <span class="s1">known_models </span><span class="s2">|= </span><span class="s1">flat_models</span>
    <span class="s1">fields </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">ModelField</span><span class="s2">], </span><span class="s1">model</span><span class="s2">.</span><span class="s1">__fields__</span><span class="s2">.</span><span class="s1">values</span><span class="s2">())</span>
    <span class="s1">flat_models </span><span class="s2">|= </span><span class="s1">get_flat_models_from_fields</span><span class="s2">(</span><span class="s1">fields</span><span class="s2">, </span><span class="s1">known_models</span><span class="s2">=</span><span class="s1">known_models</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">flat_models</span>


<span class="s0">def </span><span class="s1">get_flat_models_from_field</span><span class="s2">(</span><span class="s1">field</span><span class="s2">: </span><span class="s1">ModelField</span><span class="s2">, </span><span class="s1">known_models</span><span class="s2">: </span><span class="s1">TypeModelSet</span><span class="s2">) </span><span class="s1">-&gt; TypeModelSet</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Take a single Pydantic ``ModelField`` (from a model) that could have been declared as a subclass of BaseModel 
    (so, it could be a submodel), and generate a set with its model and all the sub-models in the tree. 
    I.e. if you pass a field that was declared to be of type ``Foo`` (subclass of BaseModel) as ``field``, and that 
    model ``Foo`` has a field of type ``Bar`` (also subclass of ``BaseModel``) and that model ``Bar`` has a field of 
    type ``Baz`` (also subclass of ``BaseModel``), the return value will be ``set([Foo, Bar, Baz])``. 
 
    :param field: a Pydantic ``ModelField`` 
    :param known_models: used to solve circular references 
    :return: a set with the model used in the declaration for this field, if any, and all its sub-models 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">main </span><span class="s0">import </span><span class="s1">BaseModel</span>

    <span class="s1">flat_models</span><span class="s2">: </span><span class="s1">TypeModelSet </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>

    <span class="s1">field_type </span><span class="s2">= </span><span class="s1">field</span><span class="s2">.</span><span class="s1">type_</span>
    <span class="s0">if </span><span class="s1">lenient_issubclass</span><span class="s2">(</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">, </span><span class="s3">'__pydantic_model__'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">), </span><span class="s1">BaseModel</span><span class="s2">):</span>
        <span class="s1">field_type </span><span class="s2">= </span><span class="s1">field_type</span><span class="s2">.</span><span class="s1">__pydantic_model__</span>

    <span class="s0">if </span><span class="s1">field</span><span class="s2">.</span><span class="s1">sub_fields </span><span class="s0">and not </span><span class="s1">lenient_issubclass</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">, </span><span class="s1">BaseModel</span><span class="s2">):</span>
        <span class="s1">flat_models </span><span class="s2">|= </span><span class="s1">get_flat_models_from_fields</span><span class="s2">(</span><span class="s1">field</span><span class="s2">.</span><span class="s1">sub_fields</span><span class="s2">, </span><span class="s1">known_models</span><span class="s2">=</span><span class="s1">known_models</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">lenient_issubclass</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">, </span><span class="s1">BaseModel</span><span class="s2">) </span><span class="s0">and </span><span class="s1">field_type </span><span class="s0">not in </span><span class="s1">known_models</span><span class="s2">:</span>
        <span class="s1">flat_models </span><span class="s2">|= </span><span class="s1">get_flat_models_from_model</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">, </span><span class="s1">known_models</span><span class="s2">=</span><span class="s1">known_models</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">lenient_issubclass</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">, </span><span class="s1">Enum</span><span class="s2">):</span>
        <span class="s1">flat_models</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">flat_models</span>


<span class="s0">def </span><span class="s1">get_flat_models_from_fields</span><span class="s2">(</span><span class="s1">fields</span><span class="s2">: </span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">ModelField</span><span class="s2">], </span><span class="s1">known_models</span><span class="s2">: </span><span class="s1">TypeModelSet</span><span class="s2">) </span><span class="s1">-&gt; TypeModelSet</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Take a list of Pydantic  ``ModelField``s (from a model) that could have been declared as subclasses of ``BaseModel`` 
    (so, any of them could be a submodel), and generate a set with their models and all the sub-models in the tree. 
    I.e. if you pass a the fields of a model ``Foo`` (subclass of ``BaseModel``) as ``fields``, and on of them has a 
    field of type ``Bar`` (also subclass of ``BaseModel``) and that model ``Bar`` has a field of type ``Baz`` (also 
    subclass of ``BaseModel``), the return value will be ``set([Foo, Bar, Baz])``. 
 
    :param fields: a list of Pydantic ``ModelField``s 
    :param known_models: used to solve circular references 
    :return: a set with any model declared in the fields, and all their sub-models 
    &quot;&quot;&quot;</span>
    <span class="s1">flat_models</span><span class="s2">: </span><span class="s1">TypeModelSet </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
    <span class="s0">for </span><span class="s1">field </span><span class="s0">in </span><span class="s1">fields</span><span class="s2">:</span>
        <span class="s1">flat_models </span><span class="s2">|= </span><span class="s1">get_flat_models_from_field</span><span class="s2">(</span><span class="s1">field</span><span class="s2">, </span><span class="s1">known_models</span><span class="s2">=</span><span class="s1">known_models</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">flat_models</span>


<span class="s0">def </span><span class="s1">get_flat_models_from_models</span><span class="s2">(</span><span class="s1">models</span><span class="s2">: </span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">Type</span><span class="s2">[</span><span class="s3">'BaseModel'</span><span class="s2">]]) </span><span class="s1">-&gt; TypeModelSet</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Take a list of ``models`` and generate a set with them and all their sub-models in their trees. I.e. if you pass 
    a list of two models, ``Foo`` and ``Bar``, both subclasses of Pydantic ``BaseModel`` as models, and ``Bar`` has 
    a field of type ``Baz`` (also subclass of ``BaseModel``), the return value will be ``set([Foo, Bar, Baz])``. 
    &quot;&quot;&quot;</span>
    <span class="s1">flat_models</span><span class="s2">: </span><span class="s1">TypeModelSet </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
    <span class="s0">for </span><span class="s1">model </span><span class="s0">in </span><span class="s1">models</span><span class="s2">:</span>
        <span class="s1">flat_models </span><span class="s2">|= </span><span class="s1">get_flat_models_from_model</span><span class="s2">(</span><span class="s1">model</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">flat_models</span>


<span class="s0">def </span><span class="s1">get_long_model_name</span><span class="s2">(</span><span class="s1">model</span><span class="s2">: </span><span class="s1">TypeModelOrEnum</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
    <span class="s0">return </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">model</span><span class="s2">.</span><span class="s1">__module__</span><span class="s0">}</span><span class="s3">__</span><span class="s0">{</span><span class="s1">model</span><span class="s2">.</span><span class="s1">__qualname__</span><span class="s0">}</span><span class="s3">'</span><span class="s2">.</span><span class="s1">replace</span><span class="s2">(</span><span class="s3">'.'</span><span class="s2">, </span><span class="s3">'__'</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">field_type_schema</span><span class="s2">(</span>
    <span class="s1">field</span><span class="s2">: </span><span class="s1">ModelField</span><span class="s2">,</span>
    <span class="s2">*,</span>
    <span class="s1">by_alias</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">,</span>
    <span class="s1">model_name_map</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">TypeModelOrEnum</span><span class="s2">, </span><span class="s1">str</span><span class="s2">],</span>
    <span class="s1">ref_template</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
    <span class="s1">schema_overrides</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s1">ref_prefix</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">known_models</span><span class="s2">: </span><span class="s1">TypeModelSet</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; Tuple</span><span class="s2">[</span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], </span><span class="s1">Set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]]:</span>
    <span class="s4">&quot;&quot;&quot; 
    Used by ``field_schema()``, you probably should be using that function. 
 
    Take a single ``field`` and generate the schema for its type only, not including additional 
    information as title, etc. Also return additional schema definitions, from sub-models. 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">main </span><span class="s0">import </span><span class="s1">BaseModel  </span><span class="s5"># noqa: F811</span>

    <span class="s1">definitions </span><span class="s2">= {}</span>
    <span class="s1">nested_models</span><span class="s2">: </span><span class="s1">Set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s1">set</span><span class="s2">()</span>
    <span class="s1">f_schema</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]</span>
    <span class="s0">if </span><span class="s1">field</span><span class="s2">.</span><span class="s1">shape </span><span class="s0">in </span><span class="s2">{</span>
        <span class="s1">SHAPE_LIST</span><span class="s2">,</span>
        <span class="s1">SHAPE_TUPLE_ELLIPSIS</span><span class="s2">,</span>
        <span class="s1">SHAPE_SEQUENCE</span><span class="s2">,</span>
        <span class="s1">SHAPE_SET</span><span class="s2">,</span>
        <span class="s1">SHAPE_FROZENSET</span><span class="s2">,</span>
        <span class="s1">SHAPE_ITERABLE</span><span class="s2">,</span>
        <span class="s1">SHAPE_DEQUE</span><span class="s2">,</span>
    <span class="s2">}:</span>
        <span class="s1">items_schema</span><span class="s2">, </span><span class="s1">f_definitions</span><span class="s2">, </span><span class="s1">f_nested_models </span><span class="s2">= </span><span class="s1">field_singleton_schema</span><span class="s2">(</span>
            <span class="s1">field</span><span class="s2">,</span>
            <span class="s1">by_alias</span><span class="s2">=</span><span class="s1">by_alias</span><span class="s2">,</span>
            <span class="s1">model_name_map</span><span class="s2">=</span><span class="s1">model_name_map</span><span class="s2">,</span>
            <span class="s1">ref_prefix</span><span class="s2">=</span><span class="s1">ref_prefix</span><span class="s2">,</span>
            <span class="s1">ref_template</span><span class="s2">=</span><span class="s1">ref_template</span><span class="s2">,</span>
            <span class="s1">known_models</span><span class="s2">=</span><span class="s1">known_models</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">definitions</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">f_definitions</span><span class="s2">)</span>
        <span class="s1">nested_models</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">f_nested_models</span><span class="s2">)</span>
        <span class="s1">f_schema </span><span class="s2">= {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'array'</span><span class="s2">, </span><span class="s3">'items'</span><span class="s2">: </span><span class="s1">items_schema</span><span class="s2">}</span>
        <span class="s0">if </span><span class="s1">field</span><span class="s2">.</span><span class="s1">shape </span><span class="s0">in </span><span class="s2">{</span><span class="s1">SHAPE_SET</span><span class="s2">, </span><span class="s1">SHAPE_FROZENSET</span><span class="s2">}:</span>
            <span class="s1">f_schema</span><span class="s2">[</span><span class="s3">'uniqueItems'</span><span class="s2">] = </span><span class="s0">True</span>

    <span class="s0">elif </span><span class="s1">field</span><span class="s2">.</span><span class="s1">shape </span><span class="s0">in </span><span class="s1">MAPPING_LIKE_SHAPES</span><span class="s2">:</span>
        <span class="s1">f_schema </span><span class="s2">= {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'object'</span><span class="s2">}</span>
        <span class="s1">key_field </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">ModelField</span><span class="s2">, </span><span class="s1">field</span><span class="s2">.</span><span class="s1">key_field</span><span class="s2">)</span>
        <span class="s1">regex </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">key_field</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">, </span><span class="s3">'regex'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">items_schema</span><span class="s2">, </span><span class="s1">f_definitions</span><span class="s2">, </span><span class="s1">f_nested_models </span><span class="s2">= </span><span class="s1">field_singleton_schema</span><span class="s2">(</span>
            <span class="s1">field</span><span class="s2">,</span>
            <span class="s1">by_alias</span><span class="s2">=</span><span class="s1">by_alias</span><span class="s2">,</span>
            <span class="s1">model_name_map</span><span class="s2">=</span><span class="s1">model_name_map</span><span class="s2">,</span>
            <span class="s1">ref_prefix</span><span class="s2">=</span><span class="s1">ref_prefix</span><span class="s2">,</span>
            <span class="s1">ref_template</span><span class="s2">=</span><span class="s1">ref_template</span><span class="s2">,</span>
            <span class="s1">known_models</span><span class="s2">=</span><span class="s1">known_models</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">definitions</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">f_definitions</span><span class="s2">)</span>
        <span class="s1">nested_models</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">f_nested_models</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">regex</span><span class="s2">:</span>
            <span class="s5"># Dict keys have a regex pattern</span>
            <span class="s5"># items_schema might be a schema or empty dict, add it either way</span>
            <span class="s1">f_schema</span><span class="s2">[</span><span class="s3">'patternProperties'</span><span class="s2">] = {</span><span class="s1">ConstrainedStr</span><span class="s2">.</span><span class="s1">_get_pattern</span><span class="s2">(</span><span class="s1">regex</span><span class="s2">): </span><span class="s1">items_schema</span><span class="s2">}</span>
        <span class="s0">if </span><span class="s1">items_schema</span><span class="s2">:</span>
            <span class="s5"># The dict values are not simply Any, so they need a schema</span>
            <span class="s1">f_schema</span><span class="s2">[</span><span class="s3">'additionalProperties'</span><span class="s2">] = </span><span class="s1">items_schema</span>
    <span class="s0">elif </span><span class="s1">field</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">SHAPE_TUPLE </span><span class="s0">or </span><span class="s2">(</span><span class="s1">field</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">SHAPE_GENERIC </span><span class="s0">and not </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">field</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">BaseModel</span><span class="s2">)):</span>
        <span class="s1">sub_schema </span><span class="s2">= []</span>
        <span class="s1">sub_fields </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">List</span><span class="s2">[</span><span class="s1">ModelField</span><span class="s2">], </span><span class="s1">field</span><span class="s2">.</span><span class="s1">sub_fields</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">sf </span><span class="s0">in </span><span class="s1">sub_fields</span><span class="s2">:</span>
            <span class="s1">sf_schema</span><span class="s2">, </span><span class="s1">sf_definitions</span><span class="s2">, </span><span class="s1">sf_nested_models </span><span class="s2">= </span><span class="s1">field_type_schema</span><span class="s2">(</span>
                <span class="s1">sf</span><span class="s2">,</span>
                <span class="s1">by_alias</span><span class="s2">=</span><span class="s1">by_alias</span><span class="s2">,</span>
                <span class="s1">model_name_map</span><span class="s2">=</span><span class="s1">model_name_map</span><span class="s2">,</span>
                <span class="s1">ref_prefix</span><span class="s2">=</span><span class="s1">ref_prefix</span><span class="s2">,</span>
                <span class="s1">ref_template</span><span class="s2">=</span><span class="s1">ref_template</span><span class="s2">,</span>
                <span class="s1">known_models</span><span class="s2">=</span><span class="s1">known_models</span><span class="s2">,</span>
            <span class="s2">)</span>
            <span class="s1">definitions</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">sf_definitions</span><span class="s2">)</span>
            <span class="s1">nested_models</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">sf_nested_models</span><span class="s2">)</span>
            <span class="s1">sub_schema</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">sf_schema</span><span class="s2">)</span>

        <span class="s1">sub_fields_len </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">sub_fields</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">field</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">SHAPE_GENERIC</span><span class="s2">:</span>
            <span class="s1">all_of_schemas </span><span class="s2">= </span><span class="s1">sub_schema</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] </span><span class="s0">if </span><span class="s1">sub_fields_len </span><span class="s2">== </span><span class="s6">1 </span><span class="s0">else </span><span class="s2">{</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'array'</span><span class="s2">, </span><span class="s3">'items'</span><span class="s2">: </span><span class="s1">sub_schema</span><span class="s2">}</span>
            <span class="s1">f_schema </span><span class="s2">= {</span><span class="s3">'allOf'</span><span class="s2">: [</span><span class="s1">all_of_schemas</span><span class="s2">]}</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">f_schema </span><span class="s2">= {</span>
                <span class="s3">'type'</span><span class="s2">: </span><span class="s3">'array'</span><span class="s2">,</span>
                <span class="s3">'minItems'</span><span class="s2">: </span><span class="s1">sub_fields_len</span><span class="s2">,</span>
                <span class="s3">'maxItems'</span><span class="s2">: </span><span class="s1">sub_fields_len</span><span class="s2">,</span>
            <span class="s2">}</span>
            <span class="s0">if </span><span class="s1">sub_fields_len </span><span class="s2">&gt;= </span><span class="s6">1</span><span class="s2">:</span>
                <span class="s1">f_schema</span><span class="s2">[</span><span class="s3">'items'</span><span class="s2">] = </span><span class="s1">sub_schema</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">field</span><span class="s2">.</span><span class="s1">shape </span><span class="s0">in </span><span class="s2">{</span><span class="s1">SHAPE_SINGLETON</span><span class="s2">, </span><span class="s1">SHAPE_GENERIC</span><span class="s2">}, </span><span class="s1">field</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s1">f_schema</span><span class="s2">, </span><span class="s1">f_definitions</span><span class="s2">, </span><span class="s1">f_nested_models </span><span class="s2">= </span><span class="s1">field_singleton_schema</span><span class="s2">(</span>
            <span class="s1">field</span><span class="s2">,</span>
            <span class="s1">by_alias</span><span class="s2">=</span><span class="s1">by_alias</span><span class="s2">,</span>
            <span class="s1">model_name_map</span><span class="s2">=</span><span class="s1">model_name_map</span><span class="s2">,</span>
            <span class="s1">schema_overrides</span><span class="s2">=</span><span class="s1">schema_overrides</span><span class="s2">,</span>
            <span class="s1">ref_prefix</span><span class="s2">=</span><span class="s1">ref_prefix</span><span class="s2">,</span>
            <span class="s1">ref_template</span><span class="s2">=</span><span class="s1">ref_template</span><span class="s2">,</span>
            <span class="s1">known_models</span><span class="s2">=</span><span class="s1">known_models</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">definitions</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">f_definitions</span><span class="s2">)</span>
        <span class="s1">nested_models</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">f_nested_models</span><span class="s2">)</span>

    <span class="s5"># check field type to avoid repeated calls to the same __modify_schema__ method</span>
    <span class="s0">if </span><span class="s1">field</span><span class="s2">.</span><span class="s1">type_ </span><span class="s2">!= </span><span class="s1">field</span><span class="s2">.</span><span class="s1">outer_type_</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">field</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">SHAPE_GENERIC</span><span class="s2">:</span>
            <span class="s1">field_type </span><span class="s2">= </span><span class="s1">field</span><span class="s2">.</span><span class="s1">type_</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">field_type </span><span class="s2">= </span><span class="s1">field</span><span class="s2">.</span><span class="s1">outer_type_</span>
        <span class="s1">modify_schema </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">, </span><span class="s3">'__modify_schema__'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">modify_schema</span><span class="s2">:</span>
            <span class="s1">_apply_modify_schema</span><span class="s2">(</span><span class="s1">modify_schema</span><span class="s2">, </span><span class="s1">field</span><span class="s2">, </span><span class="s1">f_schema</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">f_schema</span><span class="s2">, </span><span class="s1">definitions</span><span class="s2">, </span><span class="s1">nested_models</span>


<span class="s0">def </span><span class="s1">model_process_schema</span><span class="s2">(</span>
    <span class="s1">model</span><span class="s2">: </span><span class="s1">TypeModelOrEnum</span><span class="s2">,</span>
    <span class="s2">*,</span>
    <span class="s1">by_alias</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
    <span class="s1">model_name_map</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">TypeModelOrEnum</span><span class="s2">, </span><span class="s1">str</span><span class="s2">],</span>
    <span class="s1">ref_prefix</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">ref_template</span><span class="s2">: </span><span class="s1">str </span><span class="s2">= </span><span class="s1">default_ref_template</span><span class="s2">,</span>
    <span class="s1">known_models</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">TypeModelSet</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">field</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">ModelField</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; Tuple</span><span class="s2">[</span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], </span><span class="s1">Set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]]:</span>
    <span class="s4">&quot;&quot;&quot; 
    Used by ``model_schema()``, you probably should be using that function. 
 
    Take a single ``model`` and generate its schema. Also return additional schema definitions, from sub-models. The 
    sub-models of the returned schema will be referenced, but their definitions will not be included in the schema. All 
    the definitions are returned as the second value. 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">inspect </span><span class="s0">import </span><span class="s1">getdoc</span><span class="s2">, </span><span class="s1">signature</span>

    <span class="s1">known_models </span><span class="s2">= </span><span class="s1">known_models </span><span class="s0">or </span><span class="s1">set</span><span class="s2">()</span>
    <span class="s0">if </span><span class="s1">lenient_issubclass</span><span class="s2">(</span><span class="s1">model</span><span class="s2">, </span><span class="s1">Enum</span><span class="s2">):</span>
        <span class="s1">model </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">[</span><span class="s1">Enum</span><span class="s2">], </span><span class="s1">model</span><span class="s2">)</span>
        <span class="s1">s </span><span class="s2">= </span><span class="s1">enum_process_schema</span><span class="s2">(</span><span class="s1">model</span><span class="s2">, </span><span class="s1">field</span><span class="s2">=</span><span class="s1">field</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">s</span><span class="s2">, {}, </span><span class="s1">set</span><span class="s2">()</span>
    <span class="s1">model </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">[</span><span class="s3">'BaseModel'</span><span class="s2">], </span><span class="s1">model</span><span class="s2">)</span>
    <span class="s1">s </span><span class="s2">= {</span><span class="s3">'title'</span><span class="s2">: </span><span class="s1">model</span><span class="s2">.</span><span class="s1">__config__</span><span class="s2">.</span><span class="s1">title </span><span class="s0">or </span><span class="s1">model</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">}</span>
    <span class="s1">doc </span><span class="s2">= </span><span class="s1">getdoc</span><span class="s2">(</span><span class="s1">model</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">doc</span><span class="s2">:</span>
        <span class="s1">s</span><span class="s2">[</span><span class="s3">'description'</span><span class="s2">] = </span><span class="s1">doc</span>
    <span class="s1">known_models</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">model</span><span class="s2">)</span>
    <span class="s1">m_schema</span><span class="s2">, </span><span class="s1">m_definitions</span><span class="s2">, </span><span class="s1">nested_models </span><span class="s2">= </span><span class="s1">model_type_schema</span><span class="s2">(</span>
        <span class="s1">model</span><span class="s2">,</span>
        <span class="s1">by_alias</span><span class="s2">=</span><span class="s1">by_alias</span><span class="s2">,</span>
        <span class="s1">model_name_map</span><span class="s2">=</span><span class="s1">model_name_map</span><span class="s2">,</span>
        <span class="s1">ref_prefix</span><span class="s2">=</span><span class="s1">ref_prefix</span><span class="s2">,</span>
        <span class="s1">ref_template</span><span class="s2">=</span><span class="s1">ref_template</span><span class="s2">,</span>
        <span class="s1">known_models</span><span class="s2">=</span><span class="s1">known_models</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s1">s</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">m_schema</span><span class="s2">)</span>
    <span class="s1">schema_extra </span><span class="s2">= </span><span class="s1">model</span><span class="s2">.</span><span class="s1">__config__</span><span class="s2">.</span><span class="s1">schema_extra</span>
    <span class="s0">if </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">schema_extra</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">schema_extra</span><span class="s2">).</span><span class="s1">parameters</span><span class="s2">) == </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">schema_extra</span><span class="s2">(</span><span class="s1">s</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">schema_extra</span><span class="s2">(</span><span class="s1">s</span><span class="s2">, </span><span class="s1">model</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">s</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">schema_extra</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">s</span><span class="s2">, </span><span class="s1">m_definitions</span><span class="s2">, </span><span class="s1">nested_models</span>


<span class="s0">def </span><span class="s1">model_type_schema</span><span class="s2">(</span>
    <span class="s1">model</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">[</span><span class="s3">'BaseModel'</span><span class="s2">],</span>
    <span class="s2">*,</span>
    <span class="s1">by_alias</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">,</span>
    <span class="s1">model_name_map</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">TypeModelOrEnum</span><span class="s2">, </span><span class="s1">str</span><span class="s2">],</span>
    <span class="s1">ref_template</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
    <span class="s1">ref_prefix</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">known_models</span><span class="s2">: </span><span class="s1">TypeModelSet</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; Tuple</span><span class="s2">[</span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], </span><span class="s1">Set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]]:</span>
    <span class="s4">&quot;&quot;&quot; 
    You probably should be using ``model_schema()``, this function is indirectly used by that function. 
 
    Take a single ``model`` and generate the schema for its type only, not including additional 
    information as title, etc. Also return additional schema definitions, from sub-models. 
    &quot;&quot;&quot;</span>
    <span class="s1">properties </span><span class="s2">= {}</span>
    <span class="s1">required </span><span class="s2">= []</span>
    <span class="s1">definitions</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] = {}</span>
    <span class="s1">nested_models</span><span class="s2">: </span><span class="s1">Set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s1">set</span><span class="s2">()</span>
    <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">f </span><span class="s0">in </span><span class="s1">model</span><span class="s2">.</span><span class="s1">__fields__</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">f_schema</span><span class="s2">, </span><span class="s1">f_definitions</span><span class="s2">, </span><span class="s1">f_nested_models </span><span class="s2">= </span><span class="s1">field_schema</span><span class="s2">(</span>
                <span class="s1">f</span><span class="s2">,</span>
                <span class="s1">by_alias</span><span class="s2">=</span><span class="s1">by_alias</span><span class="s2">,</span>
                <span class="s1">model_name_map</span><span class="s2">=</span><span class="s1">model_name_map</span><span class="s2">,</span>
                <span class="s1">ref_prefix</span><span class="s2">=</span><span class="s1">ref_prefix</span><span class="s2">,</span>
                <span class="s1">ref_template</span><span class="s2">=</span><span class="s1">ref_template</span><span class="s2">,</span>
                <span class="s1">known_models</span><span class="s2">=</span><span class="s1">known_models</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s0">except </span><span class="s1">SkipField </span><span class="s0">as </span><span class="s1">skip</span><span class="s2">:</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">skip</span><span class="s2">.</span><span class="s1">message</span><span class="s2">, </span><span class="s1">UserWarning</span><span class="s2">)</span>
            <span class="s0">continue</span>
        <span class="s1">definitions</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">f_definitions</span><span class="s2">)</span>
        <span class="s1">nested_models</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">f_nested_models</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">by_alias</span><span class="s2">:</span>
            <span class="s1">properties</span><span class="s2">[</span><span class="s1">f</span><span class="s2">.</span><span class="s1">alias</span><span class="s2">] = </span><span class="s1">f_schema</span>
            <span class="s0">if </span><span class="s1">f</span><span class="s2">.</span><span class="s1">required</span><span class="s2">:</span>
                <span class="s1">required</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">f</span><span class="s2">.</span><span class="s1">alias</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">properties</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = </span><span class="s1">f_schema</span>
            <span class="s0">if </span><span class="s1">f</span><span class="s2">.</span><span class="s1">required</span><span class="s2">:</span>
                <span class="s1">required</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">k</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">ROOT_KEY </span><span class="s0">in </span><span class="s1">properties</span><span class="s2">:</span>
        <span class="s1">out_schema </span><span class="s2">= </span><span class="s1">properties</span><span class="s2">[</span><span class="s1">ROOT_KEY</span><span class="s2">]</span>
        <span class="s1">out_schema</span><span class="s2">[</span><span class="s3">'title'</span><span class="s2">] = </span><span class="s1">model</span><span class="s2">.</span><span class="s1">__config__</span><span class="s2">.</span><span class="s1">title </span><span class="s0">or </span><span class="s1">model</span><span class="s2">.</span><span class="s1">__name__</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">out_schema </span><span class="s2">= {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'object'</span><span class="s2">, </span><span class="s3">'properties'</span><span class="s2">: </span><span class="s1">properties</span><span class="s2">}</span>
        <span class="s0">if </span><span class="s1">required</span><span class="s2">:</span>
            <span class="s1">out_schema</span><span class="s2">[</span><span class="s3">'required'</span><span class="s2">] = </span><span class="s1">required</span>
    <span class="s0">if </span><span class="s1">model</span><span class="s2">.</span><span class="s1">__config__</span><span class="s2">.</span><span class="s1">extra </span><span class="s2">== </span><span class="s3">'forbid'</span><span class="s2">:</span>
        <span class="s1">out_schema</span><span class="s2">[</span><span class="s3">'additionalProperties'</span><span class="s2">] = </span><span class="s0">False</span>
    <span class="s0">return </span><span class="s1">out_schema</span><span class="s2">, </span><span class="s1">definitions</span><span class="s2">, </span><span class="s1">nested_models</span>


<span class="s0">def </span><span class="s1">enum_process_schema</span><span class="s2">(</span><span class="s1">enum</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">[</span><span class="s1">Enum</span><span class="s2">], *, </span><span class="s1">field</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">ModelField</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]:</span>
    <span class="s4">&quot;&quot;&quot; 
    Take a single `enum` and generate its schema. 
 
    This is similar to the `model_process_schema` function, but applies to ``Enum`` objects. 
    &quot;&quot;&quot;</span>
    <span class="s0">import </span><span class="s1">inspect</span>

    <span class="s1">schema_</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] = {</span>
        <span class="s3">'title'</span><span class="s2">: </span><span class="s1">enum</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">,</span>
        <span class="s5"># Python assigns all enums a default docstring value of 'An enumeration', so</span>
        <span class="s5"># all enums will have a description field even if not explicitly provided.</span>
        <span class="s3">'description'</span><span class="s2">: </span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">cleandoc</span><span class="s2">(</span><span class="s1">enum</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s0">or </span><span class="s3">'An enumeration.'</span><span class="s2">),</span>
        <span class="s5"># Add enum values and the enum field type to the schema.</span>
        <span class="s3">'enum'</span><span class="s2">: [</span><span class="s1">item</span><span class="s2">.</span><span class="s1">value </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">Iterable</span><span class="s2">[</span><span class="s1">Enum</span><span class="s2">], </span><span class="s1">enum</span><span class="s2">)],</span>
    <span class="s2">}</span>

    <span class="s1">add_field_type_to_schema</span><span class="s2">(</span><span class="s1">enum</span><span class="s2">, </span><span class="s1">schema_</span><span class="s2">)</span>

    <span class="s1">modify_schema </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">enum</span><span class="s2">, </span><span class="s3">'__modify_schema__'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">modify_schema</span><span class="s2">:</span>
        <span class="s1">_apply_modify_schema</span><span class="s2">(</span><span class="s1">modify_schema</span><span class="s2">, </span><span class="s1">field</span><span class="s2">, </span><span class="s1">schema_</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">schema_</span>


<span class="s0">def </span><span class="s1">field_singleton_sub_fields_schema</span><span class="s2">(</span>
    <span class="s1">field</span><span class="s2">: </span><span class="s1">ModelField</span><span class="s2">,</span>
    <span class="s2">*,</span>
    <span class="s1">by_alias</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">,</span>
    <span class="s1">model_name_map</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">TypeModelOrEnum</span><span class="s2">, </span><span class="s1">str</span><span class="s2">],</span>
    <span class="s1">ref_template</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
    <span class="s1">schema_overrides</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s1">ref_prefix</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">known_models</span><span class="s2">: </span><span class="s1">TypeModelSet</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; Tuple</span><span class="s2">[</span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], </span><span class="s1">Set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]]:</span>
    <span class="s4">&quot;&quot;&quot; 
    This function is indirectly used by ``field_schema()``, you probably should be using that function. 
 
    Take a list of Pydantic ``ModelField`` from the declaration of a type with parameters, and generate their 
    schema. I.e., fields used as &quot;type parameters&quot;, like ``str`` and ``int`` in ``Tuple[str, int]``. 
    &quot;&quot;&quot;</span>
    <span class="s1">sub_fields </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">List</span><span class="s2">[</span><span class="s1">ModelField</span><span class="s2">], </span><span class="s1">field</span><span class="s2">.</span><span class="s1">sub_fields</span><span class="s2">)</span>
    <span class="s1">definitions </span><span class="s2">= {}</span>
    <span class="s1">nested_models</span><span class="s2">: </span><span class="s1">Set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s1">set</span><span class="s2">()</span>
    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">sub_fields</span><span class="s2">) == </span><span class="s6">1</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">field_type_schema</span><span class="s2">(</span>
            <span class="s1">sub_fields</span><span class="s2">[</span><span class="s6">0</span><span class="s2">],</span>
            <span class="s1">by_alias</span><span class="s2">=</span><span class="s1">by_alias</span><span class="s2">,</span>
            <span class="s1">model_name_map</span><span class="s2">=</span><span class="s1">model_name_map</span><span class="s2">,</span>
            <span class="s1">schema_overrides</span><span class="s2">=</span><span class="s1">schema_overrides</span><span class="s2">,</span>
            <span class="s1">ref_prefix</span><span class="s2">=</span><span class="s1">ref_prefix</span><span class="s2">,</span>
            <span class="s1">ref_template</span><span class="s2">=</span><span class="s1">ref_template</span><span class="s2">,</span>
            <span class="s1">known_models</span><span class="s2">=</span><span class="s1">known_models</span><span class="s2">,</span>
        <span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">s</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] = {}</span>
        <span class="s5"># https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#discriminator-object</span>
        <span class="s1">field_has_discriminator</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s1">field</span><span class="s2">.</span><span class="s1">discriminator_key </span><span class="s0">is not None</span>
        <span class="s0">if </span><span class="s1">field_has_discriminator</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s1">field</span><span class="s2">.</span><span class="s1">sub_fields_mapping </span><span class="s0">is not None</span>

            <span class="s1">discriminator_models_refs</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]]] = {}</span>

            <span class="s0">for </span><span class="s1">discriminator_value</span><span class="s2">, </span><span class="s1">sub_field </span><span class="s0">in </span><span class="s1">field</span><span class="s2">.</span><span class="s1">sub_fields_mapping</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">discriminator_value</span><span class="s2">, </span><span class="s1">Enum</span><span class="s2">):</span>
                    <span class="s1">discriminator_value </span><span class="s2">= </span><span class="s1">str</span><span class="s2">(</span><span class="s1">discriminator_value</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>
                <span class="s5"># sub_field is either a `BaseModel` or directly an `Annotated` `Union` of many</span>
                <span class="s0">if </span><span class="s1">is_union</span><span class="s2">(</span><span class="s1">get_origin</span><span class="s2">(</span><span class="s1">sub_field</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)):</span>
                    <span class="s1">sub_models </span><span class="s2">= </span><span class="s1">get_sub_types</span><span class="s2">(</span><span class="s1">sub_field</span><span class="s2">.</span><span class="s1">type_</span><span class="s2">)</span>
                    <span class="s1">discriminator_models_refs</span><span class="s2">[</span><span class="s1">discriminator_value</span><span class="s2">] = {</span>
                        <span class="s1">model_name_map</span><span class="s2">[</span><span class="s1">sub_model</span><span class="s2">]: </span><span class="s1">get_schema_ref</span><span class="s2">(</span>
                            <span class="s1">model_name_map</span><span class="s2">[</span><span class="s1">sub_model</span><span class="s2">], </span><span class="s1">ref_prefix</span><span class="s2">, </span><span class="s1">ref_template</span><span class="s2">, </span><span class="s0">False</span>
                        <span class="s2">)</span>
                        <span class="s0">for </span><span class="s1">sub_model </span><span class="s0">in </span><span class="s1">sub_models</span>
                    <span class="s2">}</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">sub_field_type </span><span class="s2">= </span><span class="s1">sub_field</span><span class="s2">.</span><span class="s1">type_</span>
                    <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">sub_field_type</span><span class="s2">, </span><span class="s3">'__pydantic_model__'</span><span class="s2">):</span>
                        <span class="s1">sub_field_type </span><span class="s2">= </span><span class="s1">sub_field_type</span><span class="s2">.</span><span class="s1">__pydantic_model__</span>

                    <span class="s1">discriminator_model_name </span><span class="s2">= </span><span class="s1">model_name_map</span><span class="s2">[</span><span class="s1">sub_field_type</span><span class="s2">]</span>
                    <span class="s1">discriminator_model_ref </span><span class="s2">= </span><span class="s1">get_schema_ref</span><span class="s2">(</span><span class="s1">discriminator_model_name</span><span class="s2">, </span><span class="s1">ref_prefix</span><span class="s2">, </span><span class="s1">ref_template</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
                    <span class="s1">discriminator_models_refs</span><span class="s2">[</span><span class="s1">discriminator_value</span><span class="s2">] = </span><span class="s1">discriminator_model_ref</span><span class="s2">[</span><span class="s3">'$ref'</span><span class="s2">]</span>

            <span class="s1">s</span><span class="s2">[</span><span class="s3">'discriminator'</span><span class="s2">] = {</span>
                <span class="s3">'propertyName'</span><span class="s2">: </span><span class="s1">field</span><span class="s2">.</span><span class="s1">discriminator_alias </span><span class="s0">if </span><span class="s1">by_alias </span><span class="s0">else </span><span class="s1">field</span><span class="s2">.</span><span class="s1">discriminator_key</span><span class="s2">,</span>
                <span class="s3">'mapping'</span><span class="s2">: </span><span class="s1">discriminator_models_refs</span><span class="s2">,</span>
            <span class="s2">}</span>

        <span class="s1">sub_field_schemas </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">sf </span><span class="s0">in </span><span class="s1">sub_fields</span><span class="s2">:</span>
            <span class="s1">sub_schema</span><span class="s2">, </span><span class="s1">sub_definitions</span><span class="s2">, </span><span class="s1">sub_nested_models </span><span class="s2">= </span><span class="s1">field_type_schema</span><span class="s2">(</span>
                <span class="s1">sf</span><span class="s2">,</span>
                <span class="s1">by_alias</span><span class="s2">=</span><span class="s1">by_alias</span><span class="s2">,</span>
                <span class="s1">model_name_map</span><span class="s2">=</span><span class="s1">model_name_map</span><span class="s2">,</span>
                <span class="s1">schema_overrides</span><span class="s2">=</span><span class="s1">schema_overrides</span><span class="s2">,</span>
                <span class="s1">ref_prefix</span><span class="s2">=</span><span class="s1">ref_prefix</span><span class="s2">,</span>
                <span class="s1">ref_template</span><span class="s2">=</span><span class="s1">ref_template</span><span class="s2">,</span>
                <span class="s1">known_models</span><span class="s2">=</span><span class="s1">known_models</span><span class="s2">,</span>
            <span class="s2">)</span>
            <span class="s1">definitions</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">sub_definitions</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">schema_overrides </span><span class="s0">and </span><span class="s3">'allOf' </span><span class="s0">in </span><span class="s1">sub_schema</span><span class="s2">:</span>
                <span class="s5"># if the sub_field is a referenced schema we only need the referenced</span>
                <span class="s5"># object. Otherwise we will end up with several allOf inside anyOf/oneOf.</span>
                <span class="s5"># See https://github.com/pydantic/pydantic/issues/1209</span>
                <span class="s1">sub_schema </span><span class="s2">= </span><span class="s1">sub_schema</span><span class="s2">[</span><span class="s3">'allOf'</span><span class="s2">][</span><span class="s6">0</span><span class="s2">]</span>

            <span class="s0">if </span><span class="s1">sub_schema</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">() == {</span><span class="s3">'discriminator'</span><span class="s2">, </span><span class="s3">'oneOf'</span><span class="s2">}:</span>
                <span class="s5"># we don't want discriminator information inside oneOf choices, this is dealt with elsewhere</span>
                <span class="s1">sub_schema</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'discriminator'</span><span class="s2">)</span>
            <span class="s1">sub_field_schemas</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">sub_schema</span><span class="s2">)</span>
            <span class="s1">nested_models</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">sub_nested_models</span><span class="s2">)</span>
        <span class="s1">s</span><span class="s2">[</span><span class="s3">'oneOf' </span><span class="s0">if </span><span class="s1">field_has_discriminator </span><span class="s0">else </span><span class="s3">'anyOf'</span><span class="s2">] = </span><span class="s1">sub_field_schemas</span>
        <span class="s0">return </span><span class="s1">s</span><span class="s2">, </span><span class="s1">definitions</span><span class="s2">, </span><span class="s1">nested_models</span>


<span class="s5"># Order is important, e.g. subclasses of str must go before str</span>
<span class="s5"># this is used only for standard library types, custom types should use __modify_schema__ instead</span>
<span class="s1">field_class_to_schema</span><span class="s2">: </span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]], ...] = (</span>
    <span class="s2">(</span><span class="s1">Path</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'string'</span><span class="s2">, </span><span class="s3">'format'</span><span class="s2">: </span><span class="s3">'path'</span><span class="s2">}),</span>
    <span class="s2">(</span><span class="s1">datetime</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'string'</span><span class="s2">, </span><span class="s3">'format'</span><span class="s2">: </span><span class="s3">'date-time'</span><span class="s2">}),</span>
    <span class="s2">(</span><span class="s1">date</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'string'</span><span class="s2">, </span><span class="s3">'format'</span><span class="s2">: </span><span class="s3">'date'</span><span class="s2">}),</span>
    <span class="s2">(</span><span class="s1">time</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'string'</span><span class="s2">, </span><span class="s3">'format'</span><span class="s2">: </span><span class="s3">'time'</span><span class="s2">}),</span>
    <span class="s2">(</span><span class="s1">timedelta</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'number'</span><span class="s2">, </span><span class="s3">'format'</span><span class="s2">: </span><span class="s3">'time-delta'</span><span class="s2">}),</span>
    <span class="s2">(</span><span class="s1">IPv4Network</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'string'</span><span class="s2">, </span><span class="s3">'format'</span><span class="s2">: </span><span class="s3">'ipv4network'</span><span class="s2">}),</span>
    <span class="s2">(</span><span class="s1">IPv6Network</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'string'</span><span class="s2">, </span><span class="s3">'format'</span><span class="s2">: </span><span class="s3">'ipv6network'</span><span class="s2">}),</span>
    <span class="s2">(</span><span class="s1">IPv4Interface</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'string'</span><span class="s2">, </span><span class="s3">'format'</span><span class="s2">: </span><span class="s3">'ipv4interface'</span><span class="s2">}),</span>
    <span class="s2">(</span><span class="s1">IPv6Interface</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'string'</span><span class="s2">, </span><span class="s3">'format'</span><span class="s2">: </span><span class="s3">'ipv6interface'</span><span class="s2">}),</span>
    <span class="s2">(</span><span class="s1">IPv4Address</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'string'</span><span class="s2">, </span><span class="s3">'format'</span><span class="s2">: </span><span class="s3">'ipv4'</span><span class="s2">}),</span>
    <span class="s2">(</span><span class="s1">IPv6Address</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'string'</span><span class="s2">, </span><span class="s3">'format'</span><span class="s2">: </span><span class="s3">'ipv6'</span><span class="s2">}),</span>
    <span class="s2">(</span><span class="s1">Pattern</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'string'</span><span class="s2">, </span><span class="s3">'format'</span><span class="s2">: </span><span class="s3">'regex'</span><span class="s2">}),</span>
    <span class="s2">(</span><span class="s1">str</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'string'</span><span class="s2">}),</span>
    <span class="s2">(</span><span class="s1">bytes</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'string'</span><span class="s2">, </span><span class="s3">'format'</span><span class="s2">: </span><span class="s3">'binary'</span><span class="s2">}),</span>
    <span class="s2">(</span><span class="s1">bool</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'boolean'</span><span class="s2">}),</span>
    <span class="s2">(</span><span class="s1">int</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'integer'</span><span class="s2">}),</span>
    <span class="s2">(</span><span class="s1">float</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'number'</span><span class="s2">}),</span>
    <span class="s2">(</span><span class="s1">Decimal</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'number'</span><span class="s2">}),</span>
    <span class="s2">(</span><span class="s1">UUID</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'string'</span><span class="s2">, </span><span class="s3">'format'</span><span class="s2">: </span><span class="s3">'uuid'</span><span class="s2">}),</span>
    <span class="s2">(</span><span class="s1">dict</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'object'</span><span class="s2">}),</span>
    <span class="s2">(</span><span class="s1">list</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'array'</span><span class="s2">, </span><span class="s3">'items'</span><span class="s2">: {}}),</span>
    <span class="s2">(</span><span class="s1">tuple</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'array'</span><span class="s2">, </span><span class="s3">'items'</span><span class="s2">: {}}),</span>
    <span class="s2">(</span><span class="s1">set</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'array'</span><span class="s2">, </span><span class="s3">'items'</span><span class="s2">: {}, </span><span class="s3">'uniqueItems'</span><span class="s2">: </span><span class="s0">True</span><span class="s2">}),</span>
    <span class="s2">(</span><span class="s1">frozenset</span><span class="s2">, {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'array'</span><span class="s2">, </span><span class="s3">'items'</span><span class="s2">: {}, </span><span class="s3">'uniqueItems'</span><span class="s2">: </span><span class="s0">True</span><span class="s2">}),</span>
<span class="s2">)</span>

<span class="s1">json_scheme </span><span class="s2">= {</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'string'</span><span class="s2">, </span><span class="s3">'format'</span><span class="s2">: </span><span class="s3">'json-string'</span><span class="s2">}</span>


<span class="s0">def </span><span class="s1">add_field_type_to_schema</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">schema_</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Update the given `schema` with the type-specific metadata for the given `field_type`. 
 
    This function looks through `field_class_to_schema` for a class that matches the given `field_type`, 
    and then modifies the given `schema` with the information from that type. 
    &quot;&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">type_</span><span class="s2">, </span><span class="s1">t_schema </span><span class="s0">in </span><span class="s1">field_class_to_schema</span><span class="s2">:</span>
        <span class="s5"># Fallback for `typing.Pattern` and `re.Pattern` as they are not a valid class</span>
        <span class="s0">if </span><span class="s1">lenient_issubclass</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">, </span><span class="s1">type_</span><span class="s2">) </span><span class="s0">or </span><span class="s1">field_type </span><span class="s0">is </span><span class="s1">type_ </span><span class="s0">is </span><span class="s1">Pattern</span><span class="s2">:</span>
            <span class="s1">schema_</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">t_schema</span><span class="s2">)</span>
            <span class="s0">break</span>


<span class="s0">def </span><span class="s1">get_schema_ref</span><span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">ref_prefix</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">], </span><span class="s1">ref_template</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">schema_overrides</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">) </span><span class="s1">-&gt; Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]:</span>
    <span class="s0">if </span><span class="s1">ref_prefix</span><span class="s2">:</span>
        <span class="s1">schema_ref </span><span class="s2">= {</span><span class="s3">'$ref'</span><span class="s2">: </span><span class="s1">ref_prefix </span><span class="s2">+ </span><span class="s1">name</span><span class="s2">}</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">schema_ref </span><span class="s2">= {</span><span class="s3">'$ref'</span><span class="s2">: </span><span class="s1">ref_template</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">model</span><span class="s2">=</span><span class="s1">name</span><span class="s2">)}</span>
    <span class="s0">return </span><span class="s2">{</span><span class="s3">'allOf'</span><span class="s2">: [</span><span class="s1">schema_ref</span><span class="s2">]} </span><span class="s0">if </span><span class="s1">schema_overrides </span><span class="s0">else </span><span class="s1">schema_ref</span>


<span class="s0">def </span><span class="s1">field_singleton_schema</span><span class="s2">(  </span><span class="s5"># noqa: C901 (ignore complexity)</span>
    <span class="s1">field</span><span class="s2">: </span><span class="s1">ModelField</span><span class="s2">,</span>
    <span class="s2">*,</span>
    <span class="s1">by_alias</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">,</span>
    <span class="s1">model_name_map</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">TypeModelOrEnum</span><span class="s2">, </span><span class="s1">str</span><span class="s2">],</span>
    <span class="s1">ref_template</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
    <span class="s1">schema_overrides</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s1">ref_prefix</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">known_models</span><span class="s2">: </span><span class="s1">TypeModelSet</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; Tuple</span><span class="s2">[</span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], </span><span class="s1">Set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]]:</span>
    <span class="s4">&quot;&quot;&quot; 
    This function is indirectly used by ``field_schema()``, you should probably be using that function. 
 
    Take a single Pydantic ``ModelField``, and return its schema and any additional definitions from sub-models. 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">main </span><span class="s0">import </span><span class="s1">BaseModel</span>

    <span class="s1">definitions</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] = {}</span>
    <span class="s1">nested_models</span><span class="s2">: </span><span class="s1">Set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s1">set</span><span class="s2">()</span>
    <span class="s1">field_type </span><span class="s2">= </span><span class="s1">field</span><span class="s2">.</span><span class="s1">type_</span>

    <span class="s5"># Recurse into this field if it contains sub_fields and is NOT a</span>
    <span class="s5"># BaseModel OR that BaseModel is a const</span>
    <span class="s0">if </span><span class="s1">field</span><span class="s2">.</span><span class="s1">sub_fields </span><span class="s0">and </span><span class="s2">(</span>
        <span class="s2">(</span><span class="s1">field</span><span class="s2">.</span><span class="s1">field_info </span><span class="s0">and </span><span class="s1">field</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">const</span><span class="s2">) </span><span class="s0">or not </span><span class="s1">lenient_issubclass</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">, </span><span class="s1">BaseModel</span><span class="s2">)</span>
    <span class="s2">):</span>
        <span class="s0">return </span><span class="s1">field_singleton_sub_fields_schema</span><span class="s2">(</span>
            <span class="s1">field</span><span class="s2">,</span>
            <span class="s1">by_alias</span><span class="s2">=</span><span class="s1">by_alias</span><span class="s2">,</span>
            <span class="s1">model_name_map</span><span class="s2">=</span><span class="s1">model_name_map</span><span class="s2">,</span>
            <span class="s1">schema_overrides</span><span class="s2">=</span><span class="s1">schema_overrides</span><span class="s2">,</span>
            <span class="s1">ref_prefix</span><span class="s2">=</span><span class="s1">ref_prefix</span><span class="s2">,</span>
            <span class="s1">ref_template</span><span class="s2">=</span><span class="s1">ref_template</span><span class="s2">,</span>
            <span class="s1">known_models</span><span class="s2">=</span><span class="s1">known_models</span><span class="s2">,</span>
        <span class="s2">)</span>
    <span class="s0">if </span><span class="s1">field_type </span><span class="s0">is </span><span class="s1">Any </span><span class="s0">or </span><span class="s1">field_type </span><span class="s0">is </span><span class="s1">object </span><span class="s0">or </span><span class="s1">field_type</span><span class="s2">.</span><span class="s1">__class__ </span><span class="s2">== </span><span class="s1">TypeVar </span><span class="s0">or </span><span class="s1">get_origin</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">) </span><span class="s0">is </span><span class="s1">type</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s2">{}, </span><span class="s1">definitions</span><span class="s2">, </span><span class="s1">nested_models  </span><span class="s5"># no restrictions</span>
    <span class="s0">if </span><span class="s1">is_none_type</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span><span class="s3">'type'</span><span class="s2">: </span><span class="s3">'null'</span><span class="s2">}, </span><span class="s1">definitions</span><span class="s2">, </span><span class="s1">nested_models</span>
    <span class="s0">if </span><span class="s1">is_callable_type</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">SkipField</span><span class="s2">(</span><span class="s3">f'Callable </span><span class="s0">{</span><span class="s1">field</span><span class="s2">.</span><span class="s1">name</span><span class="s0">} </span><span class="s3">was excluded from schema since JSON schema has no equivalent type.'</span><span class="s2">)</span>
    <span class="s1">f_schema</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] = {}</span>
    <span class="s0">if </span><span class="s1">field</span><span class="s2">.</span><span class="s1">field_info </span><span class="s0">is not None and </span><span class="s1">field</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">const</span><span class="s2">:</span>
        <span class="s1">f_schema</span><span class="s2">[</span><span class="s3">'const'</span><span class="s2">] = </span><span class="s1">field</span><span class="s2">.</span><span class="s1">default</span>

    <span class="s0">if </span><span class="s1">is_literal_type</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">):</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">value </span><span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">Enum</span><span class="s2">) </span><span class="s0">else </span><span class="s1">x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">all_literal_values</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">))</span>

        <span class="s0">if </span><span class="s1">len</span><span class="s2">({</span><span class="s1">v</span><span class="s2">.</span><span class="s1">__class__ </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">values</span><span class="s2">}) &gt; </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">field_schema</span><span class="s2">(</span>
                <span class="s1">multitypes_literal_field_for_schema</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">field</span><span class="s2">),</span>
                <span class="s1">by_alias</span><span class="s2">=</span><span class="s1">by_alias</span><span class="s2">,</span>
                <span class="s1">model_name_map</span><span class="s2">=</span><span class="s1">model_name_map</span><span class="s2">,</span>
                <span class="s1">ref_prefix</span><span class="s2">=</span><span class="s1">ref_prefix</span><span class="s2">,</span>
                <span class="s1">ref_template</span><span class="s2">=</span><span class="s1">ref_template</span><span class="s2">,</span>
                <span class="s1">known_models</span><span class="s2">=</span><span class="s1">known_models</span><span class="s2">,</span>
            <span class="s2">)</span>

        <span class="s5"># All values have the same type</span>
        <span class="s1">field_type </span><span class="s2">= </span><span class="s1">values</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">__class__</span>
        <span class="s1">f_schema</span><span class="s2">[</span><span class="s3">'enum'</span><span class="s2">] = </span><span class="s1">list</span><span class="s2">(</span><span class="s1">values</span><span class="s2">)</span>
        <span class="s1">add_field_type_to_schema</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">, </span><span class="s1">f_schema</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">lenient_issubclass</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">, </span><span class="s1">Enum</span><span class="s2">):</span>
        <span class="s1">enum_name </span><span class="s2">= </span><span class="s1">model_name_map</span><span class="s2">[</span><span class="s1">field_type</span><span class="s2">]</span>
        <span class="s1">f_schema</span><span class="s2">, </span><span class="s1">schema_overrides </span><span class="s2">= </span><span class="s1">get_field_info_schema</span><span class="s2">(</span><span class="s1">field</span><span class="s2">, </span><span class="s1">schema_overrides</span><span class="s2">)</span>
        <span class="s1">f_schema</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">get_schema_ref</span><span class="s2">(</span><span class="s1">enum_name</span><span class="s2">, </span><span class="s1">ref_prefix</span><span class="s2">, </span><span class="s1">ref_template</span><span class="s2">, </span><span class="s1">schema_overrides</span><span class="s2">))</span>
        <span class="s1">definitions</span><span class="s2">[</span><span class="s1">enum_name</span><span class="s2">] = </span><span class="s1">enum_process_schema</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">, </span><span class="s1">field</span><span class="s2">=</span><span class="s1">field</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">is_namedtuple</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">):</span>
        <span class="s1">sub_schema</span><span class="s2">, *</span><span class="s1">_ </span><span class="s2">= </span><span class="s1">model_process_schema</span><span class="s2">(</span>
            <span class="s1">field_type</span><span class="s2">.</span><span class="s1">__pydantic_model__</span><span class="s2">,</span>
            <span class="s1">by_alias</span><span class="s2">=</span><span class="s1">by_alias</span><span class="s2">,</span>
            <span class="s1">model_name_map</span><span class="s2">=</span><span class="s1">model_name_map</span><span class="s2">,</span>
            <span class="s1">ref_prefix</span><span class="s2">=</span><span class="s1">ref_prefix</span><span class="s2">,</span>
            <span class="s1">ref_template</span><span class="s2">=</span><span class="s1">ref_template</span><span class="s2">,</span>
            <span class="s1">known_models</span><span class="s2">=</span><span class="s1">known_models</span><span class="s2">,</span>
            <span class="s1">field</span><span class="s2">=</span><span class="s1">field</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">items_schemas </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">sub_schema</span><span class="s2">[</span><span class="s3">'properties'</span><span class="s2">].</span><span class="s1">values</span><span class="s2">())</span>
        <span class="s1">f_schema</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span>
            <span class="s2">{</span>
                <span class="s3">'type'</span><span class="s2">: </span><span class="s3">'array'</span><span class="s2">,</span>
                <span class="s3">'items'</span><span class="s2">: </span><span class="s1">items_schemas</span><span class="s2">,</span>
                <span class="s3">'minItems'</span><span class="s2">: </span><span class="s1">len</span><span class="s2">(</span><span class="s1">items_schemas</span><span class="s2">),</span>
                <span class="s3">'maxItems'</span><span class="s2">: </span><span class="s1">len</span><span class="s2">(</span><span class="s1">items_schemas</span><span class="s2">),</span>
            <span class="s2">}</span>
        <span class="s2">)</span>
    <span class="s0">elif not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">, </span><span class="s3">'__pydantic_model__'</span><span class="s2">):</span>
        <span class="s1">add_field_type_to_schema</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">, </span><span class="s1">f_schema</span><span class="s2">)</span>

        <span class="s1">modify_schema </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">, </span><span class="s3">'__modify_schema__'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">modify_schema</span><span class="s2">:</span>
            <span class="s1">_apply_modify_schema</span><span class="s2">(</span><span class="s1">modify_schema</span><span class="s2">, </span><span class="s1">field</span><span class="s2">, </span><span class="s1">f_schema</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">f_schema</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">f_schema</span><span class="s2">, </span><span class="s1">definitions</span><span class="s2">, </span><span class="s1">nested_models</span>

    <span class="s5"># Handle dataclass-based models</span>
    <span class="s0">if </span><span class="s1">lenient_issubclass</span><span class="s2">(</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">, </span><span class="s3">'__pydantic_model__'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">), </span><span class="s1">BaseModel</span><span class="s2">):</span>
        <span class="s1">field_type </span><span class="s2">= </span><span class="s1">field_type</span><span class="s2">.</span><span class="s1">__pydantic_model__</span>

    <span class="s0">if </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">, </span><span class="s1">BaseModel</span><span class="s2">):</span>
        <span class="s1">model_name </span><span class="s2">= </span><span class="s1">model_name_map</span><span class="s2">[</span><span class="s1">field_type</span><span class="s2">]</span>
        <span class="s0">if </span><span class="s1">field_type </span><span class="s0">not in </span><span class="s1">known_models</span><span class="s2">:</span>
            <span class="s1">sub_schema</span><span class="s2">, </span><span class="s1">sub_definitions</span><span class="s2">, </span><span class="s1">sub_nested_models </span><span class="s2">= </span><span class="s1">model_process_schema</span><span class="s2">(</span>
                <span class="s1">field_type</span><span class="s2">,</span>
                <span class="s1">by_alias</span><span class="s2">=</span><span class="s1">by_alias</span><span class="s2">,</span>
                <span class="s1">model_name_map</span><span class="s2">=</span><span class="s1">model_name_map</span><span class="s2">,</span>
                <span class="s1">ref_prefix</span><span class="s2">=</span><span class="s1">ref_prefix</span><span class="s2">,</span>
                <span class="s1">ref_template</span><span class="s2">=</span><span class="s1">ref_template</span><span class="s2">,</span>
                <span class="s1">known_models</span><span class="s2">=</span><span class="s1">known_models</span><span class="s2">,</span>
                <span class="s1">field</span><span class="s2">=</span><span class="s1">field</span><span class="s2">,</span>
            <span class="s2">)</span>
            <span class="s1">definitions</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">sub_definitions</span><span class="s2">)</span>
            <span class="s1">definitions</span><span class="s2">[</span><span class="s1">model_name</span><span class="s2">] = </span><span class="s1">sub_schema</span>
            <span class="s1">nested_models</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">sub_nested_models</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">nested_models</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">model_name</span><span class="s2">)</span>
        <span class="s1">schema_ref </span><span class="s2">= </span><span class="s1">get_schema_ref</span><span class="s2">(</span><span class="s1">model_name</span><span class="s2">, </span><span class="s1">ref_prefix</span><span class="s2">, </span><span class="s1">ref_template</span><span class="s2">, </span><span class="s1">schema_overrides</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">schema_ref</span><span class="s2">, </span><span class="s1">definitions</span><span class="s2">, </span><span class="s1">nested_models</span>

    <span class="s5"># For generics with no args</span>
    <span class="s1">args </span><span class="s2">= </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">field_type</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">args </span><span class="s0">is not None and not </span><span class="s1">args </span><span class="s0">and </span><span class="s1">Generic </span><span class="s0">in </span><span class="s1">field_type</span><span class="s2">.</span><span class="s1">__bases__</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">f_schema</span><span class="s2">, </span><span class="s1">definitions</span><span class="s2">, </span><span class="s1">nested_models</span>

    <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f'Value not declarable with JSON Schema, field: </span><span class="s0">{</span><span class="s1">field</span><span class="s0">}</span><span class="s3">'</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">multitypes_literal_field_for_schema</span><span class="s2">(</span><span class="s1">values</span><span class="s2">: </span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...], </span><span class="s1">field</span><span class="s2">: </span><span class="s1">ModelField</span><span class="s2">) </span><span class="s1">-&gt; ModelField</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    To support `Literal` with values of different types, we split it into multiple `Literal` with same type 
    e.g. `Literal['qwe', 'asd', 1, 2]` becomes `Union[Literal['qwe', 'asd'], Literal[1, 2]]` 
    &quot;&quot;&quot;</span>
    <span class="s1">literal_distinct_types </span><span class="s2">= </span><span class="s1">defaultdict</span><span class="s2">(</span><span class="s1">list</span><span class="s2">)</span>
    <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">values</span><span class="s2">:</span>
        <span class="s1">literal_distinct_types</span><span class="s2">[</span><span class="s1">v</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">].</span><span class="s1">append</span><span class="s2">(</span><span class="s1">v</span><span class="s2">)</span>
    <span class="s1">distinct_literals </span><span class="s2">= (</span><span class="s1">Literal</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">same_type_values</span><span class="s2">)] </span><span class="s0">for </span><span class="s1">same_type_values </span><span class="s0">in </span><span class="s1">literal_distinct_types</span><span class="s2">.</span><span class="s1">values</span><span class="s2">())</span>

    <span class="s0">return </span><span class="s1">ModelField</span><span class="s2">(</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s1">field</span><span class="s2">.</span><span class="s1">name</span><span class="s2">,</span>
        <span class="s1">type_</span><span class="s2">=</span><span class="s1">Union</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">distinct_literals</span><span class="s2">)],  </span><span class="s5"># type: ignore</span>
        <span class="s1">class_validators</span><span class="s2">=</span><span class="s1">field</span><span class="s2">.</span><span class="s1">class_validators</span><span class="s2">,</span>
        <span class="s1">model_config</span><span class="s2">=</span><span class="s1">field</span><span class="s2">.</span><span class="s1">model_config</span><span class="s2">,</span>
        <span class="s1">default</span><span class="s2">=</span><span class="s1">field</span><span class="s2">.</span><span class="s1">default</span><span class="s2">,</span>
        <span class="s1">required</span><span class="s2">=</span><span class="s1">field</span><span class="s2">.</span><span class="s1">required</span><span class="s2">,</span>
        <span class="s1">alias</span><span class="s2">=</span><span class="s1">field</span><span class="s2">.</span><span class="s1">alias</span><span class="s2">,</span>
        <span class="s1">field_info</span><span class="s2">=</span><span class="s1">field</span><span class="s2">.</span><span class="s1">field_info</span><span class="s2">,</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">encode_default</span><span class="s2">(</span><span class="s1">dft</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">pydantic</span><span class="s2">.</span><span class="s1">v1</span><span class="s2">.</span><span class="s1">main </span><span class="s0">import </span><span class="s1">BaseModel</span>

    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dft</span><span class="s2">, </span><span class="s1">BaseModel</span><span class="s2">) </span><span class="s0">or </span><span class="s1">is_dataclass</span><span class="s2">(</span><span class="s1">dft</span><span class="s2">):</span>
        <span class="s1">dft </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s3">'dict[str, Any]'</span><span class="s2">, </span><span class="s1">pydantic_encoder</span><span class="s2">(</span><span class="s1">dft</span><span class="s2">))</span>

    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dft</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span><span class="s1">encode_default</span><span class="s2">(</span><span class="s1">k</span><span class="s2">): </span><span class="s1">encode_default</span><span class="s2">(</span><span class="s1">v</span><span class="s2">) </span><span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">dft</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()}</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dft</span><span class="s2">, </span><span class="s1">Enum</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">dft</span><span class="s2">.</span><span class="s1">value</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dft</span><span class="s2">, (</span><span class="s1">int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">str</span><span class="s2">)):</span>
        <span class="s0">return </span><span class="s1">dft</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dft</span><span class="s2">, (</span><span class="s1">list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">)):</span>
        <span class="s1">t </span><span class="s2">= </span><span class="s1">dft</span><span class="s2">.</span><span class="s1">__class__</span>
        <span class="s1">seq_args </span><span class="s2">= (</span><span class="s1">encode_default</span><span class="s2">(</span><span class="s1">v</span><span class="s2">) </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">dft</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">t</span><span class="s2">(*</span><span class="s1">seq_args</span><span class="s2">) </span><span class="s0">if </span><span class="s1">is_namedtuple</span><span class="s2">(</span><span class="s1">t</span><span class="s2">) </span><span class="s0">else </span><span class="s1">t</span><span class="s2">(</span><span class="s1">seq_args</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">dft </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s0">return None</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">pydantic_encoder</span><span class="s2">(</span><span class="s1">dft</span><span class="s2">)</span>


<span class="s1">_map_types_constraint</span><span class="s2">: </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">type</span><span class="s2">]] = {</span><span class="s1">int</span><span class="s2">: </span><span class="s1">conint</span><span class="s2">, </span><span class="s1">float</span><span class="s2">: </span><span class="s1">confloat</span><span class="s2">, </span><span class="s1">Decimal</span><span class="s2">: </span><span class="s1">condecimal</span><span class="s2">}</span>


<span class="s0">def </span><span class="s1">get_annotation_from_field_info</span><span class="s2">(</span>
    <span class="s1">annotation</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">field_info</span><span class="s2">: </span><span class="s1">FieldInfo</span><span class="s2">, </span><span class="s1">field_name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">validate_assignment</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span>
<span class="s2">) </span><span class="s1">-&gt; Type</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">]:</span>
    <span class="s4">&quot;&quot;&quot; 
    Get an annotation with validation implemented for numbers and strings based on the field_info. 
    :param annotation: an annotation from a field specification, as ``str``, ``ConstrainedStr`` 
    :param field_info: an instance of FieldInfo, possibly with declarations for validations and JSON Schema 
    :param field_name: name of the field for use in error messages 
    :param validate_assignment: default False, flag for BaseModel Config value of validate_assignment 
    :return: the same ``annotation`` if unmodified or a new annotation with validation in place 
    &quot;&quot;&quot;</span>
    <span class="s1">constraints </span><span class="s2">= </span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">get_constraints</span><span class="s2">()</span>
    <span class="s1">used_constraints</span><span class="s2">: </span><span class="s1">Set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s1">set</span><span class="s2">()</span>
    <span class="s0">if </span><span class="s1">constraints</span><span class="s2">:</span>
        <span class="s1">annotation</span><span class="s2">, </span><span class="s1">used_constraints </span><span class="s2">= </span><span class="s1">get_annotation_with_constraints</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">, </span><span class="s1">field_info</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">validate_assignment</span><span class="s2">:</span>
        <span class="s1">used_constraints</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s3">'allow_mutation'</span><span class="s2">)</span>

    <span class="s1">unused_constraints </span><span class="s2">= </span><span class="s1">constraints </span><span class="s2">- </span><span class="s1">used_constraints</span>
    <span class="s0">if </span><span class="s1">unused_constraints</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s3">f'On field &quot;</span><span class="s0">{</span><span class="s1">field_name</span><span class="s0">}</span><span class="s3">&quot; the following field constraints are set but not enforced: '</span>
            <span class="s3">f'</span><span class="s0">{</span><span class="s3">&quot;, &quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">unused_constraints</span><span class="s2">)</span><span class="s0">}</span><span class="s3">. '</span>
            <span class="s3">f'</span><span class="s0">\n</span><span class="s3">For more details see https://docs.pydantic.dev/usage/schema/#unenforced-field-constraints'</span>
        <span class="s2">)</span>

    <span class="s0">return </span><span class="s1">annotation</span>


<span class="s0">def </span><span class="s1">get_annotation_with_constraints</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">field_info</span><span class="s2">: </span><span class="s1">FieldInfo</span><span class="s2">) </span><span class="s1">-&gt; Tuple</span><span class="s2">[</span><span class="s1">Type</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">], </span><span class="s1">Set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]]:  </span><span class="s5"># noqa: C901</span>
    <span class="s4">&quot;&quot;&quot; 
    Get an annotation with used constraints implemented for numbers and strings based on the field_info. 
 
    :param annotation: an annotation from a field specification, as ``str``, ``ConstrainedStr`` 
    :param field_info: an instance of FieldInfo, possibly with declarations for validations and JSON Schema 
    :return: the same ``annotation`` if unmodified or a new annotation along with the used constraints. 
    &quot;&quot;&quot;</span>
    <span class="s1">used_constraints</span><span class="s2">: </span><span class="s1">Set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s1">set</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">go</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">) </span><span class="s1">-&gt; Type</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">]:</span>
        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">is_literal_type</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">)</span>
            <span class="s0">or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">ForwardRef</span><span class="s2">)</span>
            <span class="s0">or </span><span class="s1">lenient_issubclass</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">, (</span><span class="s1">ConstrainedList</span><span class="s2">, </span><span class="s1">ConstrainedSet</span><span class="s2">, </span><span class="s1">ConstrainedFrozenSet</span><span class="s2">))</span>
        <span class="s2">):</span>
            <span class="s0">return </span><span class="s1">type_</span>
        <span class="s1">origin </span><span class="s2">= </span><span class="s1">get_origin</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">origin </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">args</span><span class="s2">: </span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...] = </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">any</span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">ForwardRef</span><span class="s2">) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">args</span><span class="s2">):</span>
                <span class="s5"># forward refs cause infinite recursion below</span>
                <span class="s0">return </span><span class="s1">type_</span>

            <span class="s0">if </span><span class="s1">origin </span><span class="s0">is </span><span class="s1">Annotated</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">go</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">])</span>
            <span class="s0">if </span><span class="s1">is_union</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">go</span><span class="s2">(</span><span class="s1">a</span><span class="s2">) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">args</span><span class="s2">)]  </span><span class="s5"># type: ignore</span>

            <span class="s0">if </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">List</span><span class="s2">) </span><span class="s0">and </span><span class="s2">(</span>
                <span class="s1">field_info</span><span class="s2">.</span><span class="s1">min_items </span><span class="s0">is not None</span>
                <span class="s0">or </span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">max_items </span><span class="s0">is not None</span>
                <span class="s0">or </span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">unique_items </span><span class="s0">is not None</span>
            <span class="s2">):</span>
                <span class="s1">used_constraints</span><span class="s2">.</span><span class="s1">update</span><span class="s2">({</span><span class="s3">'min_items'</span><span class="s2">, </span><span class="s3">'max_items'</span><span class="s2">, </span><span class="s3">'unique_items'</span><span class="s2">})</span>
                <span class="s0">return </span><span class="s1">conlist</span><span class="s2">(</span>
                    <span class="s1">go</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]),</span>
                    <span class="s1">min_items</span><span class="s2">=</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">min_items</span><span class="s2">,</span>
                    <span class="s1">max_items</span><span class="s2">=</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">max_items</span><span class="s2">,</span>
                    <span class="s1">unique_items</span><span class="s2">=</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">unique_items</span><span class="s2">,</span>
                <span class="s2">)</span>

            <span class="s0">if </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">Set</span><span class="s2">) </span><span class="s0">and </span><span class="s2">(</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">min_items </span><span class="s0">is not None or </span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">max_items </span><span class="s0">is not None</span><span class="s2">):</span>
                <span class="s1">used_constraints</span><span class="s2">.</span><span class="s1">update</span><span class="s2">({</span><span class="s3">'min_items'</span><span class="s2">, </span><span class="s3">'max_items'</span><span class="s2">})</span>
                <span class="s0">return </span><span class="s1">conset</span><span class="s2">(</span><span class="s1">go</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]), </span><span class="s1">min_items</span><span class="s2">=</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">min_items</span><span class="s2">, </span><span class="s1">max_items</span><span class="s2">=</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">max_items</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">FrozenSet</span><span class="s2">) </span><span class="s0">and </span><span class="s2">(</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">min_items </span><span class="s0">is not None or </span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">max_items </span><span class="s0">is not None</span><span class="s2">):</span>
                <span class="s1">used_constraints</span><span class="s2">.</span><span class="s1">update</span><span class="s2">({</span><span class="s3">'min_items'</span><span class="s2">, </span><span class="s3">'max_items'</span><span class="s2">})</span>
                <span class="s0">return </span><span class="s1">confrozenset</span><span class="s2">(</span><span class="s1">go</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]), </span><span class="s1">min_items</span><span class="s2">=</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">min_items</span><span class="s2">, </span><span class="s1">max_items</span><span class="s2">=</span><span class="s1">field_info</span><span class="s2">.</span><span class="s1">max_items</span><span class="s2">)</span>

            <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s2">(</span><span class="s1">Tuple</span><span class="s2">, </span><span class="s1">List</span><span class="s2">, </span><span class="s1">Set</span><span class="s2">, </span><span class="s1">FrozenSet</span><span class="s2">, </span><span class="s1">Sequence</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">t</span><span class="s2">):  </span><span class="s5"># type: ignore</span>
                    <span class="s0">return </span><span class="s1">t</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">go</span><span class="s2">(</span><span class="s1">a</span><span class="s2">) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">args</span><span class="s2">)]  </span><span class="s5"># type: ignore</span>

            <span class="s0">if </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">Dict</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">Dict</span><span class="s2">[</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">go</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s6">1</span><span class="s2">])]  </span><span class="s5"># type: ignore</span>

        <span class="s1">attrs</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, ...]] = </span><span class="s0">None</span>
        <span class="s1">constraint_func</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">type</span><span class="s2">]] = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">type</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">, (</span><span class="s1">SecretStr</span><span class="s2">, </span><span class="s1">SecretBytes</span><span class="s2">)):</span>
                <span class="s1">attrs </span><span class="s2">= (</span><span class="s3">'max_length'</span><span class="s2">, </span><span class="s3">'min_length'</span><span class="s2">)</span>

                <span class="s0">def </span><span class="s1">constraint_func</span><span class="s2">(**</span><span class="s1">kw</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">) </span><span class="s1">-&gt; Type</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">]:  </span><span class="s5"># noqa: F811</span>
                    <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">, (</span><span class="s1">type_</span><span class="s2">,), </span><span class="s1">kw</span><span class="s2">)</span>

            <span class="s0">elif </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">str</span><span class="s2">) </span><span class="s0">and not </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">, (</span><span class="s1">EmailStr</span><span class="s2">, </span><span class="s1">AnyUrl</span><span class="s2">)):</span>
                <span class="s1">attrs </span><span class="s2">= (</span><span class="s3">'max_length'</span><span class="s2">, </span><span class="s3">'min_length'</span><span class="s2">, </span><span class="s3">'regex'</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">StrictStr</span><span class="s2">):</span>

                    <span class="s0">def </span><span class="s1">constraint_func</span><span class="s2">(**</span><span class="s1">kw</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">) </span><span class="s1">-&gt; Type</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">]:</span>
                        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">, (</span><span class="s1">type_</span><span class="s2">,), </span><span class="s1">kw</span><span class="s2">)</span>

                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">constraint_func </span><span class="s2">= </span><span class="s1">constr</span>
            <span class="s0">elif </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">):</span>
                <span class="s1">attrs </span><span class="s2">= (</span><span class="s3">'max_length'</span><span class="s2">, </span><span class="s3">'min_length'</span><span class="s2">, </span><span class="s3">'regex'</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">StrictBytes</span><span class="s2">):</span>

                    <span class="s0">def </span><span class="s1">constraint_func</span><span class="s2">(**</span><span class="s1">kw</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">) </span><span class="s1">-&gt; Type</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">]:</span>
                        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">, (</span><span class="s1">type_</span><span class="s2">,), </span><span class="s1">kw</span><span class="s2">)</span>

                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">constraint_func </span><span class="s2">= </span><span class="s1">conbytes</span>
            <span class="s0">elif </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">numeric_types</span><span class="s2">) </span><span class="s0">and not </span><span class="s1">issubclass</span><span class="s2">(</span>
                <span class="s1">type_</span><span class="s2">,</span>
                <span class="s2">(</span>
                    <span class="s1">ConstrainedInt</span><span class="s2">,</span>
                    <span class="s1">ConstrainedFloat</span><span class="s2">,</span>
                    <span class="s1">ConstrainedDecimal</span><span class="s2">,</span>
                    <span class="s1">ConstrainedList</span><span class="s2">,</span>
                    <span class="s1">ConstrainedSet</span><span class="s2">,</span>
                    <span class="s1">ConstrainedFrozenSet</span><span class="s2">,</span>
                    <span class="s1">bool</span><span class="s2">,</span>
                <span class="s2">),</span>
            <span class="s2">):</span>
                <span class="s5"># Is numeric type</span>
                <span class="s1">attrs </span><span class="s2">= (</span><span class="s3">'gt'</span><span class="s2">, </span><span class="s3">'lt'</span><span class="s2">, </span><span class="s3">'ge'</span><span class="s2">, </span><span class="s3">'le'</span><span class="s2">, </span><span class="s3">'multiple_of'</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">float</span><span class="s2">):</span>
                    <span class="s1">attrs </span><span class="s2">+= (</span><span class="s3">'allow_inf_nan'</span><span class="s2">,)</span>
                <span class="s0">if </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">Decimal</span><span class="s2">):</span>
                    <span class="s1">attrs </span><span class="s2">+= (</span><span class="s3">'max_digits'</span><span class="s2">, </span><span class="s3">'decimal_places'</span><span class="s2">)</span>
                <span class="s1">numeric_type </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">t </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">numeric_types </span><span class="s0">if </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">t</span><span class="s2">))  </span><span class="s5"># pragma: no branch</span>
                <span class="s1">constraint_func </span><span class="s2">= </span><span class="s1">_map_types_constraint</span><span class="s2">[</span><span class="s1">numeric_type</span><span class="s2">]</span>

        <span class="s0">if </span><span class="s1">attrs</span><span class="s2">:</span>
            <span class="s1">used_constraints</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">set</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">))</span>
            <span class="s1">kwargs </span><span class="s2">= {</span>
                <span class="s1">attr_name</span><span class="s2">: </span><span class="s1">attr</span>
                <span class="s0">for </span><span class="s1">attr_name</span><span class="s2">, </span><span class="s1">attr </span><span class="s0">in </span><span class="s2">((</span><span class="s1">attr_name</span><span class="s2">, </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">field_info</span><span class="s2">, </span><span class="s1">attr_name</span><span class="s2">)) </span><span class="s0">for </span><span class="s1">attr_name </span><span class="s0">in </span><span class="s1">attrs</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">attr </span><span class="s0">is not None</span>
            <span class="s2">}</span>
            <span class="s0">if </span><span class="s1">kwargs</span><span class="s2">:</span>
                <span class="s1">constraint_func </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">type</span><span class="s2">], </span><span class="s1">constraint_func</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">constraint_func</span><span class="s2">(**</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">type_</span>

    <span class="s0">return </span><span class="s1">go</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">), </span><span class="s1">used_constraints</span>


<span class="s0">def </span><span class="s1">normalize_name</span><span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Normalizes the given name. This can be applied to either a model *or* enum. 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">re</span><span class="s2">.</span><span class="s1">sub</span><span class="s2">(</span><span class="s3">r'[^a-zA-Z0-9.\-_]'</span><span class="s2">, </span><span class="s3">'_'</span><span class="s2">, </span><span class="s1">name</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">SkipField</span><span class="s2">(</span><span class="s1">Exception</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Utility exception used to exclude fields from schema. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">message</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">message </span><span class="s2">= </span><span class="s1">message</span>
</pre>
</body>
</html>