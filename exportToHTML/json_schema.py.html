<html>
<head>
<title>json_schema.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
json_schema.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;!!! abstract &quot;Usage Documentation&quot; 
    [JSON Schema](../concepts/json_schema.md) 
 
The `json_schema` module contains classes and functions to allow the way [JSON Schema](https://json-schema.org/) 
is generated to be customized. 
 
In general you shouldn't need to use this module directly; instead, you can use 
[`BaseModel.model_json_schema`][pydantic.BaseModel.model_json_schema] and 
[`TypeAdapter.json_schema`][pydantic.TypeAdapter.json_schema]. 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations </span><span class="s2">as </span><span class="s1">_annotations</span>

<span class="s2">import </span><span class="s1">dataclasses</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">Counter</span><span class="s3">, </span><span class="s1">defaultdict</span>
<span class="s2">from </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc </span><span class="s2">import </span><span class="s1">Hashable</span><span class="s3">, </span><span class="s1">Iterable</span><span class="s3">, </span><span class="s1">Sequence</span>
<span class="s2">from </span><span class="s1">copy </span><span class="s2">import </span><span class="s1">deepcopy</span>
<span class="s2">from </span><span class="s1">enum </span><span class="s2">import </span><span class="s1">Enum</span>
<span class="s2">from </span><span class="s1">re </span><span class="s2">import </span><span class="s1">Pattern</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s3">,</span>
    <span class="s1">Annotated</span><span class="s3">,</span>
    <span class="s1">Any</span><span class="s3">,</span>
    <span class="s1">Callable</span><span class="s3">,</span>
    <span class="s1">Literal</span><span class="s3">,</span>
    <span class="s1">NewType</span><span class="s3">,</span>
    <span class="s1">TypeVar</span><span class="s3">,</span>
    <span class="s1">Union</span><span class="s3">,</span>
    <span class="s1">cast</span><span class="s3">,</span>
    <span class="s1">overload</span><span class="s3">,</span>
<span class="s3">)</span>

<span class="s2">import </span><span class="s1">pydantic_core</span>
<span class="s2">from </span><span class="s1">pydantic_core </span><span class="s2">import </span><span class="s1">CoreSchema</span><span class="s3">, </span><span class="s1">PydanticOmit</span><span class="s3">, </span><span class="s1">core_schema</span><span class="s3">, </span><span class="s1">to_jsonable_python</span>
<span class="s2">from </span><span class="s1">pydantic_core</span><span class="s3">.</span><span class="s1">core_schema </span><span class="s2">import </span><span class="s1">ComputedField</span>
<span class="s2">from </span><span class="s1">typing_extensions </span><span class="s2">import </span><span class="s1">TypeAlias</span><span class="s3">, </span><span class="s1">assert_never</span><span class="s3">, </span><span class="s1">deprecated</span><span class="s3">, </span><span class="s1">final</span>
<span class="s2">from </span><span class="s1">typing_inspection</span><span class="s3">.</span><span class="s1">introspection </span><span class="s2">import </span><span class="s1">get_literal_values</span>

<span class="s2">from </span><span class="s1">pydantic</span><span class="s3">.</span><span class="s1">warnings </span><span class="s2">import </span><span class="s1">PydanticDeprecatedSince26</span><span class="s3">, </span><span class="s1">PydanticDeprecatedSince29</span>

<span class="s2">from </span><span class="s3">.</span><span class="s1">_internal </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">_config</span><span class="s3">,</span>
    <span class="s1">_core_metadata</span><span class="s3">,</span>
    <span class="s1">_core_utils</span><span class="s3">,</span>
    <span class="s1">_decorators</span><span class="s3">,</span>
    <span class="s1">_internal_dataclass</span><span class="s3">,</span>
    <span class="s1">_mock_val_ser</span><span class="s3">,</span>
    <span class="s1">_schema_generation_shared</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">annotated_handlers </span><span class="s2">import </span><span class="s1">GetJsonSchemaHandler</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">config </span><span class="s2">import </span><span class="s1">JsonDict</span><span class="s3">, </span><span class="s1">JsonValue</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">errors </span><span class="s2">import </span><span class="s1">PydanticInvalidForJsonSchema</span><span class="s3">, </span><span class="s1">PydanticSchemaGenerationError</span><span class="s3">, </span><span class="s1">PydanticUserError</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">ConfigDict</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_internal</span><span class="s3">.</span><span class="s1">_core_utils </span><span class="s2">import </span><span class="s1">CoreSchemaField</span><span class="s3">, </span><span class="s1">CoreSchemaOrField</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_internal</span><span class="s3">.</span><span class="s1">_dataclasses </span><span class="s2">import </span><span class="s1">PydanticDataclass</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_internal</span><span class="s3">.</span><span class="s1">_schema_generation_shared </span><span class="s2">import </span><span class="s1">GetJsonSchemaFunction</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">main </span><span class="s2">import </span><span class="s1">BaseModel</span>


<span class="s1">CoreSchemaOrFieldType </span><span class="s3">= </span><span class="s1">Literal</span><span class="s3">[</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchemaType</span><span class="s3">, </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchemaFieldType</span><span class="s3">]</span>
<span class="s4">&quot;&quot;&quot; 
A type alias for defined schema types that represents a union of 
`core_schema.CoreSchemaType` and 
`core_schema.CoreSchemaFieldType`. 
&quot;&quot;&quot;</span>

<span class="s1">JsonSchemaValue </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
<span class="s4">&quot;&quot;&quot; 
A type alias for a JSON schema value. This is a dictionary of string keys to arbitrary JSON values. 
&quot;&quot;&quot;</span>

<span class="s1">JsonSchemaMode </span><span class="s3">= </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">'validation'</span><span class="s3">, </span><span class="s4">'serialization'</span><span class="s3">]</span>
<span class="s4">&quot;&quot;&quot; 
A type alias that represents the mode of a JSON schema; either 'validation' or 'serialization'. 
 
For some types, the inputs to validation differ from the outputs of serialization. For example, 
computed fields will only be present when serializing, and should not be provided when 
validating. This flag provides a way to indicate whether you want the JSON schema required 
for validation inputs, or that will be matched by serialization outputs. 
&quot;&quot;&quot;</span>

<span class="s1">_MODE_TITLE_MAPPING</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">JsonSchemaMode</span><span class="s3">, </span><span class="s1">str</span><span class="s3">] = {</span><span class="s4">'validation'</span><span class="s3">: </span><span class="s4">'Input'</span><span class="s3">, </span><span class="s4">'serialization'</span><span class="s3">: </span><span class="s4">'Output'</span><span class="s3">}</span>


<span class="s1">JsonSchemaWarningKind </span><span class="s3">= </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">'skipped-choice'</span><span class="s3">, </span><span class="s4">'non-serializable-default'</span><span class="s3">, </span><span class="s4">'skipped-discriminator'</span><span class="s3">]</span>
<span class="s4">&quot;&quot;&quot; 
A type alias representing the kinds of warnings that can be emitted during JSON schema generation. 
 
See [`GenerateJsonSchema.render_warning_message`][pydantic.json_schema.GenerateJsonSchema.render_warning_message] 
for more details. 
&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">PydanticJsonSchemaWarning</span><span class="s3">(</span><span class="s1">UserWarning</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;This class is used to emit warnings produced during JSON schema generation. 
    See the [`GenerateJsonSchema.emit_warning`][pydantic.json_schema.GenerateJsonSchema.emit_warning] and 
    [`GenerateJsonSchema.render_warning_message`][pydantic.json_schema.GenerateJsonSchema.render_warning_message] 
    methods for more details; these can be overridden to control warning behavior. 
    &quot;&quot;&quot;</span>


<span class="s1">NoDefault </span><span class="s3">= </span><span class="s1">object</span><span class="s3">()</span>
<span class="s4">&quot;&quot;&quot;A sentinel value used to indicate that no default value should be used when generating a JSON Schema 
for a core schema with a default value. 
&quot;&quot;&quot;</span>


<span class="s5"># ##### JSON Schema Generation #####</span>
<span class="s1">DEFAULT_REF_TEMPLATE </span><span class="s3">= </span><span class="s4">'#/$defs/{model}'</span>
<span class="s4">&quot;&quot;&quot;The default format string used to generate reference names.&quot;&quot;&quot;</span>

<span class="s5"># There are three types of references relevant to building JSON schemas:</span>
<span class="s5">#   1. core_schema &quot;ref&quot; values; these are not exposed as part of the JSON schema</span>
<span class="s5">#       * these might look like the fully qualified path of a model, its id, or something similar</span>
<span class="s1">CoreRef </span><span class="s3">= </span><span class="s1">NewType</span><span class="s3">(</span><span class="s4">'CoreRef'</span><span class="s3">, </span><span class="s1">str</span><span class="s3">)</span>
<span class="s5">#   2. keys of the &quot;definitions&quot; object that will eventually go into the JSON schema</span>
<span class="s5">#       * by default, these look like &quot;MyModel&quot;, though may change in the presence of collisions</span>
<span class="s5">#       * eventually, we may want to make it easier to modify the way these names are generated</span>
<span class="s1">DefsRef </span><span class="s3">= </span><span class="s1">NewType</span><span class="s3">(</span><span class="s4">'DefsRef'</span><span class="s3">, </span><span class="s1">str</span><span class="s3">)</span>
<span class="s5">#   3. the values corresponding to the &quot;$ref&quot; key in the schema</span>
<span class="s5">#       * By default, these look like &quot;#/$defs/MyModel&quot;, as in {&quot;$ref&quot;: &quot;#/$defs/MyModel&quot;}</span>
<span class="s1">JsonRef </span><span class="s3">= </span><span class="s1">NewType</span><span class="s3">(</span><span class="s4">'JsonRef'</span><span class="s3">, </span><span class="s1">str</span><span class="s3">)</span>

<span class="s1">CoreModeRef </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">CoreRef</span><span class="s3">, </span><span class="s1">JsonSchemaMode</span><span class="s3">]</span>
<span class="s1">JsonSchemaKeyT </span><span class="s3">= </span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s4">'JsonSchemaKeyT'</span><span class="s3">, </span><span class="s1">bound</span><span class="s3">=</span><span class="s1">Hashable</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">dataclasses</span><span class="s3">.</span><span class="s1">dataclass</span><span class="s3">(**</span><span class="s1">_internal_dataclass</span><span class="s3">.</span><span class="s1">slots_true</span><span class="s3">)</span>
<span class="s2">class </span><span class="s1">_DefinitionsRemapping</span><span class="s3">:</span>
    <span class="s1">defs_remapping</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">DefsRef</span><span class="s3">, </span><span class="s1">DefsRef</span><span class="s3">]</span>
    <span class="s1">json_remapping</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">JsonRef</span><span class="s3">, </span><span class="s1">JsonRef</span><span class="s3">]</span>

    <span class="s3">@</span><span class="s1">staticmethod</span>
    <span class="s2">def </span><span class="s1">from_prioritized_choices</span><span class="s3">(</span>
        <span class="s1">prioritized_choices</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">DefsRef</span><span class="s3">, </span><span class="s1">list</span><span class="s3">[</span><span class="s1">DefsRef</span><span class="s3">]],</span>
        <span class="s1">defs_to_json</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">DefsRef</span><span class="s3">, </span><span class="s1">JsonRef</span><span class="s3">],</span>
        <span class="s1">definitions</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">DefsRef</span><span class="s3">, </span><span class="s1">JsonSchemaValue</span><span class="s3">],</span>
    <span class="s3">) </span><span class="s1">-&gt; _DefinitionsRemapping</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        This function should produce a remapping that replaces complex DefsRef with the simpler ones from the 
        prioritized_choices such that applying the name remapping would result in an equivalent JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s5"># We need to iteratively simplify the definitions until we reach a fixed point.</span>
        <span class="s5"># The reason for this is that outer definitions may reference inner definitions that get simplified</span>
        <span class="s5"># into an equivalent reference, and the outer definitions won't be equivalent until we've simplified</span>
        <span class="s5"># the inner definitions.</span>
        <span class="s1">copied_definitions </span><span class="s3">= </span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">definitions</span><span class="s3">)</span>
        <span class="s1">definitions_schema </span><span class="s3">= {</span><span class="s4">'$defs'</span><span class="s3">: </span><span class="s1">copied_definitions</span><span class="s3">}</span>
        <span class="s2">for </span><span class="s1">_iter </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s6">100</span><span class="s3">):  </span><span class="s5"># prevent an infinite loop in the case of a bug, 100 iterations should be enough</span>
            <span class="s5"># For every possible remapped DefsRef, collect all schemas that that DefsRef might be used for:</span>
            <span class="s1">schemas_for_alternatives</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">DefsRef</span><span class="s3">, </span><span class="s1">list</span><span class="s3">[</span><span class="s1">JsonSchemaValue</span><span class="s3">]] = </span><span class="s1">defaultdict</span><span class="s3">(</span><span class="s1">list</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">defs_ref </span><span class="s2">in </span><span class="s1">copied_definitions</span><span class="s3">:</span>
                <span class="s1">alternatives </span><span class="s3">= </span><span class="s1">prioritized_choices</span><span class="s3">[</span><span class="s1">defs_ref</span><span class="s3">]</span>
                <span class="s2">for </span><span class="s1">alternative </span><span class="s2">in </span><span class="s1">alternatives</span><span class="s3">:</span>
                    <span class="s1">schemas_for_alternatives</span><span class="s3">[</span><span class="s1">alternative</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">copied_definitions</span><span class="s3">[</span><span class="s1">defs_ref</span><span class="s3">])</span>

            <span class="s5"># Deduplicate the schemas for each alternative; the idea is that we only want to remap to a new DefsRef</span>
            <span class="s5"># if it introduces no ambiguity, i.e., there is only one distinct schema for that DefsRef.</span>
            <span class="s2">for </span><span class="s1">defs_ref </span><span class="s2">in </span><span class="s1">schemas_for_alternatives</span><span class="s3">:</span>
                <span class="s1">schemas_for_alternatives</span><span class="s3">[</span><span class="s1">defs_ref</span><span class="s3">] = </span><span class="s1">_deduplicate_schemas</span><span class="s3">(</span><span class="s1">schemas_for_alternatives</span><span class="s3">[</span><span class="s1">defs_ref</span><span class="s3">])</span>

            <span class="s5"># Build the remapping</span>
            <span class="s1">defs_remapping</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">DefsRef</span><span class="s3">, </span><span class="s1">DefsRef</span><span class="s3">] = {}</span>
            <span class="s1">json_remapping</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">JsonRef</span><span class="s3">, </span><span class="s1">JsonRef</span><span class="s3">] = {}</span>
            <span class="s2">for </span><span class="s1">original_defs_ref </span><span class="s2">in </span><span class="s1">definitions</span><span class="s3">:</span>
                <span class="s1">alternatives </span><span class="s3">= </span><span class="s1">prioritized_choices</span><span class="s3">[</span><span class="s1">original_defs_ref</span><span class="s3">]</span>
                <span class="s5"># Pick the first alternative that has only one schema, since that means there is no collision</span>
                <span class="s1">remapped_defs_ref </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">alternatives </span><span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">schemas_for_alternatives</span><span class="s3">[</span><span class="s1">x</span><span class="s3">]) == </span><span class="s6">1</span><span class="s3">)</span>
                <span class="s1">defs_remapping</span><span class="s3">[</span><span class="s1">original_defs_ref</span><span class="s3">] = </span><span class="s1">remapped_defs_ref</span>
                <span class="s1">json_remapping</span><span class="s3">[</span><span class="s1">defs_to_json</span><span class="s3">[</span><span class="s1">original_defs_ref</span><span class="s3">]] = </span><span class="s1">defs_to_json</span><span class="s3">[</span><span class="s1">remapped_defs_ref</span><span class="s3">]</span>
            <span class="s1">remapping </span><span class="s3">= </span><span class="s1">_DefinitionsRemapping</span><span class="s3">(</span><span class="s1">defs_remapping</span><span class="s3">, </span><span class="s1">json_remapping</span><span class="s3">)</span>
            <span class="s1">new_definitions_schema </span><span class="s3">= </span><span class="s1">remapping</span><span class="s3">.</span><span class="s1">remap_json_schema</span><span class="s3">({</span><span class="s4">'$defs'</span><span class="s3">: </span><span class="s1">copied_definitions</span><span class="s3">})</span>
            <span class="s2">if </span><span class="s1">definitions_schema </span><span class="s3">== </span><span class="s1">new_definitions_schema</span><span class="s3">:</span>
                <span class="s5"># We've reached the fixed point</span>
                <span class="s2">return </span><span class="s1">remapping</span>
            <span class="s1">definitions_schema </span><span class="s3">= </span><span class="s1">new_definitions_schema</span>

        <span class="s2">raise </span><span class="s1">PydanticInvalidForJsonSchema</span><span class="s3">(</span><span class="s4">'Failed to simplify the JSON schema definitions'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">remap_defs_ref</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">: </span><span class="s1">DefsRef</span><span class="s3">) </span><span class="s1">-&gt; DefsRef</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defs_remapping</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">remap_json_ref</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">: </span><span class="s1">JsonRef</span><span class="s3">) </span><span class="s1">-&gt; JsonRef</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">json_remapping</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">remap_json_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Recursively update the JSON schema replacing all $refs 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
            <span class="s5"># Note: this may not really be a JsonRef; we rely on having no collisions between JsonRefs and other strings</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">remap_json_ref</span><span class="s3">(</span><span class="s1">JsonRef</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">list</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">remap_json_schema</span><span class="s3">(</span><span class="s1">item</span><span class="s3">) </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">schema</span><span class="s3">]</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s2">if </span><span class="s1">key </span><span class="s3">== </span><span class="s4">'$ref' </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
                    <span class="s1">schema</span><span class="s3">[</span><span class="s4">'$ref'</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">remap_json_ref</span><span class="s3">(</span><span class="s1">JsonRef</span><span class="s3">(</span><span class="s1">value</span><span class="s3">))</span>
                <span class="s2">elif </span><span class="s1">key </span><span class="s3">== </span><span class="s4">'$defs'</span><span class="s3">:</span>
                    <span class="s1">schema</span><span class="s3">[</span><span class="s4">'$defs'</span><span class="s3">] = {</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">remap_defs_ref</span><span class="s3">(</span><span class="s1">DefsRef</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)): </span><span class="s1">self</span><span class="s3">.</span><span class="s1">remap_json_schema</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
                        <span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'$defs'</span><span class="s3">].</span><span class="s1">items</span><span class="s3">()</span>
                    <span class="s3">}</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">schema</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">remap_json_schema</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">schema</span>


<span class="s2">class </span><span class="s1">GenerateJsonSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;!!! abstract &quot;Usage Documentation&quot; 
        [Customizing the JSON Schema Generation Process](../concepts/json_schema.md#customizing-the-json-schema-generation-process) 
 
    A class for generating JSON schemas. 
 
    This class generates JSON schemas based on configured parameters. The default schema dialect 
    is [https://json-schema.org/draft/2020-12/schema](https://json-schema.org/draft/2020-12/schema). 
    The class uses `by_alias` to configure how fields with 
    multiple names are handled and `ref_template` to format reference names. 
 
    Attributes: 
        schema_dialect: The JSON schema dialect used to generate the schema. See 
            [Declaring a Dialect](https://json-schema.org/understanding-json-schema/reference/schema.html#id4) 
            in the JSON Schema documentation for more information about dialects. 
        ignored_warning_kinds: Warnings to ignore when generating the schema. `self.render_warning_message` will 
            do nothing if its argument `kind` is in `ignored_warning_kinds`; 
            this value can be modified on subclasses to easily control which warnings are emitted. 
        by_alias: Whether to use field aliases when generating the schema. 
        ref_template: The format string used when generating reference names. 
        core_to_json_refs: A mapping of core refs to JSON refs. 
        core_to_defs_refs: A mapping of core refs to definition refs. 
        defs_to_core_refs: A mapping of definition refs to core refs. 
        json_to_defs_refs: A mapping of JSON refs to definition refs. 
        definitions: Definitions in the schema. 
 
    Args: 
        by_alias: Whether to use field aliases in the generated schemas. 
        ref_template: The format string to use when generating reference names. 
 
    Raises: 
        JsonSchemaError: If the instance of the class is inadvertently reused after generating a schema. 
    &quot;&quot;&quot;</span>

    <span class="s1">schema_dialect </span><span class="s3">= </span><span class="s4">'https://json-schema.org/draft/2020-12/schema'</span>

    <span class="s5"># `self.render_warning_message` will do nothing if its argument `kind` is in `ignored_warning_kinds`;</span>
    <span class="s5"># this value can be modified on subclasses to easily control which warnings are emitted</span>
    <span class="s1">ignored_warning_kinds</span><span class="s3">: </span><span class="s1">set</span><span class="s3">[</span><span class="s1">JsonSchemaWarningKind</span><span class="s3">] = {</span><span class="s4">'skipped-choice'</span><span class="s3">}</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">by_alias</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">, </span><span class="s1">ref_template</span><span class="s3">: </span><span class="s1">str </span><span class="s3">= </span><span class="s1">DEFAULT_REF_TEMPLATE</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">by_alias </span><span class="s3">= </span><span class="s1">by_alias</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">ref_template </span><span class="s3">= </span><span class="s1">ref_template</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">core_to_json_refs</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">CoreModeRef</span><span class="s3">, </span><span class="s1">JsonRef</span><span class="s3">] = {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">core_to_defs_refs</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">CoreModeRef</span><span class="s3">, </span><span class="s1">DefsRef</span><span class="s3">] = {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">defs_to_core_refs</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">DefsRef</span><span class="s3">, </span><span class="s1">CoreModeRef</span><span class="s3">] = {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">json_to_defs_refs</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">JsonRef</span><span class="s3">, </span><span class="s1">DefsRef</span><span class="s3">] = {}</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">definitions</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">DefsRef</span><span class="s3">, </span><span class="s1">JsonSchemaValue</span><span class="s3">] = {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper_stack </span><span class="s3">= </span><span class="s1">_config</span><span class="s3">.</span><span class="s1">ConfigWrapperStack</span><span class="s3">(</span><span class="s1">_config</span><span class="s3">.</span><span class="s1">ConfigWrapper</span><span class="s3">({}))</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_mode</span><span class="s3">: </span><span class="s1">JsonSchemaMode </span><span class="s3">= </span><span class="s4">'validation'</span>

        <span class="s5"># The following includes a mapping of a fully-unique defs ref choice to a list of preferred</span>
        <span class="s5"># alternatives, which are generally simpler, such as only including the class name.</span>
        <span class="s5"># At the end of schema generation, we use these to produce a JSON schema with more human-readable</span>
        <span class="s5"># definitions, which would also work better in a generated OpenAPI client, etc.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_prioritized_defsref_choices</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">DefsRef</span><span class="s3">, </span><span class="s1">list</span><span class="s3">[</span><span class="s1">DefsRef</span><span class="s3">]] = {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_collision_counter</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">] = </span><span class="s1">defaultdict</span><span class="s3">(</span><span class="s1">int</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_collision_index</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">] = {}</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_schema_type_to_method </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">build_schema_type_to_method</span><span class="s3">()</span>

        <span class="s5"># When we encounter definitions we need to try to build them immediately</span>
        <span class="s5"># so that they are available schemas that reference them</span>
        <span class="s5"># But it's possible that CoreSchema was never going to be used</span>
        <span class="s5"># (e.g. because the CoreSchema that references short circuits is JSON schema generation without needing</span>
        <span class="s5">#  the reference) so instead of failing altogether if we can't build a definition we</span>
        <span class="s5"># store the error raised and re-throw it if we end up needing that def</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_core_defs_invalid_for_json_schema</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">DefsRef</span><span class="s3">, </span><span class="s1">PydanticInvalidForJsonSchema</span><span class="s3">] = {}</span>

        <span class="s5"># This changes to True after generating a schema, to prevent issues caused by accidental reuse</span>
        <span class="s5"># of a single instance of a schema generator</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_used </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">_config</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; _config</span><span class="s3">.</span><span class="s1">ConfigWrapper</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper_stack</span><span class="s3">.</span><span class="s1">tail</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">mode</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaMode</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config</span><span class="s3">.</span><span class="s1">json_schema_mode_override </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config</span><span class="s3">.</span><span class="s1">json_schema_mode_override</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mode</span>

    <span class="s2">def </span><span class="s1">build_schema_type_to_method</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; dict</span><span class="s3">[</span><span class="s1">CoreSchemaOrFieldType</span><span class="s3">, </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">CoreSchemaOrField</span><span class="s3">], </span><span class="s1">JsonSchemaValue</span><span class="s3">]]:</span>
        <span class="s0">&quot;&quot;&quot;Builds a dictionary mapping fields to methods for generating JSON schemas. 
 
        Returns: 
            A dictionary containing the mapping of `CoreSchemaOrFieldType` to a handler method. 
 
        Raises: 
            TypeError: If no method has been defined for generating a JSON schema for a given pydantic core schema type. 
        &quot;&quot;&quot;</span>
        <span class="s1">mapping</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">CoreSchemaOrFieldType</span><span class="s3">, </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">CoreSchemaOrField</span><span class="s3">], </span><span class="s1">JsonSchemaValue</span><span class="s3">]] = {}</span>
        <span class="s1">core_schema_types</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">CoreSchemaOrFieldType</span><span class="s3">] = </span><span class="s1">list</span><span class="s3">(</span><span class="s1">get_literal_values</span><span class="s3">(</span><span class="s1">CoreSchemaOrFieldType</span><span class="s3">))</span>
        <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">core_schema_types</span><span class="s3">:</span>
            <span class="s1">method_name </span><span class="s3">= </span><span class="s4">f'</span><span class="s2">{</span><span class="s1">key</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">&quot;-&quot;</span><span class="s3">, </span><span class="s4">&quot;_&quot;</span><span class="s3">)</span><span class="s2">}</span><span class="s4">_schema'</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">mapping</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">method_name</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">AttributeError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:  </span><span class="s5"># pragma: no cover</span>
                <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">getenv</span><span class="s3">(</span><span class="s4">'PYDANTIC_PRIVATE_ALLOW_UNHANDLED_SCHEMA_TYPES'</span><span class="s3">):</span>
                    <span class="s2">continue</span>
                <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
                    <span class="s4">f'No method for generating JsonSchema for core_schema.type=</span><span class="s2">{</span><span class="s1">key</span><span class="s2">!r} </span><span class="s4">'</span>
                    <span class="s4">f'(expected: </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">.</span><span class="s2">{</span><span class="s1">method_name</span><span class="s2">}</span><span class="s4">)'</span>
                <span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>
        <span class="s2">return </span><span class="s1">mapping</span>

    <span class="s2">def </span><span class="s1">generate_definitions</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">inputs</span><span class="s3">: </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">JsonSchemaKeyT</span><span class="s3">, </span><span class="s1">JsonSchemaMode</span><span class="s3">, </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">]]</span>
    <span class="s3">) </span><span class="s1">-&gt; tuple</span><span class="s3">[</span><span class="s1">dict</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">JsonSchemaKeyT</span><span class="s3">, </span><span class="s1">JsonSchemaMode</span><span class="s3">], </span><span class="s1">JsonSchemaValue</span><span class="s3">], </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">DefsRef</span><span class="s3">, </span><span class="s1">JsonSchemaValue</span><span class="s3">]]:</span>
        <span class="s0">&quot;&quot;&quot;Generates JSON schema definitions from a list of core schemas, pairing the generated definitions with a 
        mapping that links the input keys to the definition references. 
 
        Args: 
            inputs: A sequence of tuples, where: 
 
                - The first element is a JSON schema key type. 
                - The second element is the JSON mode: either 'validation' or 'serialization'. 
                - The third element is a core schema. 
 
        Returns: 
            A tuple where: 
 
                - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and 
                    whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have 
                    JsonRef references to definitions that are defined in the second returned element.) 
                - The second element is a dictionary whose keys are definition references for the JSON schemas 
                    from the first returned element, and whose values are the actual JSON schema definitions. 
 
        Raises: 
            PydanticUserError: Raised if the JSON schema generator has already been used to generate a JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_used</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">PydanticUserError</span><span class="s3">(</span>
                <span class="s4">'This JSON schema generator has already been used to generate a JSON schema. '</span>
                <span class="s4">f'You must create a new instance of </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">} </span><span class="s4">to generate a new JSON schema.'</span><span class="s3">,</span>
                <span class="s1">code</span><span class="s3">=</span><span class="s4">'json-schema-already-used'</span><span class="s3">,</span>
            <span class="s3">)</span>

        <span class="s2">for </span><span class="s1">_</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">schema </span><span class="s2">in </span><span class="s1">inputs</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_mode </span><span class="s3">= </span><span class="s1">mode</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>

        <span class="s1">definitions_remapping </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_build_definitions_remapping</span><span class="s3">()</span>

        <span class="s1">json_schemas_map</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">JsonSchemaKeyT</span><span class="s3">, </span><span class="s1">JsonSchemaMode</span><span class="s3">], </span><span class="s1">DefsRef</span><span class="s3">] = {}</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">schema </span><span class="s2">in </span><span class="s1">inputs</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_mode </span><span class="s3">= </span><span class="s1">mode</span>
            <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>
            <span class="s1">json_schemas_map</span><span class="s3">[(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">)] = </span><span class="s1">definitions_remapping</span><span class="s3">.</span><span class="s1">remap_json_schema</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">)</span>

        <span class="s1">json_schema </span><span class="s3">= {</span><span class="s4">'$defs'</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">definitions</span><span class="s3">}</span>
        <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">definitions_remapping</span><span class="s3">.</span><span class="s1">remap_json_schema</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_used </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">json_schemas_map</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'$defs'</span><span class="s3">])  </span><span class="s5"># type: ignore</span>

    <span class="s2">def </span><span class="s1">generate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">: </span><span class="s1">JsonSchemaMode </span><span class="s3">= </span><span class="s4">'validation'</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema for a specified schema in a specified mode. 
 
        Args: 
            schema: A Pydantic model. 
            mode: The mode in which to generate the schema. Defaults to 'validation'. 
 
        Returns: 
            A JSON schema representing the specified schema. 
 
        Raises: 
            PydanticUserError: If the JSON schema generator has already been used to generate a JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_mode </span><span class="s3">= </span><span class="s1">mode</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_used</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">PydanticUserError</span><span class="s3">(</span>
                <span class="s4">'This JSON schema generator has already been used to generate a JSON schema. '</span>
                <span class="s4">f'You must create a new instance of </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">} </span><span class="s4">to generate a new JSON schema.'</span><span class="s3">,</span>
                <span class="s1">code</span><span class="s3">=</span><span class="s4">'json-schema-already-used'</span><span class="s3">,</span>
            <span class="s3">)</span>

        <span class="s1">json_schema</span><span class="s3">: </span><span class="s1">JsonSchemaValue </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>
        <span class="s1">json_ref_counts </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_json_ref_counts</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">)</span>

        <span class="s1">ref </span><span class="s3">= </span><span class="s1">cast</span><span class="s3">(</span><span class="s1">JsonRef</span><span class="s3">, </span><span class="s1">json_schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'$ref'</span><span class="s3">))</span>
        <span class="s2">while </span><span class="s1">ref </span><span class="s2">is not None</span><span class="s3">:  </span><span class="s5"># may need to unpack multiple levels</span>
            <span class="s1">ref_json_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_schema_from_definitions</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">json_ref_counts</span><span class="s3">[</span><span class="s1">ref</span><span class="s3">] == </span><span class="s6">1 </span><span class="s2">and </span><span class="s1">ref_json_schema </span><span class="s2">is not None and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">) == </span><span class="s6">1</span><span class="s3">:</span>
                <span class="s5"># &quot;Unpack&quot; the ref since this is the only reference and there are no sibling keys</span>
                <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">ref_json_schema</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()  </span><span class="s5"># copy to prevent recursive dict reference</span>
                <span class="s1">json_ref_counts</span><span class="s3">[</span><span class="s1">ref</span><span class="s3">] -= </span><span class="s6">1</span>
                <span class="s1">ref </span><span class="s3">= </span><span class="s1">cast</span><span class="s3">(</span><span class="s1">JsonRef</span><span class="s3">, </span><span class="s1">json_schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'$ref'</span><span class="s3">))</span>
            <span class="s1">ref </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_garbage_collect_definitions</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">)</span>
        <span class="s1">definitions_remapping </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_build_definitions_remapping</span><span class="s3">()</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">definitions</span><span class="s3">:</span>
            <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'$defs'</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">definitions</span>

        <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">definitions_remapping</span><span class="s3">.</span><span class="s1">remap_json_schema</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">)</span>

        <span class="s5"># For now, we will not set the $schema key. However, if desired, this can be easily added by overriding</span>
        <span class="s5"># this method and adding the following line after a call to super().generate(schema):</span>
        <span class="s5"># json_schema['$schema'] = self.schema_dialect</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_used </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchemaOrField</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:  </span><span class="s5"># noqa: C901</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema for a given core schema. 
 
        Args: 
            schema: The given core schema. 
 
        Returns: 
            The generated JSON schema. 
 
        TODO: the nested function definitions here seem like bad practice, I'd like to unpack these 
        in a future PR. It'd be great if we could shorten the call stack a bit for JSON schema generation, 
        and I think there's potential for that here. 
        &quot;&quot;&quot;</span>
        <span class="s5"># If a schema with the same CoreRef has been handled, just return a reference to it</span>
        <span class="s5"># Note that this assumes that it will _never_ be the case that the same CoreRef is used</span>
        <span class="s5"># on types that should have different JSON schemas</span>
        <span class="s2">if </span><span class="s4">'ref' </span><span class="s2">in </span><span class="s1">schema</span><span class="s3">:</span>
            <span class="s1">core_ref </span><span class="s3">= </span><span class="s1">CoreRef</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'ref'</span><span class="s3">])  </span><span class="s5"># type: ignore[typeddict-item]</span>
            <span class="s1">core_mode_ref </span><span class="s3">= (</span><span class="s1">core_ref</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mode</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">core_mode_ref </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">core_to_defs_refs </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">core_to_defs_refs</span><span class="s3">[</span><span class="s1">core_mode_ref</span><span class="s3">] </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">definitions</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s3">{</span><span class="s4">'$ref'</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">core_to_json_refs</span><span class="s3">[</span><span class="s1">core_mode_ref</span><span class="s3">]}</span>

        <span class="s2">def </span><span class="s1">populate_defs</span><span class="s3">(</span><span class="s1">core_schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">, </span><span class="s1">json_schema</span><span class="s3">: </span><span class="s1">JsonSchemaValue</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s4">'ref' </span><span class="s2">in </span><span class="s1">core_schema</span><span class="s3">:</span>
                <span class="s1">core_ref </span><span class="s3">= </span><span class="s1">CoreRef</span><span class="s3">(</span><span class="s1">core_schema</span><span class="s3">[</span><span class="s4">'ref'</span><span class="s3">])  </span><span class="s5"># type: ignore[typeddict-item]</span>
                <span class="s1">defs_ref</span><span class="s3">, </span><span class="s1">ref_json_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_cache_defs_ref_schema</span><span class="s3">(</span><span class="s1">core_ref</span><span class="s3">)</span>
                <span class="s1">json_ref </span><span class="s3">= </span><span class="s1">JsonRef</span><span class="s3">(</span><span class="s1">ref_json_schema</span><span class="s3">[</span><span class="s4">'$ref'</span><span class="s3">])</span>
                <span class="s5"># Replace the schema if it's not a reference to itself</span>
                <span class="s5"># What we want to avoid is having the def be just a ref to itself</span>
                <span class="s5"># which is what would happen if we blindly assigned any</span>
                <span class="s2">if </span><span class="s1">json_schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'$ref'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) != </span><span class="s1">json_ref</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">definitions</span><span class="s3">[</span><span class="s1">defs_ref</span><span class="s3">] = </span><span class="s1">json_schema</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">_core_defs_invalid_for_json_schema</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">defs_ref</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
                <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">ref_json_schema</span>
            <span class="s2">return </span><span class="s1">json_schema</span>

        <span class="s2">def </span><span class="s1">handler_func</span><span class="s3">(</span><span class="s1">schema_or_field</span><span class="s3">: </span><span class="s1">CoreSchemaOrField</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
            <span class="s0">&quot;&quot;&quot;Generate a JSON schema based on the input schema. 
 
            Args: 
                schema_or_field: The core schema to generate a JSON schema from. 
 
            Returns: 
                The generated JSON schema. 
 
            Raises: 
                TypeError: If an unexpected schema type is encountered. 
            &quot;&quot;&quot;</span>
            <span class="s5"># Generate the core-schema-type-specific bits of the schema generation:</span>
            <span class="s1">json_schema</span><span class="s3">: </span><span class="s1">JsonSchemaValue </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'serialization' </span><span class="s2">and </span><span class="s4">'serialization' </span><span class="s2">in </span><span class="s1">schema_or_field</span><span class="s3">:</span>
                <span class="s5"># In this case, we skip the JSON Schema generation of the schema</span>
                <span class="s5"># and use the `'serialization'` schema instead (canonical example:</span>
                <span class="s5"># `Annotated[int, PlainSerializer(str)]`).</span>
                <span class="s1">ser_schema </span><span class="s3">= </span><span class="s1">schema_or_field</span><span class="s3">[</span><span class="s4">'serialization'</span><span class="s3">]  </span><span class="s5"># type: ignore</span>
                <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ser_schema</span><span class="s3">(</span><span class="s1">ser_schema</span><span class="s3">)</span>

                <span class="s5"># It might be that the 'serialization'` is skipped depending on `when_used`.</span>
                <span class="s5"># This is only relevant for `nullable` schemas though, so we special case here.</span>
                <span class="s2">if </span><span class="s3">(</span>
                    <span class="s1">json_schema </span><span class="s2">is not None</span>
                    <span class="s2">and </span><span class="s1">ser_schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'when_used'</span><span class="s3">) </span><span class="s2">in </span><span class="s3">(</span><span class="s4">'unless-none'</span><span class="s3">, </span><span class="s4">'json-unless-none'</span><span class="s3">)</span>
                    <span class="s2">and </span><span class="s1">schema_or_field</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">] == </span><span class="s4">'nullable'</span>
                <span class="s3">):</span>
                    <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_flattened_anyof</span><span class="s3">([{</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'null'</span><span class="s3">}, </span><span class="s1">json_schema</span><span class="s3">])</span>
            <span class="s2">if </span><span class="s1">json_schema </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">_core_utils</span><span class="s3">.</span><span class="s1">is_core_schema</span><span class="s3">(</span><span class="s1">schema_or_field</span><span class="s3">) </span><span class="s2">or </span><span class="s1">_core_utils</span><span class="s3">.</span><span class="s1">is_core_schema_field</span><span class="s3">(</span><span class="s1">schema_or_field</span><span class="s3">):</span>
                    <span class="s1">generate_for_schema_type </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_schema_type_to_method</span><span class="s3">[</span><span class="s1">schema_or_field</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">]]</span>
                    <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">generate_for_schema_type</span><span class="s3">(</span><span class="s1">schema_or_field</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">f'Unexpected schema type: schema=</span><span class="s2">{</span><span class="s1">schema_or_field</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>

            <span class="s2">return </span><span class="s1">json_schema</span>

        <span class="s1">current_handler </span><span class="s3">= </span><span class="s1">_schema_generation_shared</span><span class="s3">.</span><span class="s1">GenerateJsonSchemaHandler</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">handler_func</span><span class="s3">)</span>

        <span class="s1">metadata </span><span class="s3">= </span><span class="s1">cast</span><span class="s3">(</span><span class="s1">_core_metadata</span><span class="s3">.</span><span class="s1">CoreMetadata</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'metadata'</span><span class="s3">, {}))</span>

        <span class="s5"># TODO: I dislike that we have to wrap these basic dict updates in callables, is there any way around this?</span>

        <span class="s2">if </span><span class="s1">js_updates </span><span class="s3">:= </span><span class="s1">metadata</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'pydantic_js_updates'</span><span class="s3">):</span>

            <span class="s2">def </span><span class="s1">js_updates_handler_func</span><span class="s3">(</span>
                <span class="s1">schema_or_field</span><span class="s3">: </span><span class="s1">CoreSchemaOrField</span><span class="s3">,</span>
                <span class="s1">current_handler</span><span class="s3">: </span><span class="s1">GetJsonSchemaHandler </span><span class="s3">= </span><span class="s1">current_handler</span><span class="s3">,</span>
            <span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
                <span class="s1">json_schema </span><span class="s3">= {**</span><span class="s1">current_handler</span><span class="s3">(</span><span class="s1">schema_or_field</span><span class="s3">), **</span><span class="s1">js_updates</span><span class="s3">}</span>
                <span class="s2">return </span><span class="s1">json_schema</span>

            <span class="s1">current_handler </span><span class="s3">= </span><span class="s1">_schema_generation_shared</span><span class="s3">.</span><span class="s1">GenerateJsonSchemaHandler</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">js_updates_handler_func</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">js_extra </span><span class="s3">:= </span><span class="s1">metadata</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'pydantic_js_extra'</span><span class="s3">):</span>

            <span class="s2">def </span><span class="s1">js_extra_handler_func</span><span class="s3">(</span>
                <span class="s1">schema_or_field</span><span class="s3">: </span><span class="s1">CoreSchemaOrField</span><span class="s3">,</span>
                <span class="s1">current_handler</span><span class="s3">: </span><span class="s1">GetJsonSchemaHandler </span><span class="s3">= </span><span class="s1">current_handler</span><span class="s3">,</span>
            <span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
                <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">current_handler</span><span class="s3">(</span><span class="s1">schema_or_field</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">js_extra</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">):</span>
                    <span class="s1">json_schema</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">to_jsonable_python</span><span class="s3">(</span><span class="s1">js_extra</span><span class="s3">))</span>
                <span class="s2">elif </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">js_extra</span><span class="s3">):</span>
                    <span class="s5"># similar to typing issue in _update_class_schema when we're working with callable js extra</span>
                    <span class="s1">js_extra</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">)  </span><span class="s5"># type: ignore</span>
                <span class="s2">return </span><span class="s1">json_schema</span>

            <span class="s1">current_handler </span><span class="s3">= </span><span class="s1">_schema_generation_shared</span><span class="s3">.</span><span class="s1">GenerateJsonSchemaHandler</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">js_extra_handler_func</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">js_modify_function </span><span class="s2">in </span><span class="s1">metadata</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'pydantic_js_functions'</span><span class="s3">, ()):</span>

            <span class="s2">def </span><span class="s1">new_handler_func</span><span class="s3">(</span>
                <span class="s1">schema_or_field</span><span class="s3">: </span><span class="s1">CoreSchemaOrField</span><span class="s3">,</span>
                <span class="s1">current_handler</span><span class="s3">: </span><span class="s1">GetJsonSchemaHandler </span><span class="s3">= </span><span class="s1">current_handler</span><span class="s3">,</span>
                <span class="s1">js_modify_function</span><span class="s3">: </span><span class="s1">GetJsonSchemaFunction </span><span class="s3">= </span><span class="s1">js_modify_function</span><span class="s3">,</span>
            <span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
                <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">js_modify_function</span><span class="s3">(</span><span class="s1">schema_or_field</span><span class="s3">, </span><span class="s1">current_handler</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">_core_utils</span><span class="s3">.</span><span class="s1">is_core_schema</span><span class="s3">(</span><span class="s1">schema_or_field</span><span class="s3">):</span>
                    <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">populate_defs</span><span class="s3">(</span><span class="s1">schema_or_field</span><span class="s3">, </span><span class="s1">json_schema</span><span class="s3">)</span>
                <span class="s1">original_schema </span><span class="s3">= </span><span class="s1">current_handler</span><span class="s3">.</span><span class="s1">resolve_ref_schema</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">)</span>
                <span class="s1">ref </span><span class="s3">= </span><span class="s1">json_schema</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s4">'$ref'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">ref </span><span class="s2">and </span><span class="s1">json_schema</span><span class="s3">:</span>
                    <span class="s1">original_schema</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">original_schema</span>

            <span class="s1">current_handler </span><span class="s3">= </span><span class="s1">_schema_generation_shared</span><span class="s3">.</span><span class="s1">GenerateJsonSchemaHandler</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">new_handler_func</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">js_modify_function </span><span class="s2">in </span><span class="s1">metadata</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'pydantic_js_annotation_functions'</span><span class="s3">, ()):</span>

            <span class="s2">def </span><span class="s1">new_handler_func</span><span class="s3">(</span>
                <span class="s1">schema_or_field</span><span class="s3">: </span><span class="s1">CoreSchemaOrField</span><span class="s3">,</span>
                <span class="s1">current_handler</span><span class="s3">: </span><span class="s1">GetJsonSchemaHandler </span><span class="s3">= </span><span class="s1">current_handler</span><span class="s3">,</span>
                <span class="s1">js_modify_function</span><span class="s3">: </span><span class="s1">GetJsonSchemaFunction </span><span class="s3">= </span><span class="s1">js_modify_function</span><span class="s3">,</span>
            <span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">js_modify_function</span><span class="s3">(</span><span class="s1">schema_or_field</span><span class="s3">, </span><span class="s1">current_handler</span><span class="s3">)</span>

            <span class="s1">current_handler </span><span class="s3">= </span><span class="s1">_schema_generation_shared</span><span class="s3">.</span><span class="s1">GenerateJsonSchemaHandler</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">new_handler_func</span><span class="s3">)</span>

        <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">current_handler</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">_core_utils</span><span class="s3">.</span><span class="s1">is_core_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">):</span>
            <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">populate_defs</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">json_schema</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">sort</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">: </span><span class="s1">JsonSchemaValue</span><span class="s3">, </span><span class="s1">parent_key</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Override this method to customize the sorting of the JSON schema (e.g., don't sort at all, sort all keys unconditionally, etc.) 
 
        By default, alphabetically sort the keys in the JSON schema, skipping the 'properties' and 'default' keys to preserve field definition order. 
        This sort is recursive, so it will sort all nested dictionaries as well. 
        &quot;&quot;&quot;</span>
        <span class="s1">sorted_dict</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">JsonSchemaValue</span><span class="s3">] = {}</span>
        <span class="s1">keys </span><span class="s3">= </span><span class="s1">value</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">parent_key </span><span class="s2">not in </span><span class="s3">(</span><span class="s4">'properties'</span><span class="s3">, </span><span class="s4">'default'</span><span class="s3">):</span>
            <span class="s1">keys </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">keys</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">keys</span><span class="s3">:</span>
            <span class="s1">sorted_dict</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_sort_recursive</span><span class="s3">(</span><span class="s1">value</span><span class="s3">[</span><span class="s1">key</span><span class="s3">], </span><span class="s1">parent_key</span><span class="s3">=</span><span class="s1">key</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">sorted_dict</span>

    <span class="s2">def </span><span class="s1">_sort_recursive</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">parent_key</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Recursively sort a JSON schema value.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">):</span>
            <span class="s1">sorted_dict</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">JsonSchemaValue</span><span class="s3">] = {}</span>
            <span class="s1">keys </span><span class="s3">= </span><span class="s1">value</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">parent_key </span><span class="s2">not in </span><span class="s3">(</span><span class="s4">'properties'</span><span class="s3">, </span><span class="s4">'default'</span><span class="s3">):</span>
                <span class="s1">keys </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">keys</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">keys</span><span class="s3">:</span>
                <span class="s1">sorted_dict</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_sort_recursive</span><span class="s3">(</span><span class="s1">value</span><span class="s3">[</span><span class="s1">key</span><span class="s3">], </span><span class="s1">parent_key</span><span class="s3">=</span><span class="s1">key</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">sorted_dict</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">list</span><span class="s3">):</span>
            <span class="s1">sorted_list</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">JsonSchemaValue</span><span class="s3">] = []</span>
            <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">value</span><span class="s3">:</span>
                <span class="s1">sorted_list</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_sort_recursive</span><span class="s3">(</span><span class="s1">item</span><span class="s3">, </span><span class="s1">parent_key</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s1">sorted_list</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">value</span>

    <span class="s5"># ### Schema generation methods</span>

    <span class="s2">def </span><span class="s1">invalid_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">InvalidSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Placeholder - should never be called.&quot;&quot;&quot;</span>

        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'Cannot generate schema for invalid_schema. This is a bug! Please report it.'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">any_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">AnySchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches any value. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">{}</span>

    <span class="s2">def </span><span class="s1">none_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">NoneSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches `None`. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">{</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'null'</span><span class="s3">}</span>

    <span class="s2">def </span><span class="s1">bool_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">BoolSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a bool value. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">{</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'boolean'</span><span class="s3">}</span>

    <span class="s2">def </span><span class="s1">int_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">IntSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches an int value. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">json_schema</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] = {</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'integer'</span><span class="s3">}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">update_with_validations</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ValidationsMapping</span><span class="s3">.</span><span class="s1">numeric</span><span class="s3">)</span>
        <span class="s1">json_schema </span><span class="s3">= {</span><span class="s1">k</span><span class="s3">: </span><span class="s1">v </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">json_schema</span><span class="s3">.</span><span class="s1">items</span><span class="s3">() </span><span class="s2">if </span><span class="s1">v </span><span class="s2">not in </span><span class="s3">{</span><span class="s1">math</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">, -</span><span class="s1">math</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">}}</span>
        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">float_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">FloatSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a float value. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">json_schema</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] = {</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'number'</span><span class="s3">}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">update_with_validations</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ValidationsMapping</span><span class="s3">.</span><span class="s1">numeric</span><span class="s3">)</span>
        <span class="s1">json_schema </span><span class="s3">= {</span><span class="s1">k</span><span class="s3">: </span><span class="s1">v </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">json_schema</span><span class="s3">.</span><span class="s1">items</span><span class="s3">() </span><span class="s2">if </span><span class="s1">v </span><span class="s2">not in </span><span class="s3">{</span><span class="s1">math</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">, -</span><span class="s1">math</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">}}</span>
        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">decimal_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">DecimalSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a decimal value. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">str_schema</span><span class="s3">(</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">str_schema</span><span class="s3">())</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'validation'</span><span class="s3">:</span>
            <span class="s1">multiple_of </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'multiple_of'</span><span class="s3">)</span>
            <span class="s1">le </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'le'</span><span class="s3">)</span>
            <span class="s1">ge </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'ge'</span><span class="s3">)</span>
            <span class="s1">lt </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'lt'</span><span class="s3">)</span>
            <span class="s1">gt </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'gt'</span><span class="s3">)</span>
            <span class="s1">json_schema </span><span class="s3">= {</span>
                <span class="s4">'anyOf'</span><span class="s3">: [</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">float_schema</span><span class="s3">(</span>
                        <span class="s1">core_schema</span><span class="s3">.</span><span class="s1">float_schema</span><span class="s3">(</span>
                            <span class="s1">allow_inf_nan</span><span class="s3">=</span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'allow_inf_nan'</span><span class="s3">),</span>
                            <span class="s1">multiple_of</span><span class="s3">=</span><span class="s2">None if </span><span class="s1">multiple_of </span><span class="s2">is None else </span><span class="s1">float</span><span class="s3">(</span><span class="s1">multiple_of</span><span class="s3">),</span>
                            <span class="s1">le</span><span class="s3">=</span><span class="s2">None if </span><span class="s1">le </span><span class="s2">is None else </span><span class="s1">float</span><span class="s3">(</span><span class="s1">le</span><span class="s3">),</span>
                            <span class="s1">ge</span><span class="s3">=</span><span class="s2">None if </span><span class="s1">ge </span><span class="s2">is None else </span><span class="s1">float</span><span class="s3">(</span><span class="s1">ge</span><span class="s3">),</span>
                            <span class="s1">lt</span><span class="s3">=</span><span class="s2">None if </span><span class="s1">lt </span><span class="s2">is None else </span><span class="s1">float</span><span class="s3">(</span><span class="s1">lt</span><span class="s3">),</span>
                            <span class="s1">gt</span><span class="s3">=</span><span class="s2">None if </span><span class="s1">gt </span><span class="s2">is None else </span><span class="s1">float</span><span class="s3">(</span><span class="s1">gt</span><span class="s3">),</span>
                        <span class="s3">)</span>
                    <span class="s3">),</span>
                    <span class="s1">json_schema</span><span class="s3">,</span>
                <span class="s3">],</span>
            <span class="s3">}</span>
        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">str_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">StringSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a string value. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">json_schema </span><span class="s3">= {</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'string'</span><span class="s3">}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">update_with_validations</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ValidationsMapping</span><span class="s3">.</span><span class="s1">string</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'pattern'</span><span class="s3">), </span><span class="s1">Pattern</span><span class="s3">):</span>
            <span class="s5"># TODO: should we add regex flags to the pattern?</span>
            <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'pattern'</span><span class="s3">] = </span><span class="s1">json_schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'pattern'</span><span class="s3">).</span><span class="s1">pattern  </span><span class="s5"># type: ignore</span>
        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">bytes_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">BytesSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a bytes value. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">json_schema </span><span class="s3">= {</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'string'</span><span class="s3">, </span><span class="s4">'format'</span><span class="s3">: </span><span class="s4">'base64url' </span><span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config</span><span class="s3">.</span><span class="s1">ser_json_bytes </span><span class="s3">== </span><span class="s4">'base64' </span><span class="s2">else </span><span class="s4">'binary'</span><span class="s3">}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">update_with_validations</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ValidationsMapping</span><span class="s3">.</span><span class="s1">bytes</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">date_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">DateSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a date value. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">{</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'string'</span><span class="s3">, </span><span class="s4">'format'</span><span class="s3">: </span><span class="s4">'date'</span><span class="s3">}</span>

    <span class="s2">def </span><span class="s1">time_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">TimeSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a time value. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">{</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'string'</span><span class="s3">, </span><span class="s4">'format'</span><span class="s3">: </span><span class="s4">'time'</span><span class="s3">}</span>

    <span class="s2">def </span><span class="s1">datetime_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">DatetimeSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a datetime value. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">{</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'string'</span><span class="s3">, </span><span class="s4">'format'</span><span class="s3">: </span><span class="s4">'date-time'</span><span class="s3">}</span>

    <span class="s2">def </span><span class="s1">timedelta_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">TimedeltaSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a timedelta value. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config</span><span class="s3">.</span><span class="s1">ser_json_timedelta </span><span class="s3">== </span><span class="s4">'float'</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s3">{</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'number'</span><span class="s3">}</span>
        <span class="s2">return </span><span class="s3">{</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'string'</span><span class="s3">, </span><span class="s4">'format'</span><span class="s3">: </span><span class="s4">'duration'</span><span class="s3">}</span>

    <span class="s2">def </span><span class="s1">literal_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">LiteralSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a literal value. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">expected </span><span class="s3">= [</span><span class="s1">to_jsonable_python</span><span class="s3">(</span><span class="s1">v</span><span class="s3">.</span><span class="s1">value </span><span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">Enum</span><span class="s3">) </span><span class="s2">else </span><span class="s1">v</span><span class="s3">) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'expected'</span><span class="s3">]]</span>

        <span class="s1">result</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] = {}</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">expected</span><span class="s3">) == </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s1">result</span><span class="s3">[</span><span class="s4">'const'</span><span class="s3">] = </span><span class="s1">expected</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">result</span><span class="s3">[</span><span class="s4">'enum'</span><span class="s3">] = </span><span class="s1">expected</span>

        <span class="s1">types </span><span class="s3">= {</span><span class="s1">type</span><span class="s3">(</span><span class="s1">e</span><span class="s3">) </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">expected</span><span class="s3">}</span>
        <span class="s2">if </span><span class="s1">types </span><span class="s3">== {</span><span class="s1">str</span><span class="s3">}:</span>
            <span class="s1">result</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">] = </span><span class="s4">'string'</span>
        <span class="s2">elif </span><span class="s1">types </span><span class="s3">== {</span><span class="s1">int</span><span class="s3">}:</span>
            <span class="s1">result</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">] = </span><span class="s4">'integer'</span>
        <span class="s2">elif </span><span class="s1">types </span><span class="s3">== {</span><span class="s1">float</span><span class="s3">}:</span>
            <span class="s1">result</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">] = </span><span class="s4">'number'</span>
        <span class="s2">elif </span><span class="s1">types </span><span class="s3">== {</span><span class="s1">bool</span><span class="s3">}:</span>
            <span class="s1">result</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">] = </span><span class="s4">'boolean'</span>
        <span class="s2">elif </span><span class="s1">types </span><span class="s3">== {</span><span class="s1">list</span><span class="s3">}:</span>
            <span class="s1">result</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">] = </span><span class="s4">'array'</span>
        <span class="s2">elif </span><span class="s1">types </span><span class="s3">== {</span><span class="s1">type</span><span class="s3">(</span><span class="s2">None</span><span class="s3">)}:</span>
            <span class="s1">result</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">] = </span><span class="s4">'null'</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">enum_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">EnumSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches an Enum value. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">enum_type </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'cls'</span><span class="s3">]</span>
        <span class="s1">description </span><span class="s3">= </span><span class="s2">None if not </span><span class="s1">enum_type</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s2">else </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">cleandoc</span><span class="s3">(</span><span class="s1">enum_type</span><span class="s3">.</span><span class="s1">__doc__</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s3">(</span>
            <span class="s1">description </span><span class="s3">== </span><span class="s4">'An enumeration.'</span>
        <span class="s3">):  </span><span class="s5"># This is the default value provided by enum.EnumMeta.__new__; don't use it</span>
            <span class="s1">description </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">result</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] = {</span><span class="s4">'title'</span><span class="s3">: </span><span class="s1">enum_type</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">, </span><span class="s4">'description'</span><span class="s3">: </span><span class="s1">description</span><span class="s3">}</span>
        <span class="s1">result </span><span class="s3">= {</span><span class="s1">k</span><span class="s3">: </span><span class="s1">v </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">result</span><span class="s3">.</span><span class="s1">items</span><span class="s3">() </span><span class="s2">if </span><span class="s1">v </span><span class="s2">is not None</span><span class="s3">}</span>

        <span class="s1">expected </span><span class="s3">= [</span><span class="s1">to_jsonable_python</span><span class="s3">(</span><span class="s1">v</span><span class="s3">.</span><span class="s1">value</span><span class="s3">) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'members'</span><span class="s3">]]</span>

        <span class="s1">result</span><span class="s3">[</span><span class="s4">'enum'</span><span class="s3">] = </span><span class="s1">expected</span>

        <span class="s1">types </span><span class="s3">= {</span><span class="s1">type</span><span class="s3">(</span><span class="s1">e</span><span class="s3">) </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">expected</span><span class="s3">}</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">enum_type</span><span class="s3">, </span><span class="s1">str</span><span class="s3">) </span><span class="s2">or </span><span class="s1">types </span><span class="s3">== {</span><span class="s1">str</span><span class="s3">}:</span>
            <span class="s1">result</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">] = </span><span class="s4">'string'</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">enum_type</span><span class="s3">, </span><span class="s1">int</span><span class="s3">) </span><span class="s2">or </span><span class="s1">types </span><span class="s3">== {</span><span class="s1">int</span><span class="s3">}:</span>
            <span class="s1">result</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">] = </span><span class="s4">'integer'</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">enum_type</span><span class="s3">, </span><span class="s1">float</span><span class="s3">) </span><span class="s2">or </span><span class="s1">types </span><span class="s3">== {</span><span class="s1">float</span><span class="s3">}:</span>
            <span class="s1">result</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">] = </span><span class="s4">'number'</span>
        <span class="s2">elif </span><span class="s1">types </span><span class="s3">== {</span><span class="s1">bool</span><span class="s3">}:</span>
            <span class="s1">result</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">] = </span><span class="s4">'boolean'</span>
        <span class="s2">elif </span><span class="s1">types </span><span class="s3">== {</span><span class="s1">list</span><span class="s3">}:</span>
            <span class="s1">result</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">] = </span><span class="s4">'array'</span>

        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">is_instance_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">IsInstanceSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Handles JSON schema generation for a core schema that checks if a value is an instance of a class. 
 
        Unless overridden in a subclass, this raises an error. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">handle_invalid_for_json_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s4">f'core_schema.IsInstanceSchema (</span><span class="s2">{</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">&quot;cls&quot;</span><span class="s3">]</span><span class="s2">}</span><span class="s4">)'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">is_subclass_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">IsSubclassSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Handles JSON schema generation for a core schema that checks if a value is a subclass of a class. 
 
        For backwards compatibility with v1, this does not raise an error, but can be overridden to change this. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Note: This is for compatibility with V1; you can override if you want different behavior.</span>
        <span class="s2">return </span><span class="s3">{}</span>

    <span class="s2">def </span><span class="s1">callable_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CallableSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a callable value. 
 
        Unless overridden in a subclass, this raises an error. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">handle_invalid_for_json_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s4">'core_schema.CallableSchema'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">list_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">ListSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Returns a schema that matches a list schema. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">items_schema </span><span class="s3">= {} </span><span class="s2">if </span><span class="s4">'items_schema' </span><span class="s2">not in </span><span class="s1">schema </span><span class="s2">else </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'items_schema'</span><span class="s3">])</span>
        <span class="s1">json_schema </span><span class="s3">= {</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'array'</span><span class="s3">, </span><span class="s4">'items'</span><span class="s3">: </span><span class="s1">items_schema</span><span class="s3">}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">update_with_validations</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ValidationsMapping</span><span class="s3">.</span><span class="s1">array</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s3">@</span><span class="s1">deprecated</span><span class="s3">(</span><span class="s4">'`tuple_positional_schema` is deprecated. Use `tuple_schema` instead.'</span><span class="s3">, </span><span class="s1">category</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>
    <span class="s3">@</span><span class="s1">final</span>
    <span class="s2">def </span><span class="s1">tuple_positional_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">TupleSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Replaced by `tuple_schema`.&quot;&quot;&quot;</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s4">'`tuple_positional_schema` is deprecated. Use `tuple_schema` instead.'</span><span class="s3">,</span>
            <span class="s1">PydanticDeprecatedSince26</span><span class="s3">,</span>
            <span class="s1">stacklevel</span><span class="s3">=</span><span class="s6">2</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tuple_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">deprecated</span><span class="s3">(</span><span class="s4">'`tuple_variable_schema` is deprecated. Use `tuple_schema` instead.'</span><span class="s3">, </span><span class="s1">category</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>
    <span class="s3">@</span><span class="s1">final</span>
    <span class="s2">def </span><span class="s1">tuple_variable_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">TupleSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Replaced by `tuple_schema`.&quot;&quot;&quot;</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s4">'`tuple_variable_schema` is deprecated. Use `tuple_schema` instead.'</span><span class="s3">,</span>
            <span class="s1">PydanticDeprecatedSince26</span><span class="s3">,</span>
            <span class="s1">stacklevel</span><span class="s3">=</span><span class="s6">2</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tuple_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">tuple_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">TupleSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a tuple schema e.g. `tuple[int, 
        str, bool]` or `tuple[int, ...]`. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">json_schema</span><span class="s3">: </span><span class="s1">JsonSchemaValue </span><span class="s3">= {</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'array'</span><span class="s3">}</span>
        <span class="s2">if </span><span class="s4">'variadic_item_index' </span><span class="s2">in </span><span class="s1">schema</span><span class="s3">:</span>
            <span class="s1">variadic_item_index </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'variadic_item_index'</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">variadic_item_index </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">:</span>
                <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'minItems'</span><span class="s3">] = </span><span class="s1">variadic_item_index</span>
                <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'prefixItems'</span><span class="s3">] = [</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">item</span><span class="s3">) </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'items_schema'</span><span class="s3">][:</span><span class="s1">variadic_item_index</span><span class="s3">]</span>
                <span class="s3">]</span>
            <span class="s2">if </span><span class="s1">variadic_item_index </span><span class="s3">+ </span><span class="s6">1 </span><span class="s3">== </span><span class="s1">len</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'items_schema'</span><span class="s3">]):</span>
                <span class="s5"># if the variadic item is the last item, then represent it faithfully</span>
                <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'items'</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'items_schema'</span><span class="s3">][</span><span class="s1">variadic_item_index</span><span class="s3">])</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s5"># otherwise, 'items' represents the schema for the variadic</span>
                <span class="s5"># item plus the suffix, so just allow anything for simplicity</span>
                <span class="s5"># for now</span>
                <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'items'</span><span class="s3">] = </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">prefixItems </span><span class="s3">= [</span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">item</span><span class="s3">) </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'items_schema'</span><span class="s3">]]</span>
            <span class="s2">if </span><span class="s1">prefixItems</span><span class="s3">:</span>
                <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'prefixItems'</span><span class="s3">] = </span><span class="s1">prefixItems</span>
            <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'minItems'</span><span class="s3">] = </span><span class="s1">len</span><span class="s3">(</span><span class="s1">prefixItems</span><span class="s3">)</span>
            <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'maxItems'</span><span class="s3">] = </span><span class="s1">len</span><span class="s3">(</span><span class="s1">prefixItems</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">update_with_validations</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ValidationsMapping</span><span class="s3">.</span><span class="s1">array</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">set_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">SetSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a set schema. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_common_set_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">frozenset_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">FrozenSetSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a frozenset schema. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_common_set_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_common_set_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">SetSchema </span><span class="s3">| </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">FrozenSetSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s1">items_schema </span><span class="s3">= {} </span><span class="s2">if </span><span class="s4">'items_schema' </span><span class="s2">not in </span><span class="s1">schema </span><span class="s2">else </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'items_schema'</span><span class="s3">])</span>
        <span class="s1">json_schema </span><span class="s3">= {</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'array'</span><span class="s3">, </span><span class="s4">'uniqueItems'</span><span class="s3">: </span><span class="s2">True</span><span class="s3">, </span><span class="s4">'items'</span><span class="s3">: </span><span class="s1">items_schema</span><span class="s3">}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">update_with_validations</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ValidationsMapping</span><span class="s3">.</span><span class="s1">array</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">generator_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">GeneratorSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Returns a JSON schema that represents the provided GeneratorSchema. 
 
        Args: 
            schema: The schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">items_schema </span><span class="s3">= {} </span><span class="s2">if </span><span class="s4">'items_schema' </span><span class="s2">not in </span><span class="s1">schema </span><span class="s2">else </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'items_schema'</span><span class="s3">])</span>
        <span class="s1">json_schema </span><span class="s3">= {</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'array'</span><span class="s3">, </span><span class="s4">'items'</span><span class="s3">: </span><span class="s1">items_schema</span><span class="s3">}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">update_with_validations</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ValidationsMapping</span><span class="s3">.</span><span class="s1">array</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">dict_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">DictSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a dict schema. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">json_schema</span><span class="s3">: </span><span class="s1">JsonSchemaValue </span><span class="s3">= {</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'object'</span><span class="s3">}</span>

        <span class="s1">keys_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'keys_schema'</span><span class="s3">]).</span><span class="s1">copy</span><span class="s3">() </span><span class="s2">if </span><span class="s4">'keys_schema' </span><span class="s2">in </span><span class="s1">schema </span><span class="s2">else </span><span class="s3">{}</span>
        <span class="s2">if </span><span class="s4">'$ref' </span><span class="s2">not in </span><span class="s1">keys_schema</span><span class="s3">:</span>
            <span class="s1">keys_pattern </span><span class="s3">= </span><span class="s1">keys_schema</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s4">'pattern'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s5"># Don't give a title to patternProperties/propertyNames:</span>
            <span class="s1">keys_schema</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s4">'title'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s5"># Here, we assume that if the keys schema is a definition reference,</span>
            <span class="s5"># it can't be a simple string core schema (and thus no pattern can exist).</span>
            <span class="s5"># However, this is only in practice (in theory, a definition reference core</span>
            <span class="s5"># schema could be generated for a simple string schema).</span>
            <span class="s5"># Note that we avoid calling `self.resolve_ref_schema`, as it might not exist yet.</span>
            <span class="s1">keys_pattern </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s1">values_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'values_schema'</span><span class="s3">]).</span><span class="s1">copy</span><span class="s3">() </span><span class="s2">if </span><span class="s4">'values_schema' </span><span class="s2">in </span><span class="s1">schema </span><span class="s2">else </span><span class="s3">{}</span>
        <span class="s5"># don't give a title to additionalProperties:</span>
        <span class="s1">values_schema</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s4">'title'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">values_schema </span><span class="s2">or </span><span class="s1">keys_pattern </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">keys_pattern </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'additionalProperties'</span><span class="s3">] = </span><span class="s1">values_schema</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'patternProperties'</span><span class="s3">] = {</span><span class="s1">keys_pattern</span><span class="s3">: </span><span class="s1">values_schema</span><span class="s3">}</span>
        <span class="s2">else</span><span class="s3">:  </span><span class="s5"># for `dict[str, Any]`, we allow any key and any value, since `str` is the default key type</span>
            <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'additionalProperties'</span><span class="s3">] = </span><span class="s2">True</span>

        <span class="s2">if </span><span class="s3">(</span>
            <span class="s5"># The len check indicates that constraints are probably present:</span>
            <span class="s3">(</span><span class="s1">keys_schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'type'</span><span class="s3">) == </span><span class="s4">'string' </span><span class="s2">and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">keys_schema</span><span class="s3">) &gt; </span><span class="s6">1</span><span class="s3">)</span>
            <span class="s5"># If this is a definition reference schema, it most likely has constraints:</span>
            <span class="s2">or </span><span class="s4">'$ref' </span><span class="s2">in </span><span class="s1">keys_schema</span>
        <span class="s3">):</span>
            <span class="s1">keys_schema</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s4">'type'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'propertyNames'</span><span class="s3">] = </span><span class="s1">keys_schema</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">update_with_validations</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ValidationsMapping</span><span class="s3">.</span><span class="s1">object</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">function_before_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">BeforeValidatorFunctionSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a function-before schema. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'validation' </span><span class="s2">and </span><span class="s3">(</span><span class="s1">input_schema </span><span class="s3">:= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'json_schema_input_schema'</span><span class="s3">)):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">input_schema</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">function_after_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">AfterValidatorFunctionSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a function-after schema. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">function_plain_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">PlainValidatorFunctionSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a function-plain schema. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'validation' </span><span class="s2">and </span><span class="s3">(</span><span class="s1">input_schema </span><span class="s3">:= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'json_schema_input_schema'</span><span class="s3">)):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">input_schema</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">handle_invalid_for_json_schema</span><span class="s3">(</span>
            <span class="s1">schema</span><span class="s3">, </span><span class="s4">f'core_schema.PlainValidatorFunctionSchema (</span><span class="s2">{</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">&quot;function&quot;</span><span class="s3">]</span><span class="s2">}</span><span class="s4">)'</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">function_wrap_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">WrapValidatorFunctionSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a function-wrap schema. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'validation' </span><span class="s2">and </span><span class="s3">(</span><span class="s1">input_schema </span><span class="s3">:= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'json_schema_input_schema'</span><span class="s3">)):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">input_schema</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">default_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">WithDefaultSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema with a default value. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">])</span>

        <span class="s1">default </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_default_value</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">default </span><span class="s2">is </span><span class="s1">NoDefault</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">json_schema</span>

        <span class="s5"># we reflect the application of custom plain, no-info serializers to defaults for</span>
        <span class="s5"># JSON Schemas viewed in serialization mode:</span>
        <span class="s5"># TODO: improvements along with https://github.com/pydantic/pydantic/issues/8208</span>
        <span class="s2">if </span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'serialization'</span>
            <span class="s2">and </span><span class="s3">(</span><span class="s1">ser_schema </span><span class="s3">:= </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">].</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'serialization'</span><span class="s3">))</span>
            <span class="s2">and </span><span class="s3">(</span><span class="s1">ser_func </span><span class="s3">:= </span><span class="s1">ser_schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'function'</span><span class="s3">))</span>
            <span class="s2">and </span><span class="s1">ser_schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'type'</span><span class="s3">) == </span><span class="s4">'function-plain'</span>
            <span class="s2">and not </span><span class="s1">ser_schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'info_arg'</span><span class="s3">)</span>
            <span class="s2">and not </span><span class="s3">(</span><span class="s1">default </span><span class="s2">is None and </span><span class="s1">ser_schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'when_used'</span><span class="s3">) </span><span class="s2">in </span><span class="s3">(</span><span class="s4">'unless-none'</span><span class="s3">, </span><span class="s4">'json-unless-none'</span><span class="s3">))</span>
        <span class="s3">):</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">default </span><span class="s3">= </span><span class="s1">ser_func</span><span class="s3">(</span><span class="s1">default</span><span class="s3">)  </span><span class="s5"># type: ignore</span>
            <span class="s2">except </span><span class="s1">Exception</span><span class="s3">:</span>
                <span class="s5"># It might be that the provided default needs to be validated (read: parsed) first</span>
                <span class="s5"># (assuming `validate_default` is enabled). However, we can't perform</span>
                <span class="s5"># such validation during JSON Schema generation so we don't support</span>
                <span class="s5"># this pattern for now.</span>
                <span class="s5"># (One example is when using `foo: ByteSize = '1MB'`, which validates and</span>
                <span class="s5"># serializes as an int. In this case, `ser_func` is `int` and `int('1MB')` fails).</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">emit_warning</span><span class="s3">(</span>
                    <span class="s4">'non-serializable-default'</span><span class="s3">,</span>
                    <span class="s4">f'Unable to serialize value </span><span class="s2">{</span><span class="s1">default</span><span class="s2">!r} </span><span class="s4">with the plain serializer; excluding default from JSON schema'</span><span class="s3">,</span>
                <span class="s3">)</span>
                <span class="s2">return </span><span class="s1">json_schema</span>

        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">encoded_default </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">encode_default</span><span class="s3">(</span><span class="s1">default</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">pydantic_core</span><span class="s3">.</span><span class="s1">PydanticSerializationError</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">emit_warning</span><span class="s3">(</span>
                <span class="s4">'non-serializable-default'</span><span class="s3">,</span>
                <span class="s4">f'Default value </span><span class="s2">{</span><span class="s1">default</span><span class="s2">} </span><span class="s4">is not JSON serializable; excluding default from JSON schema'</span><span class="s3">,</span>
            <span class="s3">)</span>
            <span class="s5"># Return the inner schema, as though there was no default</span>
            <span class="s2">return </span><span class="s1">json_schema</span>

        <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'default'</span><span class="s3">] = </span><span class="s1">encoded_default</span>
        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">get_default_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">WithDefaultSchema</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Get the default value to be used when generating a JSON Schema for a core schema with a default. 
 
        The default implementation is to use the statically defined default value. This method can be overridden 
        if you want to make use of the default factory. 
 
        Args: 
            schema: The `'with-default'` core schema. 
 
        Returns: 
            The default value to use, or [`NoDefault`][pydantic.json_schema.NoDefault] if no default 
                value is available. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'default'</span><span class="s3">, </span><span class="s1">NoDefault</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">nullable_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">NullableSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that allows null values. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">null_schema </span><span class="s3">= {</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'null'</span><span class="s3">}</span>
        <span class="s1">inner_json_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">])</span>

        <span class="s2">if </span><span class="s1">inner_json_schema </span><span class="s3">== </span><span class="s1">null_schema</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">null_schema</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s5"># Thanks to the equality check against `null_schema` above, I think 'oneOf' would also be valid here;</span>
            <span class="s5"># I'll use 'anyOf' for now, but it could be changed it if it would work better with some external tooling</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_flattened_anyof</span><span class="s3">([</span><span class="s1">inner_json_schema</span><span class="s3">, </span><span class="s1">null_schema</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">union_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">UnionSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that allows values matching any of the given schemas. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">generated</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">JsonSchemaValue</span><span class="s3">] = []</span>

        <span class="s1">choices </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'choices'</span><span class="s3">]</span>
        <span class="s2">for </span><span class="s1">choice </span><span class="s2">in </span><span class="s1">choices</span><span class="s3">:</span>
            <span class="s5"># choice will be a tuple if an explicit label was provided</span>
            <span class="s1">choice_schema </span><span class="s3">= </span><span class="s1">choice</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">choice</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">) </span><span class="s2">else </span><span class="s1">choice</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">generated</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">choice_schema</span><span class="s3">))</span>
            <span class="s2">except </span><span class="s1">PydanticOmit</span><span class="s3">:</span>
                <span class="s2">continue</span>
            <span class="s2">except </span><span class="s1">PydanticInvalidForJsonSchema </span><span class="s2">as </span><span class="s1">exc</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">emit_warning</span><span class="s3">(</span><span class="s4">'skipped-choice'</span><span class="s3">, </span><span class="s1">exc</span><span class="s3">.</span><span class="s1">message</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">generated</span><span class="s3">) == </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">generated</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_flattened_anyof</span><span class="s3">(</span><span class="s1">generated</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">tagged_union_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">TaggedUnionSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that allows values matching any of the given schemas, where 
        the schemas are tagged with a discriminator field that indicates which schema should be used to validate 
        the value. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">generated</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">JsonSchemaValue</span><span class="s3">] = {}</span>
        <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'choices'</span><span class="s3">].</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">Enum</span><span class="s3">):</span>
                <span class="s1">k </span><span class="s3">= </span><span class="s1">k</span><span class="s3">.</span><span class="s1">value</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s5"># Use str(k) since keys must be strings for json; while not technically correct,</span>
                <span class="s5"># it's the closest that can be represented in valid JSON</span>
                <span class="s1">generated</span><span class="s3">[</span><span class="s1">str</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">v</span><span class="s3">).</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s2">except </span><span class="s1">PydanticOmit</span><span class="s3">:</span>
                <span class="s2">continue</span>
            <span class="s2">except </span><span class="s1">PydanticInvalidForJsonSchema </span><span class="s2">as </span><span class="s1">exc</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">emit_warning</span><span class="s3">(</span><span class="s4">'skipped-choice'</span><span class="s3">, </span><span class="s1">exc</span><span class="s3">.</span><span class="s1">message</span><span class="s3">)</span>

        <span class="s1">one_of_choices </span><span class="s3">= </span><span class="s1">_deduplicate_schemas</span><span class="s3">(</span><span class="s1">generated</span><span class="s3">.</span><span class="s1">values</span><span class="s3">())</span>
        <span class="s1">json_schema</span><span class="s3">: </span><span class="s1">JsonSchemaValue </span><span class="s3">= {</span><span class="s4">'oneOf'</span><span class="s3">: </span><span class="s1">one_of_choices</span><span class="s3">}</span>

        <span class="s5"># This reflects the v1 behavior; TODO: we should make it possible to exclude OpenAPI stuff from the JSON schema</span>
        <span class="s1">openapi_discriminator </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_extract_discriminator</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">one_of_choices</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">openapi_discriminator </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'discriminator'</span><span class="s3">] = {</span>
                <span class="s4">'propertyName'</span><span class="s3">: </span><span class="s1">openapi_discriminator</span><span class="s3">,</span>
                <span class="s4">'mapping'</span><span class="s3">: {</span><span class="s1">k</span><span class="s3">: </span><span class="s1">v</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'$ref'</span><span class="s3">, </span><span class="s1">v</span><span class="s3">) </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">generated</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()},</span>
            <span class="s3">}</span>

        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">_extract_discriminator</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">TaggedUnionSchema</span><span class="s3">, </span><span class="s1">one_of_choices</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">JsonDict</span><span class="s3">]</span>
    <span class="s3">) </span><span class="s1">-&gt; str </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Extract a compatible OpenAPI discriminator from the schema and one_of choices that end up in the final 
        schema.&quot;&quot;&quot;</span>
        <span class="s1">openapi_discriminator</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'discriminator'</span><span class="s3">], </span><span class="s1">str</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'discriminator'</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'discriminator'</span><span class="s3">], </span><span class="s1">list</span><span class="s3">):</span>
            <span class="s5"># If the discriminator is a single item list containing a string, that is equivalent to the string case</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'discriminator'</span><span class="s3">]) == </span><span class="s6">1 </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'discriminator'</span><span class="s3">][</span><span class="s6">0</span><span class="s3">], </span><span class="s1">str</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'discriminator'</span><span class="s3">][</span><span class="s6">0</span><span class="s3">]</span>
            <span class="s5"># When an alias is used that is different from the field name, the discriminator will be a list of single</span>
            <span class="s5"># str lists, one for the attribute and one for the actual alias. The logic here will work even if there is</span>
            <span class="s5"># more than one possible attribute, and looks for whether a single alias choice is present as a documented</span>
            <span class="s5"># property on all choices. If so, that property will be used as the OpenAPI discriminator.</span>
            <span class="s2">for </span><span class="s1">alias_path </span><span class="s2">in </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'discriminator'</span><span class="s3">]:</span>
                <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">alias_path</span><span class="s3">, </span><span class="s1">list</span><span class="s3">):</span>
                    <span class="s2">break  </span><span class="s5"># this means that the discriminator is not a list of alias paths</span>
                <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">alias_path</span><span class="s3">) != </span><span class="s6">1</span><span class="s3">:</span>
                    <span class="s2">continue  </span><span class="s5"># this means that the &quot;alias&quot; does not represent a single field</span>
                <span class="s1">alias </span><span class="s3">= </span><span class="s1">alias_path</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
                <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">alias</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
                    <span class="s2">continue  </span><span class="s5"># this means that the &quot;alias&quot; does not represent a field</span>
                <span class="s1">alias_is_present_on_all_choices </span><span class="s3">= </span><span class="s2">True</span>
                <span class="s2">for </span><span class="s1">choice </span><span class="s2">in </span><span class="s1">one_of_choices</span><span class="s3">:</span>
                    <span class="s2">try</span><span class="s3">:</span>
                        <span class="s1">choice </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">resolve_ref_schema</span><span class="s3">(</span><span class="s1">choice</span><span class="s3">)</span>
                    <span class="s2">except </span><span class="s1">RuntimeError </span><span class="s2">as </span><span class="s1">exc</span><span class="s3">:</span>
                        <span class="s5"># TODO: fixme - this is a workaround for the fact that we can't always resolve refs</span>
                        <span class="s5"># for tagged union choices at this point in the schema gen process, we might need to do</span>
                        <span class="s5"># another pass at the end like we do for core schemas</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">emit_warning</span><span class="s3">(</span><span class="s4">'skipped-discriminator'</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">exc</span><span class="s3">))</span>
                        <span class="s1">choice </span><span class="s3">= {}</span>
                    <span class="s1">properties </span><span class="s3">= </span><span class="s1">choice</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'properties'</span><span class="s3">, {})</span>
                    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">properties</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">) </span><span class="s2">or </span><span class="s1">alias </span><span class="s2">not in </span><span class="s1">properties</span><span class="s3">:</span>
                        <span class="s1">alias_is_present_on_all_choices </span><span class="s3">= </span><span class="s2">False</span>
                        <span class="s2">break</span>
                <span class="s2">if </span><span class="s1">alias_is_present_on_all_choices</span><span class="s3">:</span>
                    <span class="s1">openapi_discriminator </span><span class="s3">= </span><span class="s1">alias</span>
                    <span class="s2">break</span>
        <span class="s2">return </span><span class="s1">openapi_discriminator</span>

    <span class="s2">def </span><span class="s1">chain_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">ChainSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a core_schema.ChainSchema. 
 
        When generating a schema for validation, we return the validation JSON schema for the first step in the chain. 
        For serialization, we return the serialization JSON schema for the last step in the chain. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">step_index </span><span class="s3">= </span><span class="s6">0 </span><span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'validation' </span><span class="s2">else </span><span class="s3">-</span><span class="s6">1  </span><span class="s5"># use first step for validation, last for serialization</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'steps'</span><span class="s3">][</span><span class="s1">step_index</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">lax_or_strict_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">LaxOrStrictSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that allows values matching either the lax schema or the 
        strict schema. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s5"># TODO: Need to read the default value off of model config or whatever</span>
        <span class="s1">use_strict </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'strict'</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)  </span><span class="s5"># TODO: replace this default False</span>
        <span class="s5"># If your JSON schema fails to generate it is probably</span>
        <span class="s5"># because one of the following two branches failed.</span>
        <span class="s2">if </span><span class="s1">use_strict</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'strict_schema'</span><span class="s3">])</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'lax_schema'</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">json_or_python_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">JsonOrPythonSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that allows values matching either the JSON schema or the 
        Python schema. 
 
        The JSON schema is used instead of the Python schema. If you want to use the Python schema, you should override 
        this method. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'json_schema'</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">typed_dict_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">TypedDictSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a typed dict. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">total </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'total'</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">named_required_fields</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">, </span><span class="s1">CoreSchemaField</span><span class="s3">]] = [</span>
            <span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">field_is_required</span><span class="s3">(</span><span class="s1">field</span><span class="s3">, </span><span class="s1">total</span><span class="s3">), </span><span class="s1">field</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">field </span><span class="s2">in </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'fields'</span><span class="s3">].</span><span class="s1">items</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">field_is_present</span><span class="s3">(</span><span class="s1">field</span><span class="s3">)</span>
        <span class="s3">]</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'serialization'</span><span class="s3">:</span>
            <span class="s1">named_required_fields</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_name_required_computed_fields</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'computed_fields'</span><span class="s3">, [])))</span>
        <span class="s1">cls </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'cls'</span><span class="s3">)</span>
        <span class="s1">config </span><span class="s3">= </span><span class="s1">_get_typed_dict_config</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper_stack</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">config</span><span class="s3">):</span>
            <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_named_required_fields_schema</span><span class="s3">(</span><span class="s1">named_required_fields</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">cls </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_update_class_schema</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">, </span><span class="s1">config</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">extra </span><span class="s3">= </span><span class="s1">config</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'extra'</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">extra </span><span class="s3">== </span><span class="s4">'forbid'</span><span class="s3">:</span>
                <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'additionalProperties'</span><span class="s3">] = </span><span class="s2">False</span>
            <span class="s2">elif </span><span class="s1">extra </span><span class="s3">== </span><span class="s4">'allow'</span><span class="s3">:</span>
                <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'additionalProperties'</span><span class="s3">] = </span><span class="s2">True</span>

        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s3">@</span><span class="s1">staticmethod</span>
    <span class="s2">def </span><span class="s1">_name_required_computed_fields</span><span class="s3">(</span>
        <span class="s1">computed_fields</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">ComputedField</span><span class="s3">],</span>
    <span class="s3">) </span><span class="s1">-&gt; list</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">, </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">ComputedField</span><span class="s3">]]:</span>
        <span class="s2">return </span><span class="s3">[(</span><span class="s1">field</span><span class="s3">[</span><span class="s4">'property_name'</span><span class="s3">], </span><span class="s2">True</span><span class="s3">, </span><span class="s1">field</span><span class="s3">) </span><span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s1">computed_fields</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">_named_required_fields_schema</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">named_required_fields</span><span class="s3">: </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">, </span><span class="s1">CoreSchemaField</span><span class="s3">]]</span>
    <span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s1">properties</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">JsonSchemaValue</span><span class="s3">] = {}</span>
        <span class="s1">required_fields</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = []</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">field </span><span class="s2">in </span><span class="s1">named_required_fields</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">by_alias</span><span class="s3">:</span>
                <span class="s1">name </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_alias_name</span><span class="s3">(</span><span class="s1">field</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">field_json_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">field</span><span class="s3">).</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s2">except </span><span class="s1">PydanticOmit</span><span class="s3">:</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s4">'title' </span><span class="s2">not in </span><span class="s1">field_json_schema </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">field_title_should_be_set</span><span class="s3">(</span><span class="s1">field</span><span class="s3">):</span>
                <span class="s1">title </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_title_from_name</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
                <span class="s1">field_json_schema</span><span class="s3">[</span><span class="s4">'title'</span><span class="s3">] = </span><span class="s1">title</span>
            <span class="s1">field_json_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">handle_ref_overrides</span><span class="s3">(</span><span class="s1">field_json_schema</span><span class="s3">)</span>
            <span class="s1">properties</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">field_json_schema</span>
            <span class="s2">if </span><span class="s1">required</span><span class="s3">:</span>
                <span class="s1">required_fields</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>

        <span class="s1">json_schema </span><span class="s3">= {</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'object'</span><span class="s3">, </span><span class="s4">'properties'</span><span class="s3">: </span><span class="s1">properties</span><span class="s3">}</span>
        <span class="s2">if </span><span class="s1">required_fields</span><span class="s3">:</span>
            <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'required'</span><span class="s3">] = </span><span class="s1">required_fields</span>
        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">_get_alias_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">field</span><span class="s3">: </span><span class="s1">CoreSchemaField</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">field</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">] == </span><span class="s4">'computed-field'</span><span class="s3">:</span>
            <span class="s1">alias</span><span class="s3">: </span><span class="s1">Any </span><span class="s3">= </span><span class="s1">field</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'alias'</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'validation'</span><span class="s3">:</span>
            <span class="s1">alias </span><span class="s3">= </span><span class="s1">field</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'validation_alias'</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">alias </span><span class="s3">= </span><span class="s1">field</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'serialization_alias'</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">alias</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
            <span class="s1">name </span><span class="s3">= </span><span class="s1">alias</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">alias</span><span class="s3">, </span><span class="s1">list</span><span class="s3">):</span>
            <span class="s1">alias </span><span class="s3">= </span><span class="s1">cast</span><span class="s3">(</span><span class="s4">'list[str] | str'</span><span class="s3">, </span><span class="s1">alias</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">alias</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">list</span><span class="s3">) </span><span class="s2">and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">path</span><span class="s3">) == </span><span class="s6">1 </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">path</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">str</span><span class="s3">):</span>
                    <span class="s5"># Use the first valid single-item string path; the code that constructs the alias array</span>
                    <span class="s5"># should ensure the first such item is what belongs in the JSON schema</span>
                    <span class="s1">name </span><span class="s3">= </span><span class="s1">path</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
                    <span class="s2">break</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">assert_never</span><span class="s3">(</span><span class="s1">alias</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">name</span>

    <span class="s2">def </span><span class="s1">typed_dict_field_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">TypedDictField</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a typed dict field. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">dataclass_field_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">DataclassField</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a dataclass field. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">model_field_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">ModelField</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a model field. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">computed_field_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">ComputedField</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a computed field. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'return_schema'</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">model_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">ModelSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a model. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s5"># We do not use schema['model'].model_json_schema() here</span>
        <span class="s5"># because it could lead to inconsistent refs handling, etc.</span>
        <span class="s1">cls </span><span class="s3">= </span><span class="s1">cast</span><span class="s3">(</span><span class="s4">'type[BaseModel]'</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'cls'</span><span class="s3">])</span>
        <span class="s1">config </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">model_config</span>

        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper_stack</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">config</span><span class="s3">):</span>
            <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">])</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_update_class_schema</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">, </span><span class="s1">config</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">_update_class_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">json_schema</span><span class="s3">: </span><span class="s1">JsonSchemaValue</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">], </span><span class="s1">config</span><span class="s3">: </span><span class="s1">ConfigDict</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Update json_schema with the following, extracted from `config` and `cls`: 
 
        * title 
        * description 
        * additional properties 
        * json_schema_extra 
        * deprecated 
 
        Done in place, hence there's no return value as the original json_schema is mutated. 
        No ref resolving is involved here, as that's not appropriate for simple updates. 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s3">.</span><span class="s1">main </span><span class="s2">import </span><span class="s1">BaseModel</span>
        <span class="s2">from </span><span class="s3">.</span><span class="s1">root_model </span><span class="s2">import </span><span class="s1">RootModel</span>

        <span class="s2">if </span><span class="s3">(</span><span class="s1">config_title </span><span class="s3">:= </span><span class="s1">config</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'title'</span><span class="s3">)) </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">json_schema</span><span class="s3">.</span><span class="s1">setdefault</span><span class="s3">(</span><span class="s4">'title'</span><span class="s3">, </span><span class="s1">config_title</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">model_title_generator </span><span class="s3">:= </span><span class="s1">config</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'model_title_generator'</span><span class="s3">):</span>
            <span class="s1">title </span><span class="s3">= </span><span class="s1">model_title_generator</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">)</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">title</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">f'model_title_generator </span><span class="s2">{</span><span class="s1">model_title_generator</span><span class="s2">} </span><span class="s4">must return str, not </span><span class="s2">{</span><span class="s1">title</span><span class="s3">.</span><span class="s1">__class__</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>
            <span class="s1">json_schema</span><span class="s3">.</span><span class="s1">setdefault</span><span class="s3">(</span><span class="s4">'title'</span><span class="s3">, </span><span class="s1">title</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s4">'title' </span><span class="s2">not in </span><span class="s1">json_schema</span><span class="s3">:</span>
            <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'title'</span><span class="s3">] = </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__name__</span>

        <span class="s5"># BaseModel and dataclasses; don't use cls.__doc__ as it will contain the verbose class signature by default</span>
        <span class="s1">docstring </span><span class="s3">= </span><span class="s2">None if </span><span class="s1">cls </span><span class="s2">is </span><span class="s1">BaseModel </span><span class="s2">or </span><span class="s1">dataclasses</span><span class="s3">.</span><span class="s1">is_dataclass</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">) </span><span class="s2">else </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__doc__</span>

        <span class="s2">if </span><span class="s1">docstring</span><span class="s3">:</span>
            <span class="s1">json_schema</span><span class="s3">.</span><span class="s1">setdefault</span><span class="s3">(</span><span class="s4">'description'</span><span class="s3">, </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">cleandoc</span><span class="s3">(</span><span class="s1">docstring</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">RootModel</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">root_description </span><span class="s3">:= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__pydantic_fields__</span><span class="s3">[</span><span class="s4">'root'</span><span class="s3">].</span><span class="s1">description</span><span class="s3">):</span>
            <span class="s1">json_schema</span><span class="s3">.</span><span class="s1">setdefault</span><span class="s3">(</span><span class="s4">'description'</span><span class="s3">, </span><span class="s1">root_description</span><span class="s3">)</span>

        <span class="s1">extra </span><span class="s3">= </span><span class="s1">config</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'extra'</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s4">'additionalProperties' </span><span class="s2">not in </span><span class="s1">json_schema</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">extra </span><span class="s3">== </span><span class="s4">'allow'</span><span class="s3">:</span>
                <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'additionalProperties'</span><span class="s3">] = </span><span class="s2">True</span>
            <span class="s2">elif </span><span class="s1">extra </span><span class="s3">== </span><span class="s4">'forbid'</span><span class="s3">:</span>
                <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'additionalProperties'</span><span class="s3">] = </span><span class="s2">False</span>

        <span class="s1">json_schema_extra </span><span class="s3">= </span><span class="s1">config</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'json_schema_extra'</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">BaseModel</span><span class="s3">) </span><span class="s2">and </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__pydantic_root_model__</span><span class="s3">:</span>
            <span class="s1">root_json_schema_extra </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">model_fields</span><span class="s3">[</span><span class="s4">'root'</span><span class="s3">].</span><span class="s1">json_schema_extra</span>
            <span class="s2">if </span><span class="s1">json_schema_extra </span><span class="s2">and </span><span class="s1">root_json_schema_extra</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                    <span class="s4">'&quot;model_config[</span><span class="s2">\'</span><span class="s4">json_schema_extra</span><span class="s2">\'</span><span class="s4">]&quot; and &quot;Field.json_schema_extra&quot; on &quot;RootModel.root&quot;'</span>
                    <span class="s4">' field must not be set simultaneously'</span>
                <span class="s3">)</span>
            <span class="s2">if </span><span class="s1">root_json_schema_extra</span><span class="s3">:</span>
                <span class="s1">json_schema_extra </span><span class="s3">= </span><span class="s1">root_json_schema_extra</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">json_schema_extra</span><span class="s3">, (</span><span class="s1">staticmethod</span><span class="s3">, </span><span class="s1">classmethod</span><span class="s3">)):</span>
            <span class="s5"># In older versions of python, this is necessary to ensure staticmethod/classmethods are callable</span>
            <span class="s1">json_schema_extra </span><span class="s3">= </span><span class="s1">json_schema_extra</span><span class="s3">.</span><span class="s1">__get__</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">json_schema_extra</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">):</span>
            <span class="s1">json_schema</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">json_schema_extra</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">json_schema_extra</span><span class="s3">):</span>
            <span class="s5"># FIXME: why are there type ignores here? We support two signatures for json_schema_extra callables...</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">(</span><span class="s1">json_schema_extra</span><span class="s3">).</span><span class="s1">parameters</span><span class="s3">) &gt; </span><span class="s6">1</span><span class="s3">:</span>
                <span class="s1">json_schema_extra</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">)  </span><span class="s5"># type: ignore</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">json_schema_extra</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">)  </span><span class="s5"># type: ignore</span>
        <span class="s2">elif </span><span class="s1">json_schema_extra </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">f&quot;model_config['json_schema_extra']=</span><span class="s2">{</span><span class="s1">json_schema_extra</span><span class="s2">} </span><span class="s4">should be a dict, callable, or None&quot;</span>
            <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s4">'__deprecated__'</span><span class="s3">):</span>
            <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'deprecated'</span><span class="s3">] = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">resolve_ref_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">json_schema</span><span class="s3">: </span><span class="s1">JsonSchemaValue</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Resolve a JsonSchemaValue to the non-ref schema if it is a $ref schema. 
 
        Args: 
            json_schema: The schema to resolve. 
 
        Returns: 
            The resolved schema. 
 
        Raises: 
            RuntimeError: If the schema reference can't be found in definitions. 
        &quot;&quot;&quot;</span>
        <span class="s2">while </span><span class="s4">'$ref' </span><span class="s2">in </span><span class="s1">json_schema</span><span class="s3">:</span>
            <span class="s1">ref </span><span class="s3">= </span><span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'$ref'</span><span class="s3">]</span>
            <span class="s1">schema_to_update </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_schema_from_definitions</span><span class="s3">(</span><span class="s1">JsonRef</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">))</span>
            <span class="s2">if </span><span class="s1">schema_to_update </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">f'Cannot update undefined schema for $ref=</span><span class="s2">{</span><span class="s1">ref</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>
            <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">schema_to_update</span>
        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">model_fields_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">ModelFieldsSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a model's fields. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">named_required_fields</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">, </span><span class="s1">CoreSchemaField</span><span class="s3">]] = [</span>
            <span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">field_is_required</span><span class="s3">(</span><span class="s1">field</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">True</span><span class="s3">), </span><span class="s1">field</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">field </span><span class="s2">in </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'fields'</span><span class="s3">].</span><span class="s1">items</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">field_is_present</span><span class="s3">(</span><span class="s1">field</span><span class="s3">)</span>
        <span class="s3">]</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'serialization'</span><span class="s3">:</span>
            <span class="s1">named_required_fields</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_name_required_computed_fields</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'computed_fields'</span><span class="s3">, [])))</span>
        <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_named_required_fields_schema</span><span class="s3">(</span><span class="s1">named_required_fields</span><span class="s3">)</span>
        <span class="s1">extras_schema </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'extras_schema'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">extras_schema </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">schema_to_update </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">resolve_ref_schema</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">)</span>
            <span class="s1">schema_to_update</span><span class="s3">[</span><span class="s4">'additionalProperties'</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">extras_schema</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">field_is_present</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">field</span><span class="s3">: </span><span class="s1">CoreSchemaField</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Whether the field should be included in the generated JSON schema. 
 
        Args: 
            field: The schema for the field itself. 
 
        Returns: 
            `True` if the field should be included in the generated JSON schema, `False` otherwise. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'serialization'</span><span class="s3">:</span>
            <span class="s5"># If you still want to include the field in the generated JSON schema,</span>
            <span class="s5"># override this method and return True</span>
            <span class="s2">return not </span><span class="s1">field</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'serialization_exclude'</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'validation'</span><span class="s3">:</span>
            <span class="s2">return True</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">assert_never</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">mode</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">field_is_required</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">field</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">ModelField </span><span class="s3">| </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">DataclassField </span><span class="s3">| </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">TypedDictField</span><span class="s3">,</span>
        <span class="s1">total</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Whether the field should be marked as required in the generated JSON schema. 
        (Note that this is irrelevant if the field is not present in the JSON schema.). 
 
        Args: 
            field: The schema for the field itself. 
            total: Only applies to `TypedDictField`s. 
                Indicates if the `TypedDict` this field belongs to is total, in which case any fields that don't 
                explicitly specify `required=False` are required. 
 
        Returns: 
            `True` if the field should be marked as required in the generated JSON schema, `False` otherwise. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'serialization' </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config</span><span class="s3">.</span><span class="s1">json_schema_serialization_defaults_required</span><span class="s3">:</span>
            <span class="s2">return not </span><span class="s1">field</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'serialization_exclude'</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">field</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">] == </span><span class="s4">'typed-dict-field'</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">field</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'required'</span><span class="s3">, </span><span class="s1">total</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">field</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">][</span><span class="s4">'type'</span><span class="s3">] != </span><span class="s4">'default'</span>

    <span class="s2">def </span><span class="s1">dataclass_args_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">DataclassArgsSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a dataclass's constructor arguments. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">named_required_fields</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">, </span><span class="s1">CoreSchemaField</span><span class="s3">]] = [</span>
            <span class="s3">(</span><span class="s1">field</span><span class="s3">[</span><span class="s4">'name'</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">field_is_required</span><span class="s3">(</span><span class="s1">field</span><span class="s3">, </span><span class="s1">total</span><span class="s3">=</span><span class="s2">True</span><span class="s3">), </span><span class="s1">field</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'fields'</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">field_is_present</span><span class="s3">(</span><span class="s1">field</span><span class="s3">)</span>
        <span class="s3">]</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'serialization'</span><span class="s3">:</span>
            <span class="s1">named_required_fields</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_name_required_computed_fields</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'computed_fields'</span><span class="s3">, [])))</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_named_required_fields_schema</span><span class="s3">(</span><span class="s1">named_required_fields</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">dataclass_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">DataclassSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a dataclass. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s3">.</span><span class="s1">_internal</span><span class="s3">.</span><span class="s1">_dataclasses </span><span class="s2">import </span><span class="s1">is_builtin_dataclass</span>

        <span class="s1">cls </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'cls'</span><span class="s3">]</span>
        <span class="s1">config</span><span class="s3">: </span><span class="s1">ConfigDict </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s4">'__pydantic_config__'</span><span class="s3">, </span><span class="s1">cast</span><span class="s3">(</span><span class="s4">'ConfigDict'</span><span class="s3">, {}))</span>

        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config_wrapper_stack</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">config</span><span class="s3">):</span>
            <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">]).</span><span class="s1">copy</span><span class="s3">()</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_update_class_schema</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">, </span><span class="s1">config</span><span class="s3">)</span>

        <span class="s5"># Dataclass-specific handling of description</span>
        <span class="s2">if </span><span class="s1">is_builtin_dataclass</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">):</span>
            <span class="s5"># vanilla dataclass; don't use cls.__doc__ as it will contain the class signature by default</span>
            <span class="s1">description </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">description </span><span class="s3">= </span><span class="s2">None if </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s2">is None else </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">cleandoc</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__doc__</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">description</span><span class="s3">:</span>
            <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'description'</span><span class="s3">] = </span><span class="s1">description</span>

        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">arguments_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">ArgumentsSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a function's arguments. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">prefer_positional </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'metadata'</span><span class="s3">, {}).</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'pydantic_js_prefer_positional_arguments'</span><span class="s3">)</span>

        <span class="s1">arguments </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'arguments_schema'</span><span class="s3">]</span>
        <span class="s1">kw_only_arguments </span><span class="s3">= [</span><span class="s1">a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arguments </span><span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'mode'</span><span class="s3">) == </span><span class="s4">'keyword_only'</span><span class="s3">]</span>
        <span class="s1">kw_or_p_arguments </span><span class="s3">= [</span><span class="s1">a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arguments </span><span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'mode'</span><span class="s3">) </span><span class="s2">in </span><span class="s3">{</span><span class="s4">'positional_or_keyword'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">}]</span>
        <span class="s1">p_only_arguments </span><span class="s3">= [</span><span class="s1">a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arguments </span><span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'mode'</span><span class="s3">) == </span><span class="s4">'positional_only'</span><span class="s3">]</span>
        <span class="s1">var_args_schema </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'var_args_schema'</span><span class="s3">)</span>
        <span class="s1">var_kwargs_schema </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'var_kwargs_schema'</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">prefer_positional</span><span class="s3">:</span>
            <span class="s1">positional_possible </span><span class="s3">= </span><span class="s2">not </span><span class="s1">kw_only_arguments </span><span class="s2">and not </span><span class="s1">var_kwargs_schema</span>
            <span class="s2">if </span><span class="s1">positional_possible</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">p_arguments_schema</span><span class="s3">(</span><span class="s1">p_only_arguments </span><span class="s3">+ </span><span class="s1">kw_or_p_arguments</span><span class="s3">, </span><span class="s1">var_args_schema</span><span class="s3">)</span>

        <span class="s1">keyword_possible </span><span class="s3">= </span><span class="s2">not </span><span class="s1">p_only_arguments </span><span class="s2">and not </span><span class="s1">var_args_schema</span>
        <span class="s2">if </span><span class="s1">keyword_possible</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">kw_arguments_schema</span><span class="s3">(</span><span class="s1">kw_or_p_arguments </span><span class="s3">+ </span><span class="s1">kw_only_arguments</span><span class="s3">, </span><span class="s1">var_kwargs_schema</span><span class="s3">)</span>

        <span class="s2">if not </span><span class="s1">prefer_positional</span><span class="s3">:</span>
            <span class="s1">positional_possible </span><span class="s3">= </span><span class="s2">not </span><span class="s1">kw_only_arguments </span><span class="s2">and not </span><span class="s1">var_kwargs_schema</span>
            <span class="s2">if </span><span class="s1">positional_possible</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">p_arguments_schema</span><span class="s3">(</span><span class="s1">p_only_arguments </span><span class="s3">+ </span><span class="s1">kw_or_p_arguments</span><span class="s3">, </span><span class="s1">var_args_schema</span><span class="s3">)</span>

        <span class="s2">raise </span><span class="s1">PydanticInvalidForJsonSchema</span><span class="s3">(</span>
            <span class="s4">'Unable to generate JSON schema for arguments validator with positional-only and keyword-only arguments'</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">kw_arguments_schema</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">arguments</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">ArgumentsParameter</span><span class="s3">], </span><span class="s1">var_kwargs_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None</span>
    <span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a function's keyword arguments. 
 
        Args: 
            arguments: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">properties</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">JsonSchemaValue</span><span class="s3">] = {}</span>
        <span class="s1">required</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = []</span>
        <span class="s2">for </span><span class="s1">argument </span><span class="s2">in </span><span class="s1">arguments</span><span class="s3">:</span>
            <span class="s1">name </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_argument_name</span><span class="s3">(</span><span class="s1">argument</span><span class="s3">)</span>
            <span class="s1">argument_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">argument</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">]).</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s1">argument_schema</span><span class="s3">[</span><span class="s4">'title'</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_title_from_name</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s1">properties</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">argument_schema</span>

            <span class="s2">if </span><span class="s1">argument</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">][</span><span class="s4">'type'</span><span class="s3">] != </span><span class="s4">'default'</span><span class="s3">:</span>
                <span class="s5"># This assumes that if the argument has a default value,</span>
                <span class="s5"># the inner schema must be of type WithDefaultSchema.</span>
                <span class="s5"># I believe this is true, but I am not 100% sure</span>
                <span class="s1">required</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>

        <span class="s1">json_schema</span><span class="s3">: </span><span class="s1">JsonSchemaValue </span><span class="s3">= {</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'object'</span><span class="s3">, </span><span class="s4">'properties'</span><span class="s3">: </span><span class="s1">properties</span><span class="s3">}</span>
        <span class="s2">if </span><span class="s1">required</span><span class="s3">:</span>
            <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'required'</span><span class="s3">] = </span><span class="s1">required</span>

        <span class="s2">if </span><span class="s1">var_kwargs_schema</span><span class="s3">:</span>
            <span class="s1">additional_properties_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">var_kwargs_schema</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">additional_properties_schema</span><span class="s3">:</span>
                <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'additionalProperties'</span><span class="s3">] = </span><span class="s1">additional_properties_schema</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'additionalProperties'</span><span class="s3">] = </span><span class="s2">False</span>
        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">p_arguments_schema</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">arguments</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">ArgumentsParameter</span><span class="s3">], </span><span class="s1">var_args_schema</span><span class="s3">: </span><span class="s1">CoreSchema </span><span class="s3">| </span><span class="s2">None</span>
    <span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a function's positional arguments. 
 
        Args: 
            arguments: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">prefix_items</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">JsonSchemaValue</span><span class="s3">] = []</span>
        <span class="s1">min_items </span><span class="s3">= </span><span class="s6">0</span>

        <span class="s2">for </span><span class="s1">argument </span><span class="s2">in </span><span class="s1">arguments</span><span class="s3">:</span>
            <span class="s1">name </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_argument_name</span><span class="s3">(</span><span class="s1">argument</span><span class="s3">)</span>

            <span class="s1">argument_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">argument</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">]).</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s1">argument_schema</span><span class="s3">[</span><span class="s4">'title'</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_title_from_name</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s1">prefix_items</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">argument_schema</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">argument</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">][</span><span class="s4">'type'</span><span class="s3">] != </span><span class="s4">'default'</span><span class="s3">:</span>
                <span class="s5"># This assumes that if the argument has a default value,</span>
                <span class="s5"># the inner schema must be of type WithDefaultSchema.</span>
                <span class="s5"># I believe this is true, but I am not 100% sure</span>
                <span class="s1">min_items </span><span class="s3">+= </span><span class="s6">1</span>

        <span class="s1">json_schema</span><span class="s3">: </span><span class="s1">JsonSchemaValue </span><span class="s3">= {</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'array'</span><span class="s3">}</span>
        <span class="s2">if </span><span class="s1">prefix_items</span><span class="s3">:</span>
            <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'prefixItems'</span><span class="s3">] = </span><span class="s1">prefix_items</span>
        <span class="s2">if </span><span class="s1">min_items</span><span class="s3">:</span>
            <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'minItems'</span><span class="s3">] = </span><span class="s1">min_items</span>

        <span class="s2">if </span><span class="s1">var_args_schema</span><span class="s3">:</span>
            <span class="s1">items_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">var_args_schema</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">items_schema</span><span class="s3">:</span>
                <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'items'</span><span class="s3">] = </span><span class="s1">items_schema</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'maxItems'</span><span class="s3">] = </span><span class="s1">len</span><span class="s3">(</span><span class="s1">prefix_items</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">get_argument_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">argument</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">ArgumentsParameter </span><span class="s3">| </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">ArgumentsV3Parameter</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Retrieves the name of an argument. 
 
        Args: 
            argument: The core schema. 
 
        Returns: 
            The name of the argument. 
        &quot;&quot;&quot;</span>
        <span class="s1">name </span><span class="s3">= </span><span class="s1">argument</span><span class="s3">[</span><span class="s4">'name'</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">by_alias</span><span class="s3">:</span>
            <span class="s1">alias </span><span class="s3">= </span><span class="s1">argument</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'alias'</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">alias</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
                <span class="s1">name </span><span class="s3">= </span><span class="s1">alias</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">pass  </span><span class="s5"># might want to do something else?</span>
        <span class="s2">return </span><span class="s1">name</span>

    <span class="s2">def </span><span class="s1">arguments_v3_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">ArgumentsV3Schema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a function's arguments. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">arguments </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'arguments_schema'</span><span class="s3">]</span>
        <span class="s1">properties</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">JsonSchemaValue</span><span class="s3">] = {}</span>
        <span class="s1">required</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = []</span>
        <span class="s2">for </span><span class="s1">argument </span><span class="s2">in </span><span class="s1">arguments</span><span class="s3">:</span>
            <span class="s1">mode </span><span class="s3">= </span><span class="s1">argument</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'mode'</span><span class="s3">, </span><span class="s4">'positional_or_keyword'</span><span class="s3">)</span>
            <span class="s1">name </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_argument_name</span><span class="s3">(</span><span class="s1">argument</span><span class="s3">)</span>
            <span class="s1">argument_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">argument</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">]).</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'var_args'</span><span class="s3">:</span>
                <span class="s1">argument_schema </span><span class="s3">= {</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'array'</span><span class="s3">, </span><span class="s4">'items'</span><span class="s3">: </span><span class="s1">argument_schema</span><span class="s3">}</span>
            <span class="s2">elif </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'var_kwargs_uniform'</span><span class="s3">:</span>
                <span class="s1">argument_schema </span><span class="s3">= {</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'object'</span><span class="s3">, </span><span class="s4">'additionalProperties'</span><span class="s3">: </span><span class="s1">argument_schema</span><span class="s3">}</span>

            <span class="s1">argument_schema</span><span class="s3">.</span><span class="s1">setdefault</span><span class="s3">(</span><span class="s4">'title'</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_title_from_name</span><span class="s3">(</span><span class="s1">name</span><span class="s3">))</span>
            <span class="s1">properties</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">argument_schema</span>

            <span class="s2">if </span><span class="s3">(</span>
                <span class="s3">(</span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'var_kwargs_unpacked_typed_dict' </span><span class="s2">and </span><span class="s4">'required' </span><span class="s2">in </span><span class="s1">argument_schema</span><span class="s3">)</span>
                <span class="s2">or </span><span class="s1">mode </span><span class="s2">not in </span><span class="s3">{</span><span class="s4">'var_args'</span><span class="s3">, </span><span class="s4">'var_kwargs_uniform'</span><span class="s3">, </span><span class="s4">'var_kwargs_unpacked_typed_dict'</span><span class="s3">}</span>
                <span class="s2">and </span><span class="s1">argument</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">][</span><span class="s4">'type'</span><span class="s3">] != </span><span class="s4">'default'</span>
            <span class="s3">):</span>
                <span class="s5"># This assumes that if the argument has a default value,</span>
                <span class="s5"># the inner schema must be of type WithDefaultSchema.</span>
                <span class="s5"># I believe this is true, but I am not 100% sure</span>
                <span class="s1">required</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>

        <span class="s1">json_schema</span><span class="s3">: </span><span class="s1">JsonSchemaValue </span><span class="s3">= {</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'object'</span><span class="s3">, </span><span class="s4">'properties'</span><span class="s3">: </span><span class="s1">properties</span><span class="s3">}</span>
        <span class="s2">if </span><span class="s1">required</span><span class="s3">:</span>
            <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'required'</span><span class="s3">] = </span><span class="s1">required</span>
        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">call_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CallSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a function call. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'arguments_schema'</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">custom_error_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CustomErrorSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a custom error. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">json_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">JsonSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a JSON object. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">content_core_schema </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'schema'</span><span class="s3">) </span><span class="s2">or </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">any_schema</span><span class="s3">()</span>
        <span class="s1">content_json_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">content_core_schema</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'validation'</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s3">{</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'string'</span><span class="s3">, </span><span class="s4">'contentMediaType'</span><span class="s3">: </span><span class="s4">'application/json'</span><span class="s3">, </span><span class="s4">'contentSchema'</span><span class="s3">: </span><span class="s1">content_json_schema</span><span class="s3">}</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s5"># self.mode == 'serialization'</span>
            <span class="s2">return </span><span class="s1">content_json_schema</span>

    <span class="s2">def </span><span class="s1">url_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">UrlSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a URL. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">json_schema </span><span class="s3">= {</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'string'</span><span class="s3">, </span><span class="s4">'format'</span><span class="s3">: </span><span class="s4">'uri'</span><span class="s3">, </span><span class="s4">'minLength'</span><span class="s3">: </span><span class="s6">1</span><span class="s3">}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">update_with_validations</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ValidationsMapping</span><span class="s3">.</span><span class="s1">string</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">multi_host_url_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">MultiHostUrlSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a URL that can be used with multiple hosts. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Note: 'multi-host-uri' is a custom/pydantic-specific format, not part of the JSON Schema spec</span>
        <span class="s1">json_schema </span><span class="s3">= {</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'string'</span><span class="s3">, </span><span class="s4">'format'</span><span class="s3">: </span><span class="s4">'multi-host-uri'</span><span class="s3">, </span><span class="s4">'minLength'</span><span class="s3">: </span><span class="s6">1</span><span class="s3">}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">update_with_validations</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ValidationsMapping</span><span class="s3">.</span><span class="s1">string</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">uuid_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">UuidSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a UUID. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">{</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'string'</span><span class="s3">, </span><span class="s4">'format'</span><span class="s3">: </span><span class="s4">'uuid'</span><span class="s3">}</span>

    <span class="s2">def </span><span class="s1">definitions_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">DefinitionsSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a JSON object with definitions. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">definition </span><span class="s2">in </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'definitions'</span><span class="s3">]:</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">definition</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">PydanticInvalidForJsonSchema </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s1">core_ref</span><span class="s3">: </span><span class="s1">CoreRef </span><span class="s3">= </span><span class="s1">CoreRef</span><span class="s3">(</span><span class="s1">definition</span><span class="s3">[</span><span class="s4">'ref'</span><span class="s3">])  </span><span class="s5"># type: ignore</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_core_defs_invalid_for_json_schema</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_defs_ref</span><span class="s3">((</span><span class="s1">core_ref</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mode</span><span class="s3">))] = </span><span class="s1">e</span>
                <span class="s2">continue</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">definition_ref_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">DefinitionReferenceSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that references a definition. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">core_ref </span><span class="s3">= </span><span class="s1">CoreRef</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'schema_ref'</span><span class="s3">])</span>
        <span class="s1">_</span><span class="s3">, </span><span class="s1">ref_json_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_cache_defs_ref_schema</span><span class="s3">(</span><span class="s1">core_ref</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">ref_json_schema</span>

    <span class="s2">def </span><span class="s1">ser_schema</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">SerSchema </span><span class="s3">| </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">IncExSeqSerSchema </span><span class="s3">| </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">IncExDictSerSchema</span>
    <span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a serialized object. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s1">schema_type </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">schema_type </span><span class="s3">== </span><span class="s4">'function-plain' </span><span class="s2">or </span><span class="s1">schema_type </span><span class="s3">== </span><span class="s4">'function-wrap'</span><span class="s3">:</span>
            <span class="s5"># PlainSerializerFunctionSerSchema or WrapSerializerFunctionSerSchema</span>
            <span class="s1">return_schema </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'return_schema'</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">return_schema </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">return_schema</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">schema_type </span><span class="s3">== </span><span class="s4">'format' </span><span class="s2">or </span><span class="s1">schema_type </span><span class="s3">== </span><span class="s4">'to-string'</span><span class="s3">:</span>
            <span class="s5"># FormatSerSchema or ToStringSerSchema</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">str_schema</span><span class="s3">(</span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">str_schema</span><span class="s3">())</span>
        <span class="s2">elif </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">] == </span><span class="s4">'model'</span><span class="s3">:</span>
            <span class="s5"># ModelSerSchema</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_inner</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">])</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">complex_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">ComplexSchema</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Generates a JSON schema that matches a complex number. 
 
        JSON has no standard way to represent complex numbers. Complex number is not a numeric 
        type. Here we represent complex number as strings following the rule defined by Python. 
        For instance, '1+2j' is an accepted complex string. Details can be found in 
        [Python's `complex` documentation][complex]. 
 
        Args: 
            schema: The core schema. 
 
        Returns: 
            The generated JSON schema. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">{</span><span class="s4">'type'</span><span class="s3">: </span><span class="s4">'string'</span><span class="s3">}</span>

    <span class="s5"># ### Utility methods</span>

    <span class="s2">def </span><span class="s1">get_title_from_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Retrieves a title from a name. 
 
        Args: 
            name: The name to retrieve a title from. 
 
        Returns: 
            The title. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">name</span><span class="s3">.</span><span class="s1">title</span><span class="s3">().</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">'_'</span><span class="s3">, </span><span class="s4">' '</span><span class="s3">).</span><span class="s1">strip</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">field_title_should_be_set</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchemaOrField</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Returns true if a field with the given schema should have a title set based on the field name. 
 
        Intuitively, we want this to return true for schemas that wouldn't otherwise provide their own title 
        (e.g., int, float, str), and false for those that would (e.g., BaseModel subclasses). 
 
        Args: 
            schema: The schema to check. 
 
        Returns: 
            `True` if the field should have a title set, `False` otherwise. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">_core_utils</span><span class="s3">.</span><span class="s1">is_core_schema_field</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">] == </span><span class="s4">'computed-field'</span><span class="s3">:</span>
                <span class="s1">field_schema </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'return_schema'</span><span class="s3">]</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">field_schema </span><span class="s3">= </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">field_title_should_be_set</span><span class="s3">(</span><span class="s1">field_schema</span><span class="s3">)</span>

        <span class="s2">elif </span><span class="s1">_core_utils</span><span class="s3">.</span><span class="s1">is_core_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'ref'</span><span class="s3">):  </span><span class="s5"># things with refs, such as models and enums, should not have titles set</span>
                <span class="s2">return False</span>
            <span class="s2">if </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">] </span><span class="s2">in </span><span class="s3">{</span><span class="s4">'default'</span><span class="s3">, </span><span class="s4">'nullable'</span><span class="s3">, </span><span class="s4">'definitions'</span><span class="s3">}:</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">field_title_should_be_set</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">])  </span><span class="s5"># type: ignore[typeddict-item]</span>
            <span class="s2">if </span><span class="s1">_core_utils</span><span class="s3">.</span><span class="s1">is_function_with_inner_schema</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">field_title_should_be_set</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'schema'</span><span class="s3">])</span>
            <span class="s2">if </span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">] == </span><span class="s4">'definition-ref'</span><span class="s3">:</span>
                <span class="s5"># Referenced schemas should not have titles set for the same reason</span>
                <span class="s5"># schemas with refs should not</span>
                <span class="s2">return False</span>
            <span class="s2">return True  </span><span class="s5"># anything else should have title set</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">PydanticInvalidForJsonSchema</span><span class="s3">(</span><span class="s4">f'Unexpected schema type: schema=</span><span class="s2">{</span><span class="s1">schema</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)  </span><span class="s5"># pragma: no cover</span>

    <span class="s2">def </span><span class="s1">normalize_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Normalizes a name to be used as a key in a dictionary. 
 
        Args: 
            name: The name to normalize. 
 
        Returns: 
            The normalized name. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">re</span><span class="s3">.</span><span class="s1">sub</span><span class="s3">(</span><span class="s4">r'[^a-zA-Z0-9.\-_]'</span><span class="s3">, </span><span class="s4">'_'</span><span class="s3">, </span><span class="s1">name</span><span class="s3">).</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">'.'</span><span class="s3">, </span><span class="s4">'__'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_defs_ref</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">core_mode_ref</span><span class="s3">: </span><span class="s1">CoreModeRef</span><span class="s3">) </span><span class="s1">-&gt; DefsRef</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Override this method to change the way that definitions keys are generated from a core reference. 
 
        Args: 
            core_mode_ref: The core reference. 
 
        Returns: 
            The definitions key. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Split the core ref into &quot;components&quot;; generic origins and arguments are each separate components</span>
        <span class="s1">core_ref</span><span class="s3">, </span><span class="s1">mode </span><span class="s3">= </span><span class="s1">core_mode_ref</span>
        <span class="s1">components </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s4">r'([\][,])'</span><span class="s3">, </span><span class="s1">core_ref</span><span class="s3">)</span>
        <span class="s5"># Remove IDs from each component</span>
        <span class="s1">components </span><span class="s3">= [</span><span class="s1">x</span><span class="s3">.</span><span class="s1">rsplit</span><span class="s3">(</span><span class="s4">':'</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">components</span><span class="s3">]</span>
        <span class="s1">core_ref_no_id </span><span class="s3">= </span><span class="s4">''</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">components</span><span class="s3">)</span>
        <span class="s5"># Remove everything before the last period from each &quot;component&quot;</span>
        <span class="s1">components </span><span class="s3">= [</span><span class="s1">re</span><span class="s3">.</span><span class="s1">sub</span><span class="s3">(</span><span class="s4">r'(?:[^.[\]]+\.)+((?:[^.[\]]+))'</span><span class="s3">, </span><span class="s4">r'\1'</span><span class="s3">, </span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">components</span><span class="s3">]</span>
        <span class="s1">short_ref </span><span class="s3">= </span><span class="s4">''</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">components</span><span class="s3">)</span>

        <span class="s1">mode_title </span><span class="s3">= </span><span class="s1">_MODE_TITLE_MAPPING</span><span class="s3">[</span><span class="s1">mode</span><span class="s3">]</span>

        <span class="s5"># It is important that the generated defs_ref values be such that at least one choice will not</span>
        <span class="s5"># be generated for any other core_ref. Currently, this should be the case because we include</span>
        <span class="s5"># the id of the source type in the core_ref</span>
        <span class="s1">name </span><span class="s3">= </span><span class="s1">DefsRef</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">normalize_name</span><span class="s3">(</span><span class="s1">short_ref</span><span class="s3">))</span>
        <span class="s1">name_mode </span><span class="s3">= </span><span class="s1">DefsRef</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">normalize_name</span><span class="s3">(</span><span class="s1">short_ref</span><span class="s3">) + </span><span class="s4">f'-</span><span class="s2">{</span><span class="s1">mode_title</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>
        <span class="s1">module_qualname </span><span class="s3">= </span><span class="s1">DefsRef</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">normalize_name</span><span class="s3">(</span><span class="s1">core_ref_no_id</span><span class="s3">))</span>
        <span class="s1">module_qualname_mode </span><span class="s3">= </span><span class="s1">DefsRef</span><span class="s3">(</span><span class="s4">f'</span><span class="s2">{</span><span class="s1">module_qualname</span><span class="s2">}</span><span class="s4">-</span><span class="s2">{</span><span class="s1">mode_title</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>
        <span class="s1">module_qualname_id </span><span class="s3">= </span><span class="s1">DefsRef</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">normalize_name</span><span class="s3">(</span><span class="s1">core_ref</span><span class="s3">))</span>
        <span class="s1">occurrence_index </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_collision_index</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">module_qualname_id</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">occurrence_index </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_collision_counter</span><span class="s3">[</span><span class="s1">module_qualname</span><span class="s3">] += </span><span class="s6">1</span>
            <span class="s1">occurrence_index </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_collision_index</span><span class="s3">[</span><span class="s1">module_qualname_id</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_collision_counter</span><span class="s3">[</span><span class="s1">module_qualname</span><span class="s3">]</span>

        <span class="s1">module_qualname_occurrence </span><span class="s3">= </span><span class="s1">DefsRef</span><span class="s3">(</span><span class="s4">f'</span><span class="s2">{</span><span class="s1">module_qualname</span><span class="s2">}</span><span class="s4">__</span><span class="s2">{</span><span class="s1">occurrence_index</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>
        <span class="s1">module_qualname_occurrence_mode </span><span class="s3">= </span><span class="s1">DefsRef</span><span class="s3">(</span><span class="s4">f'</span><span class="s2">{</span><span class="s1">module_qualname_mode</span><span class="s2">}</span><span class="s4">__</span><span class="s2">{</span><span class="s1">occurrence_index</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_prioritized_defsref_choices</span><span class="s3">[</span><span class="s1">module_qualname_occurrence_mode</span><span class="s3">] = [</span>
            <span class="s1">name</span><span class="s3">,</span>
            <span class="s1">name_mode</span><span class="s3">,</span>
            <span class="s1">module_qualname</span><span class="s3">,</span>
            <span class="s1">module_qualname_mode</span><span class="s3">,</span>
            <span class="s1">module_qualname_occurrence</span><span class="s3">,</span>
            <span class="s1">module_qualname_occurrence_mode</span><span class="s3">,</span>
        <span class="s3">]</span>

        <span class="s2">return </span><span class="s1">module_qualname_occurrence_mode</span>

    <span class="s2">def </span><span class="s1">get_cache_defs_ref_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">core_ref</span><span class="s3">: </span><span class="s1">CoreRef</span><span class="s3">) </span><span class="s1">-&gt; tuple</span><span class="s3">[</span><span class="s1">DefsRef</span><span class="s3">, </span><span class="s1">JsonSchemaValue</span><span class="s3">]:</span>
        <span class="s0">&quot;&quot;&quot;This method wraps the get_defs_ref method with some cache-lookup/population logic, 
        and returns both the produced defs_ref and the JSON schema that will refer to the right definition. 
 
        Args: 
            core_ref: The core reference to get the definitions reference for. 
 
        Returns: 
            A tuple of the definitions reference and the JSON schema that will refer to it. 
        &quot;&quot;&quot;</span>
        <span class="s1">core_mode_ref </span><span class="s3">= (</span><span class="s1">core_ref</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mode</span><span class="s3">)</span>
        <span class="s1">maybe_defs_ref </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">core_to_defs_refs</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">core_mode_ref</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">maybe_defs_ref </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">json_ref </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">core_to_json_refs</span><span class="s3">[</span><span class="s1">core_mode_ref</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">maybe_defs_ref</span><span class="s3">, {</span><span class="s4">'$ref'</span><span class="s3">: </span><span class="s1">json_ref</span><span class="s3">}</span>

        <span class="s1">defs_ref </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_defs_ref</span><span class="s3">(</span><span class="s1">core_mode_ref</span><span class="s3">)</span>

        <span class="s5"># populate the ref translation mappings</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">core_to_defs_refs</span><span class="s3">[</span><span class="s1">core_mode_ref</span><span class="s3">] = </span><span class="s1">defs_ref</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">defs_to_core_refs</span><span class="s3">[</span><span class="s1">defs_ref</span><span class="s3">] = </span><span class="s1">core_mode_ref</span>

        <span class="s1">json_ref </span><span class="s3">= </span><span class="s1">JsonRef</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ref_template</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">model</span><span class="s3">=</span><span class="s1">defs_ref</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">core_to_json_refs</span><span class="s3">[</span><span class="s1">core_mode_ref</span><span class="s3">] = </span><span class="s1">json_ref</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">json_to_defs_refs</span><span class="s3">[</span><span class="s1">json_ref</span><span class="s3">] = </span><span class="s1">defs_ref</span>
        <span class="s1">ref_json_schema </span><span class="s3">= {</span><span class="s4">'$ref'</span><span class="s3">: </span><span class="s1">json_ref</span><span class="s3">}</span>
        <span class="s2">return </span><span class="s1">defs_ref</span><span class="s3">, </span><span class="s1">ref_json_schema</span>

    <span class="s2">def </span><span class="s1">handle_ref_overrides</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">json_schema</span><span class="s3">: </span><span class="s1">JsonSchemaValue</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Remove any sibling keys that are redundant with the referenced schema. 
 
        Args: 
            json_schema: The schema to remove redundant sibling keys from. 
 
        Returns: 
            The schema with redundant sibling keys removed. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s4">'$ref' </span><span class="s2">in </span><span class="s1">json_schema</span><span class="s3">:</span>
            <span class="s5"># prevent modifications to the input; this copy may be safe to drop if there is significant overhead</span>
            <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">json_schema</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

            <span class="s1">referenced_json_schema </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_schema_from_definitions</span><span class="s3">(</span><span class="s1">JsonRef</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'$ref'</span><span class="s3">]))</span>
            <span class="s2">if </span><span class="s1">referenced_json_schema </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s5"># This can happen when building schemas for models with not-yet-defined references.</span>
                <span class="s5"># It may be a good idea to do a recursive pass at the end of the generation to remove</span>
                <span class="s5"># any redundant override keys.</span>
                <span class="s2">return </span><span class="s1">json_schema</span>
            <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">list</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()):</span>
                <span class="s2">if </span><span class="s1">k </span><span class="s3">== </span><span class="s4">'$ref'</span><span class="s3">:</span>
                    <span class="s2">continue</span>
                <span class="s2">if </span><span class="s1">k </span><span class="s2">in </span><span class="s1">referenced_json_schema </span><span class="s2">and </span><span class="s1">referenced_json_schema</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] == </span><span class="s1">v</span><span class="s3">:</span>
                    <span class="s2">del </span><span class="s1">json_schema</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]  </span><span class="s5"># redundant key</span>

        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">get_schema_from_definitions</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">json_ref</span><span class="s3">: </span><span class="s1">JsonRef</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">def_ref </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">json_to_defs_refs</span><span class="s3">[</span><span class="s1">json_ref</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">def_ref </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_core_defs_invalid_for_json_schema</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_core_defs_invalid_for_json_schema</span><span class="s3">[</span><span class="s1">def_ref</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">definitions</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">def_ref</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">json_ref</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">((</span><span class="s4">'http://'</span><span class="s3">, </span><span class="s4">'https://'</span><span class="s3">)):</span>
                <span class="s2">return None</span>
            <span class="s2">raise</span>

    <span class="s2">def </span><span class="s1">encode_default</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dft</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Encode a default value to a JSON-serializable value. 
 
        This is used to encode default values for fields in the generated JSON schema. 
 
        Args: 
            dft: The default value to encode. 
 
        Returns: 
            The encoded default value. 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s3">.</span><span class="s1">type_adapter </span><span class="s2">import </span><span class="s1">TypeAdapter</span><span class="s3">, </span><span class="s1">_type_has_config</span>

        <span class="s1">config </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_config</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">default </span><span class="s3">= (</span>
                <span class="s1">dft</span>
                <span class="s2">if </span><span class="s1">_type_has_config</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">dft</span><span class="s3">))</span>
                <span class="s2">else </span><span class="s1">TypeAdapter</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">dft</span><span class="s3">), </span><span class="s1">config</span><span class="s3">=</span><span class="s1">config</span><span class="s3">.</span><span class="s1">config_dict</span><span class="s3">).</span><span class="s1">dump_python</span><span class="s3">(</span>
                    <span class="s1">dft</span><span class="s3">, </span><span class="s1">by_alias</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">by_alias</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">'json'</span>
                <span class="s3">)</span>
            <span class="s3">)</span>
        <span class="s2">except </span><span class="s1">PydanticSchemaGenerationError</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">pydantic_core</span><span class="s3">.</span><span class="s1">PydanticSerializationError</span><span class="s3">(</span><span class="s4">f'Unable to encode default value </span><span class="s2">{</span><span class="s1">dft</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">pydantic_core</span><span class="s3">.</span><span class="s1">to_jsonable_python</span><span class="s3">(</span>
            <span class="s1">default</span><span class="s3">, </span><span class="s1">timedelta_mode</span><span class="s3">=</span><span class="s1">config</span><span class="s3">.</span><span class="s1">ser_json_timedelta</span><span class="s3">, </span><span class="s1">bytes_mode</span><span class="s3">=</span><span class="s1">config</span><span class="s3">.</span><span class="s1">ser_json_bytes</span><span class="s3">, </span><span class="s1">by_alias</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">by_alias</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">update_with_validations</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">json_schema</span><span class="s3">: </span><span class="s1">JsonSchemaValue</span><span class="s3">, </span><span class="s1">core_schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">, </span><span class="s1">mapping</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">str</span><span class="s3">]</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Update the json_schema with the corresponding validations specified in the core_schema, 
        using the provided mapping to translate keys in core_schema to the appropriate keys for a JSON schema. 
 
        Args: 
            json_schema: The JSON schema to update. 
            core_schema: The core schema to get the validations from. 
            mapping: A mapping from core_schema attribute names to the corresponding JSON schema attribute names. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">core_key</span><span class="s3">, </span><span class="s1">json_schema_key </span><span class="s2">in </span><span class="s1">mapping</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s1">core_key </span><span class="s2">in </span><span class="s1">core_schema</span><span class="s3">:</span>
                <span class="s1">json_schema</span><span class="s3">[</span><span class="s1">json_schema_key</span><span class="s3">] = </span><span class="s1">core_schema</span><span class="s3">[</span><span class="s1">core_key</span><span class="s3">]</span>

    <span class="s2">class </span><span class="s1">ValidationsMapping</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;This class just contains mappings from core_schema attribute names to the corresponding 
        JSON schema attribute names. While I suspect it is unlikely to be necessary, you can in 
        principle override this class in a subclass of GenerateJsonSchema (by inheriting from 
        GenerateJsonSchema.ValidationsMapping) to change these mappings. 
        &quot;&quot;&quot;</span>

        <span class="s1">numeric </span><span class="s3">= {</span>
            <span class="s4">'multiple_of'</span><span class="s3">: </span><span class="s4">'multipleOf'</span><span class="s3">,</span>
            <span class="s4">'le'</span><span class="s3">: </span><span class="s4">'maximum'</span><span class="s3">,</span>
            <span class="s4">'ge'</span><span class="s3">: </span><span class="s4">'minimum'</span><span class="s3">,</span>
            <span class="s4">'lt'</span><span class="s3">: </span><span class="s4">'exclusiveMaximum'</span><span class="s3">,</span>
            <span class="s4">'gt'</span><span class="s3">: </span><span class="s4">'exclusiveMinimum'</span><span class="s3">,</span>
        <span class="s3">}</span>
        <span class="s1">bytes </span><span class="s3">= {</span>
            <span class="s4">'min_length'</span><span class="s3">: </span><span class="s4">'minLength'</span><span class="s3">,</span>
            <span class="s4">'max_length'</span><span class="s3">: </span><span class="s4">'maxLength'</span><span class="s3">,</span>
        <span class="s3">}</span>
        <span class="s1">string </span><span class="s3">= {</span>
            <span class="s4">'min_length'</span><span class="s3">: </span><span class="s4">'minLength'</span><span class="s3">,</span>
            <span class="s4">'max_length'</span><span class="s3">: </span><span class="s4">'maxLength'</span><span class="s3">,</span>
            <span class="s4">'pattern'</span><span class="s3">: </span><span class="s4">'pattern'</span><span class="s3">,</span>
        <span class="s3">}</span>
        <span class="s1">array </span><span class="s3">= {</span>
            <span class="s4">'min_length'</span><span class="s3">: </span><span class="s4">'minItems'</span><span class="s3">,</span>
            <span class="s4">'max_length'</span><span class="s3">: </span><span class="s4">'maxItems'</span><span class="s3">,</span>
        <span class="s3">}</span>
        <span class="s1">object </span><span class="s3">= {</span>
            <span class="s4">'min_length'</span><span class="s3">: </span><span class="s4">'minProperties'</span><span class="s3">,</span>
            <span class="s4">'max_length'</span><span class="s3">: </span><span class="s4">'maxProperties'</span><span class="s3">,</span>
        <span class="s3">}</span>

    <span class="s2">def </span><span class="s1">get_flattened_anyof</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schemas</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">JsonSchemaValue</span><span class="s3">]) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s1">members </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">schema </span><span class="s2">in </span><span class="s1">schemas</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">) == </span><span class="s6">1 </span><span class="s2">and </span><span class="s4">'anyOf' </span><span class="s2">in </span><span class="s1">schema</span><span class="s3">:</span>
                <span class="s1">members</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'anyOf'</span><span class="s3">])</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">members</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>
        <span class="s1">members </span><span class="s3">= </span><span class="s1">_deduplicate_schemas</span><span class="s3">(</span><span class="s1">members</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">members</span><span class="s3">) == </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">members</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s3">{</span><span class="s4">'anyOf'</span><span class="s3">: </span><span class="s1">members</span><span class="s3">}</span>

    <span class="s2">def </span><span class="s1">get_json_ref_counts</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">json_schema</span><span class="s3">: </span><span class="s1">JsonSchemaValue</span><span class="s3">) </span><span class="s1">-&gt; dict</span><span class="s3">[</span><span class="s1">JsonRef</span><span class="s3">, </span><span class="s1">int</span><span class="s3">]:</span>
        <span class="s0">&quot;&quot;&quot;Get all values corresponding to the key '$ref' anywhere in the json_schema.&quot;&quot;&quot;</span>
        <span class="s1">json_refs</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">JsonRef</span><span class="s3">, </span><span class="s1">int</span><span class="s3">] = </span><span class="s1">Counter</span><span class="s3">()</span>

        <span class="s2">def </span><span class="s1">_add_json_refs</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s4">'$ref' </span><span class="s2">in </span><span class="s1">schema</span><span class="s3">:</span>
                    <span class="s1">json_ref </span><span class="s3">= </span><span class="s1">JsonRef</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">[</span><span class="s4">'$ref'</span><span class="s3">])</span>
                    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">json_ref</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
                        <span class="s2">return  </span><span class="s5"># in this case, '$ref' might have been the name of a property</span>
                    <span class="s1">already_visited </span><span class="s3">= </span><span class="s1">json_ref </span><span class="s2">in </span><span class="s1">json_refs</span>
                    <span class="s1">json_refs</span><span class="s3">[</span><span class="s1">json_ref</span><span class="s3">] += </span><span class="s6">1</span>
                    <span class="s2">if </span><span class="s1">already_visited</span><span class="s3">:</span>
                        <span class="s2">return  </span><span class="s5"># prevent recursion on a definition that was already visited</span>
                    <span class="s2">try</span><span class="s3">:</span>
                        <span class="s1">defs_ref </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">json_to_defs_refs</span><span class="s3">[</span><span class="s1">json_ref</span><span class="s3">]</span>
                        <span class="s2">if </span><span class="s1">defs_ref </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_core_defs_invalid_for_json_schema</span><span class="s3">:</span>
                            <span class="s2">raise </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_core_defs_invalid_for_json_schema</span><span class="s3">[</span><span class="s1">defs_ref</span><span class="s3">]</span>
                        <span class="s1">_add_json_refs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">definitions</span><span class="s3">[</span><span class="s1">defs_ref</span><span class="s3">])</span>
                    <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
                        <span class="s2">if not </span><span class="s1">json_ref</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">((</span><span class="s4">'http://'</span><span class="s3">, </span><span class="s4">'https://'</span><span class="s3">)):</span>
                            <span class="s2">raise</span>

                <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">schema</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                    <span class="s2">if </span><span class="s1">k </span><span class="s3">== </span><span class="s4">'examples' </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">list</span><span class="s3">):</span>
                        <span class="s5"># Skip examples that may contain arbitrary values and references</span>
                        <span class="s5"># (see the comment in `_get_all_json_refs` for more details).</span>
                        <span class="s2">continue</span>
                    <span class="s1">_add_json_refs</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">, </span><span class="s1">list</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">schema</span><span class="s3">:</span>
                    <span class="s1">_add_json_refs</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>

        <span class="s1">_add_json_refs</span><span class="s3">(</span><span class="s1">json_schema</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">json_refs</span>

    <span class="s2">def </span><span class="s1">handle_invalid_for_json_schema</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">CoreSchemaOrField</span><span class="s3">, </span><span class="s1">error_info</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">PydanticInvalidForJsonSchema</span><span class="s3">(</span><span class="s4">f'Cannot generate a JsonSchema for </span><span class="s2">{</span><span class="s1">error_info</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">emit_warning</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">: </span><span class="s1">JsonSchemaWarningKind</span><span class="s3">, </span><span class="s1">detail</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;This method simply emits PydanticJsonSchemaWarnings based on handling in the `warning_message` method.&quot;&quot;&quot;</span>
        <span class="s1">message </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">render_warning_message</span><span class="s3">(</span><span class="s1">kind</span><span class="s3">, </span><span class="s1">detail</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">message </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s1">message</span><span class="s3">, </span><span class="s1">PydanticJsonSchemaWarning</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">render_warning_message</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">: </span><span class="s1">JsonSchemaWarningKind</span><span class="s3">, </span><span class="s1">detail</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; str </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;This method is responsible for ignoring warnings as desired, and for formatting the warning messages. 
 
        You can override the value of `ignored_warning_kinds` in a subclass of GenerateJsonSchema 
        to modify what warnings are generated. If you want more control, you can override this method; 
        just return None in situations where you don't want warnings to be emitted. 
 
        Args: 
            kind: The kind of warning to render. It can be one of the following: 
 
                - 'skipped-choice': A choice field was skipped because it had no valid choices. 
                - 'non-serializable-default': A default value was skipped because it was not JSON-serializable. 
            detail: A string with additional details about the warning. 
 
        Returns: 
            The formatted warning message, or `None` if no warning should be emitted. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">kind </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ignored_warning_kinds</span><span class="s3">:</span>
            <span class="s2">return None</span>
        <span class="s2">return </span><span class="s4">f'</span><span class="s2">{</span><span class="s1">detail</span><span class="s2">} </span><span class="s4">[</span><span class="s2">{</span><span class="s1">kind</span><span class="s2">}</span><span class="s4">]'</span>

    <span class="s2">def </span><span class="s1">_build_definitions_remapping</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; _DefinitionsRemapping</span><span class="s3">:</span>
        <span class="s1">defs_to_json</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">DefsRef</span><span class="s3">, </span><span class="s1">JsonRef</span><span class="s3">] = {}</span>
        <span class="s2">for </span><span class="s1">defs_refs </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_prioritized_defsref_choices</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
            <span class="s2">for </span><span class="s1">defs_ref </span><span class="s2">in </span><span class="s1">defs_refs</span><span class="s3">:</span>
                <span class="s1">json_ref </span><span class="s3">= </span><span class="s1">JsonRef</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ref_template</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">model</span><span class="s3">=</span><span class="s1">defs_ref</span><span class="s3">))</span>
                <span class="s1">defs_to_json</span><span class="s3">[</span><span class="s1">defs_ref</span><span class="s3">] = </span><span class="s1">json_ref</span>

        <span class="s2">return </span><span class="s1">_DefinitionsRemapping</span><span class="s3">.</span><span class="s1">from_prioritized_choices</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_prioritized_defsref_choices</span><span class="s3">, </span><span class="s1">defs_to_json</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">definitions</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_garbage_collect_definitions</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">: </span><span class="s1">JsonSchemaValue</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">visited_defs_refs</span><span class="s3">: </span><span class="s1">set</span><span class="s3">[</span><span class="s1">DefsRef</span><span class="s3">] = </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s1">unvisited_json_refs </span><span class="s3">= </span><span class="s1">_get_all_json_refs</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">)</span>
        <span class="s2">while </span><span class="s1">unvisited_json_refs</span><span class="s3">:</span>
            <span class="s1">next_json_ref </span><span class="s3">= </span><span class="s1">unvisited_json_refs</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">next_defs_ref </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">json_to_defs_refs</span><span class="s3">[</span><span class="s1">next_json_ref</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">next_defs_ref </span><span class="s2">in </span><span class="s1">visited_defs_refs</span><span class="s3">:</span>
                    <span class="s2">continue</span>
                <span class="s1">visited_defs_refs</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">next_defs_ref</span><span class="s3">)</span>
                <span class="s1">unvisited_json_refs</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">_get_all_json_refs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">definitions</span><span class="s3">[</span><span class="s1">next_defs_ref</span><span class="s3">]))</span>
            <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
                <span class="s2">if not </span><span class="s1">next_json_ref</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">((</span><span class="s4">'http://'</span><span class="s3">, </span><span class="s4">'https://'</span><span class="s3">)):</span>
                    <span class="s2">raise</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">definitions </span><span class="s3">= {</span><span class="s1">k</span><span class="s3">: </span><span class="s1">v </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">definitions</span><span class="s3">.</span><span class="s1">items</span><span class="s3">() </span><span class="s2">if </span><span class="s1">k </span><span class="s2">in </span><span class="s1">visited_defs_refs</span><span class="s3">}</span>


<span class="s5"># ##### Start JSON Schema Generation Functions #####</span>


<span class="s2">def </span><span class="s1">model_json_schema</span><span class="s3">(</span>
    <span class="s1">cls</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">BaseModel</span><span class="s3">] | </span><span class="s1">type</span><span class="s3">[</span><span class="s1">PydanticDataclass</span><span class="s3">],</span>
    <span class="s1">by_alias</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
    <span class="s1">ref_template</span><span class="s3">: </span><span class="s1">str </span><span class="s3">= </span><span class="s1">DEFAULT_REF_TEMPLATE</span><span class="s3">,</span>
    <span class="s1">schema_generator</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">GenerateJsonSchema</span><span class="s3">] = </span><span class="s1">GenerateJsonSchema</span><span class="s3">,</span>
    <span class="s1">mode</span><span class="s3">: </span><span class="s1">JsonSchemaMode </span><span class="s3">= </span><span class="s4">'validation'</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]:</span>
    <span class="s0">&quot;&quot;&quot;Utility function to generate a JSON Schema for a model. 
 
    Args: 
        cls: The model class to generate a JSON Schema for. 
        by_alias: If `True` (the default), fields will be serialized according to their alias. 
            If `False`, fields will be serialized according to their attribute name. 
        ref_template: The template to use for generating JSON Schema references. 
        schema_generator: The class to use for generating the JSON Schema. 
        mode: The mode to use for generating the JSON Schema. It can be one of the following: 
 
            - 'validation': Generate a JSON Schema for validating data. 
            - 'serialization': Generate a JSON Schema for serializing data. 
 
    Returns: 
        The generated JSON Schema. 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">main </span><span class="s2">import </span><span class="s1">BaseModel</span>

    <span class="s1">schema_generator_instance </span><span class="s3">= </span><span class="s1">schema_generator</span><span class="s3">(</span><span class="s1">by_alias</span><span class="s3">=</span><span class="s1">by_alias</span><span class="s3">, </span><span class="s1">ref_template</span><span class="s3">=</span><span class="s1">ref_template</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__pydantic_core_schema__</span><span class="s3">, </span><span class="s1">_mock_val_ser</span><span class="s3">.</span><span class="s1">MockCoreSchema</span><span class="s3">):</span>
        <span class="s1">cls</span><span class="s3">.</span><span class="s1">__pydantic_core_schema__</span><span class="s3">.</span><span class="s1">rebuild</span><span class="s3">()</span>

    <span class="s2">if </span><span class="s1">cls </span><span class="s2">is </span><span class="s1">BaseModel</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">AttributeError</span><span class="s3">(</span><span class="s4">'model_json_schema() must be called on a subclass of BaseModel, not BaseModel itself.'</span><span class="s3">)</span>

    <span class="s2">assert not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__pydantic_core_schema__</span><span class="s3">, </span><span class="s1">_mock_val_ser</span><span class="s3">.</span><span class="s1">MockCoreSchema</span><span class="s3">), </span><span class="s4">'this is a bug! please report it'</span>
    <span class="s2">return </span><span class="s1">schema_generator_instance</span><span class="s3">.</span><span class="s1">generate</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__pydantic_core_schema__</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s1">mode</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">models_json_schema</span><span class="s3">(</span>
    <span class="s1">models</span><span class="s3">: </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">type</span><span class="s3">[</span><span class="s1">BaseModel</span><span class="s3">] | </span><span class="s1">type</span><span class="s3">[</span><span class="s1">PydanticDataclass</span><span class="s3">], </span><span class="s1">JsonSchemaMode</span><span class="s3">]],</span>
    <span class="s3">*,</span>
    <span class="s1">by_alias</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
    <span class="s1">title</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">description</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">ref_template</span><span class="s3">: </span><span class="s1">str </span><span class="s3">= </span><span class="s1">DEFAULT_REF_TEMPLATE</span><span class="s3">,</span>
    <span class="s1">schema_generator</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">GenerateJsonSchema</span><span class="s3">] = </span><span class="s1">GenerateJsonSchema</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; tuple</span><span class="s3">[</span><span class="s1">dict</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">type</span><span class="s3">[</span><span class="s1">BaseModel</span><span class="s3">] | </span><span class="s1">type</span><span class="s3">[</span><span class="s1">PydanticDataclass</span><span class="s3">], </span><span class="s1">JsonSchemaMode</span><span class="s3">], </span><span class="s1">JsonSchemaValue</span><span class="s3">], </span><span class="s1">JsonSchemaValue</span><span class="s3">]:</span>
    <span class="s0">&quot;&quot;&quot;Utility function to generate a JSON Schema for multiple models. 
 
    Args: 
        models: A sequence of tuples of the form (model, mode). 
        by_alias: Whether field aliases should be used as keys in the generated JSON Schema. 
        title: The title of the generated JSON Schema. 
        description: The description of the generated JSON Schema. 
        ref_template: The reference template to use for generating JSON Schema references. 
        schema_generator: The schema generator to use for generating the JSON Schema. 
 
    Returns: 
        A tuple where: 
            - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and 
                whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have 
                JsonRef references to definitions that are defined in the second returned element.) 
            - The second element is a JSON schema containing all definitions referenced in the first returned 
                    element, along with the optional title and description keys. 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">cls</span><span class="s3">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">models</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__pydantic_core_schema__</span><span class="s3">, </span><span class="s1">_mock_val_ser</span><span class="s3">.</span><span class="s1">MockCoreSchema</span><span class="s3">):</span>
            <span class="s1">cls</span><span class="s3">.</span><span class="s1">__pydantic_core_schema__</span><span class="s3">.</span><span class="s1">rebuild</span><span class="s3">()</span>

    <span class="s1">instance </span><span class="s3">= </span><span class="s1">schema_generator</span><span class="s3">(</span><span class="s1">by_alias</span><span class="s3">=</span><span class="s1">by_alias</span><span class="s3">, </span><span class="s1">ref_template</span><span class="s3">=</span><span class="s1">ref_template</span><span class="s3">)</span>
    <span class="s1">inputs</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">type</span><span class="s3">[</span><span class="s1">BaseModel</span><span class="s3">] | </span><span class="s1">type</span><span class="s3">[</span><span class="s1">PydanticDataclass</span><span class="s3">], </span><span class="s1">JsonSchemaMode</span><span class="s3">, </span><span class="s1">CoreSchema</span><span class="s3">]] = [</span>
        <span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">m</span><span class="s3">.</span><span class="s1">__pydantic_core_schema__</span><span class="s3">) </span><span class="s2">for </span><span class="s1">m</span><span class="s3">, </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">models</span>
    <span class="s3">]</span>
    <span class="s1">json_schemas_map</span><span class="s3">, </span><span class="s1">definitions </span><span class="s3">= </span><span class="s1">instance</span><span class="s3">.</span><span class="s1">generate_definitions</span><span class="s3">(</span><span class="s1">inputs</span><span class="s3">)</span>

    <span class="s1">json_schema</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] = {}</span>
    <span class="s2">if </span><span class="s1">definitions</span><span class="s3">:</span>
        <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'$defs'</span><span class="s3">] = </span><span class="s1">definitions</span>
    <span class="s2">if </span><span class="s1">title</span><span class="s3">:</span>
        <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'title'</span><span class="s3">] = </span><span class="s1">title</span>
    <span class="s2">if </span><span class="s1">description</span><span class="s3">:</span>
        <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'description'</span><span class="s3">] = </span><span class="s1">description</span>

    <span class="s2">return </span><span class="s1">json_schemas_map</span><span class="s3">, </span><span class="s1">json_schema</span>


<span class="s5"># ##### End JSON Schema Generation Functions #####</span>


<span class="s1">_HashableJsonValue</span><span class="s3">: </span><span class="s1">TypeAlias </span><span class="s3">= </span><span class="s1">Union</span><span class="s3">[</span>
    <span class="s1">int</span><span class="s3">, </span><span class="s1">float</span><span class="s3">, </span><span class="s1">str</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">[</span><span class="s4">'_HashableJsonValue'</span><span class="s3">, ...], </span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s4">'_HashableJsonValue'</span><span class="s3">], ...]</span>
<span class="s3">]</span>


<span class="s2">def </span><span class="s1">_deduplicate_schemas</span><span class="s3">(</span><span class="s1">schemas</span><span class="s3">: </span><span class="s1">Iterable</span><span class="s3">[</span><span class="s1">JsonDict</span><span class="s3">]) </span><span class="s1">-&gt; list</span><span class="s3">[</span><span class="s1">JsonDict</span><span class="s3">]:</span>
    <span class="s2">return </span><span class="s1">list</span><span class="s3">({</span><span class="s1">_make_json_hashable</span><span class="s3">(</span><span class="s1">schema</span><span class="s3">): </span><span class="s1">schema </span><span class="s2">for </span><span class="s1">schema </span><span class="s2">in </span><span class="s1">schemas</span><span class="s3">}.</span><span class="s1">values</span><span class="s3">())</span>


<span class="s2">def </span><span class="s1">_make_json_hashable</span><span class="s3">(</span><span class="s1">value</span><span class="s3">: </span><span class="s1">JsonValue</span><span class="s3">) </span><span class="s1">-&gt; _HashableJsonValue</span><span class="s3">:</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">sorted</span><span class="s3">((</span><span class="s1">k</span><span class="s3">, </span><span class="s1">_make_json_hashable</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)) </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">value</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()))</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">list</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">_make_json_hashable</span><span class="s3">(</span><span class="s1">v</span><span class="s3">) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">value</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">value</span>


<span class="s3">@</span><span class="s1">dataclasses</span><span class="s3">.</span><span class="s1">dataclass</span><span class="s3">(**</span><span class="s1">_internal_dataclass</span><span class="s3">.</span><span class="s1">slots_true</span><span class="s3">)</span>
<span class="s2">class </span><span class="s1">WithJsonSchema</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;!!! abstract &quot;Usage Documentation&quot; 
        [`WithJsonSchema` Annotation](../concepts/json_schema.md#withjsonschema-annotation) 
 
    Add this as an annotation on a field to override the (base) JSON schema that would be generated for that field. 
    This provides a way to set a JSON schema for types that would otherwise raise errors when producing a JSON schema, 
    such as Callable, or types that have an is-instance core schema, without needing to go so far as creating a 
    custom subclass of pydantic.json_schema.GenerateJsonSchema. 
    Note that any _modifications_ to the schema that would normally be made (such as setting the title for model fields) 
    will still be performed. 
 
    If `mode` is set this will only apply to that schema generation mode, allowing you 
    to set different json schemas for validation and serialization. 
    &quot;&quot;&quot;</span>

    <span class="s1">json_schema</span><span class="s3">: </span><span class="s1">JsonSchemaValue </span><span class="s3">| </span><span class="s2">None</span>
    <span class="s1">mode</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">'validation'</span><span class="s3">, </span><span class="s4">'serialization'</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__get_pydantic_json_schema__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">core_schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">: </span><span class="s1">GetJsonSchemaHandler</span>
    <span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s1">mode </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mode </span><span class="s2">or </span><span class="s1">handler</span><span class="s3">.</span><span class="s1">mode</span>
        <span class="s2">if </span><span class="s1">mode </span><span class="s3">!= </span><span class="s1">handler</span><span class="s3">.</span><span class="s1">mode</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">handler</span><span class="s3">(</span><span class="s1">core_schema</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">json_schema </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s5"># This exception is handled in pydantic.json_schema.GenerateJsonSchema._named_required_fields_schema</span>
            <span class="s2">raise </span><span class="s1">PydanticOmit</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">json_schema</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">__hash__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; int</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">hash</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">mode</span><span class="s3">))</span>


<span class="s2">class </span><span class="s1">Examples</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Add examples to a JSON schema. 
 
    If the JSON Schema already contains examples, the provided examples 
    will be appended. 
 
    If `mode` is set this will only apply to that schema generation mode, 
    allowing you to add different examples for validation and serialization. 
    &quot;&quot;&quot;</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s3">@</span><span class="s1">deprecated</span><span class="s3">(</span><span class="s4">'Using a dict for `examples` is deprecated since v2.9 and will be removed in v3.0. Use a list instead.'</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">examples</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">], </span><span class="s1">mode</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">'validation'</span><span class="s3">, </span><span class="s4">'serialization'</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">: ...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">examples</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">], </span><span class="s1">mode</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">'validation'</span><span class="s3">, </span><span class="s4">'serialization'</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">: ...</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">examples</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s1">list</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">], </span><span class="s1">mode</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">'validation'</span><span class="s3">, </span><span class="s4">'serialization'</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">examples</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">):</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                <span class="s4">'Using a dict for `examples` is deprecated, use a list instead.'</span><span class="s3">,</span>
                <span class="s1">PydanticDeprecatedSince29</span><span class="s3">,</span>
                <span class="s1">stacklevel</span><span class="s3">=</span><span class="s6">2</span><span class="s3">,</span>
            <span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">examples </span><span class="s3">= </span><span class="s1">examples</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">mode </span><span class="s3">= </span><span class="s1">mode</span>

    <span class="s2">def </span><span class="s1">__get_pydantic_json_schema__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">core_schema</span><span class="s3">: </span><span class="s1">core_schema</span><span class="s3">.</span><span class="s1">CoreSchema</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">: </span><span class="s1">GetJsonSchemaHandler</span>
    <span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
        <span class="s1">mode </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mode </span><span class="s2">or </span><span class="s1">handler</span><span class="s3">.</span><span class="s1">mode</span>
        <span class="s1">json_schema </span><span class="s3">= </span><span class="s1">handler</span><span class="s3">(</span><span class="s1">core_schema</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">mode </span><span class="s3">!= </span><span class="s1">handler</span><span class="s3">.</span><span class="s1">mode</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">json_schema</span>
        <span class="s1">examples </span><span class="s3">= </span><span class="s1">json_schema</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'examples'</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">examples </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'examples'</span><span class="s3">] = </span><span class="s1">to_jsonable_python</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">examples</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">examples</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">examples</span><span class="s3">, </span><span class="s1">list</span><span class="s3">):</span>
                <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                    <span class="s4">'Updating existing JSON Schema examples of type dict with examples of type list. '</span>
                    <span class="s4">'Only the existing examples values will be retained. Note that dict support for '</span>
                    <span class="s4">'examples is deprecated and will be removed in v3.0.'</span><span class="s3">,</span>
                    <span class="s1">UserWarning</span><span class="s3">,</span>
                <span class="s3">)</span>
                <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'examples'</span><span class="s3">] = </span><span class="s1">to_jsonable_python</span><span class="s3">(</span>
                    <span class="s3">[</span><span class="s1">ex </span><span class="s2">for </span><span class="s1">value </span><span class="s2">in </span><span class="s1">examples</span><span class="s3">.</span><span class="s1">values</span><span class="s3">() </span><span class="s2">for </span><span class="s1">ex </span><span class="s2">in </span><span class="s1">value</span><span class="s3">] + </span><span class="s1">self</span><span class="s3">.</span><span class="s1">examples</span>
                <span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'examples'</span><span class="s3">] = </span><span class="s1">to_jsonable_python</span><span class="s3">({**</span><span class="s1">examples</span><span class="s3">, **</span><span class="s1">self</span><span class="s3">.</span><span class="s1">examples</span><span class="s3">})</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">examples</span><span class="s3">, </span><span class="s1">list</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">examples</span><span class="s3">, </span><span class="s1">list</span><span class="s3">):</span>
                <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'examples'</span><span class="s3">] = </span><span class="s1">to_jsonable_python</span><span class="s3">(</span><span class="s1">examples </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">examples</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">examples</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">):</span>
                <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                    <span class="s4">'Updating existing JSON Schema examples of type list with examples of type dict. '</span>
                    <span class="s4">'Only the examples values will be retained. Note that dict support for '</span>
                    <span class="s4">'examples is deprecated and will be removed in v3.0.'</span><span class="s3">,</span>
                    <span class="s1">UserWarning</span><span class="s3">,</span>
                <span class="s3">)</span>
                <span class="s1">json_schema</span><span class="s3">[</span><span class="s4">'examples'</span><span class="s3">] = </span><span class="s1">to_jsonable_python</span><span class="s3">(</span>
                    <span class="s1">examples </span><span class="s3">+ [</span><span class="s1">ex </span><span class="s2">for </span><span class="s1">value </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">examples</span><span class="s3">.</span><span class="s1">values</span><span class="s3">() </span><span class="s2">for </span><span class="s1">ex </span><span class="s2">in </span><span class="s1">value</span><span class="s3">]</span>
                <span class="s3">)</span>

        <span class="s2">return </span><span class="s1">json_schema</span>

    <span class="s2">def </span><span class="s1">__hash__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; int</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">hash</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">mode</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">_get_all_json_refs</span><span class="s3">(</span><span class="s1">item</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; set</span><span class="s3">[</span><span class="s1">JsonRef</span><span class="s3">]:</span>
    <span class="s0">&quot;&quot;&quot;Get all the definitions references from a JSON schema.&quot;&quot;&quot;</span>
    <span class="s1">refs</span><span class="s3">: </span><span class="s1">set</span><span class="s3">[</span><span class="s1">JsonRef</span><span class="s3">] = </span><span class="s1">set</span><span class="s3">()</span>
    <span class="s1">stack </span><span class="s3">= [</span><span class="s1">item</span><span class="s3">]</span>

    <span class="s2">while </span><span class="s1">stack</span><span class="s3">:</span>
        <span class="s1">current </span><span class="s3">= </span><span class="s1">stack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">current</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">current</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s2">if </span><span class="s1">key </span><span class="s3">== </span><span class="s4">'examples' </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">list</span><span class="s3">):</span>
                    <span class="s5"># Skip examples that may contain arbitrary values and references</span>
                    <span class="s5"># (e.g. `{&quot;examples&quot;: [{&quot;$ref&quot;: &quot;...&quot;}]}`). Note: checking for value</span>
                    <span class="s5"># of type list is necessary to avoid skipping valid portions of the schema,</span>
                    <span class="s5"># for instance when &quot;examples&quot; is used as a property key. A more robust solution</span>
                    <span class="s5"># could be found, but would require more advanced JSON Schema parsing logic.</span>
                    <span class="s2">continue</span>
                <span class="s2">if </span><span class="s1">key </span><span class="s3">== </span><span class="s4">'$ref' </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
                    <span class="s1">refs</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">JsonRef</span><span class="s3">(</span><span class="s1">value</span><span class="s3">))</span>
                <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">):</span>
                    <span class="s1">stack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
                <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">list</span><span class="s3">):</span>
                    <span class="s1">stack</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">current</span><span class="s3">, </span><span class="s1">list</span><span class="s3">):</span>
            <span class="s1">stack</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">current</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">refs</span>


<span class="s1">AnyType </span><span class="s3">= </span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s4">'AnyType'</span><span class="s3">)</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s1">SkipJsonSchema </span><span class="s3">= </span><span class="s1">Annotated</span><span class="s3">[</span><span class="s1">AnyType</span><span class="s3">, ...]</span>
<span class="s2">else</span><span class="s3">:</span>

    <span class="s3">@</span><span class="s1">dataclasses</span><span class="s3">.</span><span class="s1">dataclass</span><span class="s3">(**</span><span class="s1">_internal_dataclass</span><span class="s3">.</span><span class="s1">slots_true</span><span class="s3">)</span>
    <span class="s2">class </span><span class="s1">SkipJsonSchema</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;!!! abstract &quot;Usage Documentation&quot; 
            [`SkipJsonSchema` Annotation](../concepts/json_schema.md#skipjsonschema-annotation) 
 
        Add this as an annotation on a field to skip generating a JSON schema for that field. 
 
        Example: 
            ```python 
            from pprint import pprint 
            from typing import Union 
 
            from pydantic import BaseModel 
            from pydantic.json_schema import SkipJsonSchema 
 
            class Model(BaseModel): 
                a: Union[int, None] = None  # (1)! 
                b: Union[int, SkipJsonSchema[None]] = None  # (2)! 
                c: SkipJsonSchema[Union[int, None]] = None  # (3)! 
 
            pprint(Model.model_json_schema()) 
            ''' 
            { 
                'properties': { 
                    'a': { 
                        'anyOf': [ 
                            {'type': 'integer'}, 
                            {'type': 'null'} 
                        ], 
                        'default': None, 
                        'title': 'A' 
                    }, 
                    'b': { 
                        'default': None, 
                        'title': 'B', 
                        'type': 'integer' 
                    } 
                }, 
                'title': 'Model', 
                'type': 'object' 
            } 
            ''' 
            ``` 
 
            1. The integer and null types are both included in the schema for `a`. 
            2. The integer type is the only type included in the schema for `b`. 
            3. The entirety of the `c` field is omitted from the schema. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">__class_getitem__</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">item</span><span class="s3">: </span><span class="s1">AnyType</span><span class="s3">) </span><span class="s1">-&gt; AnyType</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">Annotated</span><span class="s3">[</span><span class="s1">item</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">()]</span>

        <span class="s2">def </span><span class="s1">__get_pydantic_json_schema__</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">, </span><span class="s1">core_schema</span><span class="s3">: </span><span class="s1">CoreSchema</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">: </span><span class="s1">GetJsonSchemaHandler</span>
        <span class="s3">) </span><span class="s1">-&gt; JsonSchemaValue</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">PydanticOmit</span>

        <span class="s2">def </span><span class="s1">__hash__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; int</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">hash</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">_get_typed_dict_config</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None</span><span class="s3">) </span><span class="s1">-&gt; ConfigDict</span><span class="s3">:</span>
    <span class="s2">if </span><span class="s1">cls </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">_decorators</span><span class="s3">.</span><span class="s1">get_attribute_from_bases</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s4">'__pydantic_config__'</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
            <span class="s2">pass</span>
    <span class="s2">return </span><span class="s3">{}</span>
</pre>
</body>
</html>