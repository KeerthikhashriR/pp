<html>
<head>
<title>_known_annotated_metadata.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #7a7e85;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_known_annotated_metadata.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">defaultdict</span>
<span class="s0">from </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc </span><span class="s0">import </span><span class="s1">Iterable</span>
<span class="s0">from </span><span class="s1">copy </span><span class="s0">import </span><span class="s1">copy</span>
<span class="s0">from </span><span class="s1">decimal </span><span class="s0">import </span><span class="s1">Decimal</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">lru_cache</span><span class="s2">, </span><span class="s1">partial</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TYPE_CHECKING</span><span class="s2">, </span><span class="s1">Any</span>

<span class="s0">from </span><span class="s1">pydantic_core </span><span class="s0">import </span><span class="s1">CoreSchema</span><span class="s2">, </span><span class="s1">PydanticCustomError</span><span class="s2">, </span><span class="s1">ValidationError</span><span class="s2">, </span><span class="s1">to_jsonable_python</span>
<span class="s0">from </span><span class="s1">pydantic_core </span><span class="s0">import </span><span class="s1">core_schema </span><span class="s0">as </span><span class="s1">cs</span>

<span class="s0">from </span><span class="s2">.</span><span class="s1">_fields </span><span class="s0">import </span><span class="s1">PydanticMetadata</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_import_utils </span><span class="s0">import </span><span class="s1">import_cached_field_info</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING</span><span class="s2">:</span>
    <span class="s0">pass</span>

<span class="s1">STRICT </span><span class="s2">= {</span><span class="s3">'strict'</span><span class="s2">}</span>
<span class="s1">FAIL_FAST </span><span class="s2">= {</span><span class="s3">'fail_fast'</span><span class="s2">}</span>
<span class="s1">LENGTH_CONSTRAINTS </span><span class="s2">= {</span><span class="s3">'min_length'</span><span class="s2">, </span><span class="s3">'max_length'</span><span class="s2">}</span>
<span class="s1">INEQUALITY </span><span class="s2">= {</span><span class="s3">'le'</span><span class="s2">, </span><span class="s3">'ge'</span><span class="s2">, </span><span class="s3">'lt'</span><span class="s2">, </span><span class="s3">'gt'</span><span class="s2">}</span>
<span class="s1">NUMERIC_CONSTRAINTS </span><span class="s2">= {</span><span class="s3">'multiple_of'</span><span class="s2">, *</span><span class="s1">INEQUALITY</span><span class="s2">}</span>
<span class="s1">ALLOW_INF_NAN </span><span class="s2">= {</span><span class="s3">'allow_inf_nan'</span><span class="s2">}</span>

<span class="s1">STR_CONSTRAINTS </span><span class="s2">= {</span>
    <span class="s2">*</span><span class="s1">LENGTH_CONSTRAINTS</span><span class="s2">,</span>
    <span class="s2">*</span><span class="s1">STRICT</span><span class="s2">,</span>
    <span class="s3">'strip_whitespace'</span><span class="s2">,</span>
    <span class="s3">'to_lower'</span><span class="s2">,</span>
    <span class="s3">'to_upper'</span><span class="s2">,</span>
    <span class="s3">'pattern'</span><span class="s2">,</span>
    <span class="s3">'coerce_numbers_to_str'</span><span class="s2">,</span>
<span class="s2">}</span>
<span class="s1">BYTES_CONSTRAINTS </span><span class="s2">= {*</span><span class="s1">LENGTH_CONSTRAINTS</span><span class="s2">, *</span><span class="s1">STRICT</span><span class="s2">}</span>

<span class="s1">LIST_CONSTRAINTS </span><span class="s2">= {*</span><span class="s1">LENGTH_CONSTRAINTS</span><span class="s2">, *</span><span class="s1">STRICT</span><span class="s2">, *</span><span class="s1">FAIL_FAST</span><span class="s2">}</span>
<span class="s1">TUPLE_CONSTRAINTS </span><span class="s2">= {*</span><span class="s1">LENGTH_CONSTRAINTS</span><span class="s2">, *</span><span class="s1">STRICT</span><span class="s2">, *</span><span class="s1">FAIL_FAST</span><span class="s2">}</span>
<span class="s1">SET_CONSTRAINTS </span><span class="s2">= {*</span><span class="s1">LENGTH_CONSTRAINTS</span><span class="s2">, *</span><span class="s1">STRICT</span><span class="s2">, *</span><span class="s1">FAIL_FAST</span><span class="s2">}</span>
<span class="s1">DICT_CONSTRAINTS </span><span class="s2">= {*</span><span class="s1">LENGTH_CONSTRAINTS</span><span class="s2">, *</span><span class="s1">STRICT</span><span class="s2">}</span>
<span class="s1">GENERATOR_CONSTRAINTS </span><span class="s2">= {*</span><span class="s1">LENGTH_CONSTRAINTS</span><span class="s2">, *</span><span class="s1">STRICT</span><span class="s2">}</span>
<span class="s1">SEQUENCE_CONSTRAINTS </span><span class="s2">= {*</span><span class="s1">LENGTH_CONSTRAINTS</span><span class="s2">, *</span><span class="s1">FAIL_FAST</span><span class="s2">}</span>

<span class="s1">FLOAT_CONSTRAINTS </span><span class="s2">= {*</span><span class="s1">NUMERIC_CONSTRAINTS</span><span class="s2">, *</span><span class="s1">ALLOW_INF_NAN</span><span class="s2">, *</span><span class="s1">STRICT</span><span class="s2">}</span>
<span class="s1">DECIMAL_CONSTRAINTS </span><span class="s2">= {</span><span class="s3">'max_digits'</span><span class="s2">, </span><span class="s3">'decimal_places'</span><span class="s2">, *</span><span class="s1">FLOAT_CONSTRAINTS</span><span class="s2">}</span>
<span class="s1">INT_CONSTRAINTS </span><span class="s2">= {*</span><span class="s1">NUMERIC_CONSTRAINTS</span><span class="s2">, *</span><span class="s1">ALLOW_INF_NAN</span><span class="s2">, *</span><span class="s1">STRICT</span><span class="s2">}</span>
<span class="s1">BOOL_CONSTRAINTS </span><span class="s2">= </span><span class="s1">STRICT</span>
<span class="s1">UUID_CONSTRAINTS </span><span class="s2">= </span><span class="s1">STRICT</span>

<span class="s1">DATE_TIME_CONSTRAINTS </span><span class="s2">= {*</span><span class="s1">NUMERIC_CONSTRAINTS</span><span class="s2">, *</span><span class="s1">STRICT</span><span class="s2">}</span>
<span class="s1">TIMEDELTA_CONSTRAINTS </span><span class="s2">= {*</span><span class="s1">NUMERIC_CONSTRAINTS</span><span class="s2">, *</span><span class="s1">STRICT</span><span class="s2">}</span>
<span class="s1">TIME_CONSTRAINTS </span><span class="s2">= {*</span><span class="s1">NUMERIC_CONSTRAINTS</span><span class="s2">, *</span><span class="s1">STRICT</span><span class="s2">}</span>
<span class="s1">LAX_OR_STRICT_CONSTRAINTS </span><span class="s2">= </span><span class="s1">STRICT</span>
<span class="s1">ENUM_CONSTRAINTS </span><span class="s2">= </span><span class="s1">STRICT</span>
<span class="s1">COMPLEX_CONSTRAINTS </span><span class="s2">= </span><span class="s1">STRICT</span>

<span class="s1">UNION_CONSTRAINTS </span><span class="s2">= {</span><span class="s3">'union_mode'</span><span class="s2">}</span>
<span class="s1">URL_CONSTRAINTS </span><span class="s2">= {</span>
    <span class="s3">'max_length'</span><span class="s2">,</span>
    <span class="s3">'allowed_schemes'</span><span class="s2">,</span>
    <span class="s3">'host_required'</span><span class="s2">,</span>
    <span class="s3">'default_host'</span><span class="s2">,</span>
    <span class="s3">'default_port'</span><span class="s2">,</span>
    <span class="s3">'default_path'</span><span class="s2">,</span>
<span class="s2">}</span>

<span class="s1">TEXT_SCHEMA_TYPES </span><span class="s2">= (</span><span class="s3">'str'</span><span class="s2">, </span><span class="s3">'bytes'</span><span class="s2">, </span><span class="s3">'url'</span><span class="s2">, </span><span class="s3">'multi-host-url'</span><span class="s2">)</span>
<span class="s1">SEQUENCE_SCHEMA_TYPES </span><span class="s2">= (</span><span class="s3">'list'</span><span class="s2">, </span><span class="s3">'tuple'</span><span class="s2">, </span><span class="s3">'set'</span><span class="s2">, </span><span class="s3">'frozenset'</span><span class="s2">, </span><span class="s3">'generator'</span><span class="s2">, *</span><span class="s1">TEXT_SCHEMA_TYPES</span><span class="s2">)</span>
<span class="s1">NUMERIC_SCHEMA_TYPES </span><span class="s2">= (</span><span class="s3">'float'</span><span class="s2">, </span><span class="s3">'int'</span><span class="s2">, </span><span class="s3">'date'</span><span class="s2">, </span><span class="s3">'time'</span><span class="s2">, </span><span class="s3">'timedelta'</span><span class="s2">, </span><span class="s3">'datetime'</span><span class="s2">)</span>

<span class="s1">CONSTRAINTS_TO_ALLOWED_SCHEMAS</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]] = </span><span class="s1">defaultdict</span><span class="s2">(</span><span class="s1">set</span><span class="s2">)</span>

<span class="s1">constraint_schema_pairings</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">], </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, ...]]] = [</span>
    <span class="s2">(</span><span class="s1">STR_CONSTRAINTS</span><span class="s2">, </span><span class="s1">TEXT_SCHEMA_TYPES</span><span class="s2">),</span>
    <span class="s2">(</span><span class="s1">BYTES_CONSTRAINTS</span><span class="s2">, (</span><span class="s3">'bytes'</span><span class="s2">,)),</span>
    <span class="s2">(</span><span class="s1">LIST_CONSTRAINTS</span><span class="s2">, (</span><span class="s3">'list'</span><span class="s2">,)),</span>
    <span class="s2">(</span><span class="s1">TUPLE_CONSTRAINTS</span><span class="s2">, (</span><span class="s3">'tuple'</span><span class="s2">,)),</span>
    <span class="s2">(</span><span class="s1">SET_CONSTRAINTS</span><span class="s2">, (</span><span class="s3">'set'</span><span class="s2">, </span><span class="s3">'frozenset'</span><span class="s2">)),</span>
    <span class="s2">(</span><span class="s1">DICT_CONSTRAINTS</span><span class="s2">, (</span><span class="s3">'dict'</span><span class="s2">,)),</span>
    <span class="s2">(</span><span class="s1">GENERATOR_CONSTRAINTS</span><span class="s2">, (</span><span class="s3">'generator'</span><span class="s2">,)),</span>
    <span class="s2">(</span><span class="s1">FLOAT_CONSTRAINTS</span><span class="s2">, (</span><span class="s3">'float'</span><span class="s2">,)),</span>
    <span class="s2">(</span><span class="s1">INT_CONSTRAINTS</span><span class="s2">, (</span><span class="s3">'int'</span><span class="s2">,)),</span>
    <span class="s2">(</span><span class="s1">DATE_TIME_CONSTRAINTS</span><span class="s2">, (</span><span class="s3">'date'</span><span class="s2">, </span><span class="s3">'time'</span><span class="s2">, </span><span class="s3">'datetime'</span><span class="s2">, </span><span class="s3">'timedelta'</span><span class="s2">)),</span>
    <span class="s4"># TODO: this is a bit redundant, we could probably avoid some of these</span>
    <span class="s2">(</span><span class="s1">STRICT</span><span class="s2">, (*</span><span class="s1">TEXT_SCHEMA_TYPES</span><span class="s2">, *</span><span class="s1">SEQUENCE_SCHEMA_TYPES</span><span class="s2">, *</span><span class="s1">NUMERIC_SCHEMA_TYPES</span><span class="s2">, </span><span class="s3">'typed-dict'</span><span class="s2">, </span><span class="s3">'model'</span><span class="s2">)),</span>
    <span class="s2">(</span><span class="s1">UNION_CONSTRAINTS</span><span class="s2">, (</span><span class="s3">'union'</span><span class="s2">,)),</span>
    <span class="s2">(</span><span class="s1">URL_CONSTRAINTS</span><span class="s2">, (</span><span class="s3">'url'</span><span class="s2">, </span><span class="s3">'multi-host-url'</span><span class="s2">)),</span>
    <span class="s2">(</span><span class="s1">BOOL_CONSTRAINTS</span><span class="s2">, (</span><span class="s3">'bool'</span><span class="s2">,)),</span>
    <span class="s2">(</span><span class="s1">UUID_CONSTRAINTS</span><span class="s2">, (</span><span class="s3">'uuid'</span><span class="s2">,)),</span>
    <span class="s2">(</span><span class="s1">LAX_OR_STRICT_CONSTRAINTS</span><span class="s2">, (</span><span class="s3">'lax-or-strict'</span><span class="s2">,)),</span>
    <span class="s2">(</span><span class="s1">ENUM_CONSTRAINTS</span><span class="s2">, (</span><span class="s3">'enum'</span><span class="s2">,)),</span>
    <span class="s2">(</span><span class="s1">DECIMAL_CONSTRAINTS</span><span class="s2">, (</span><span class="s3">'decimal'</span><span class="s2">,)),</span>
    <span class="s2">(</span><span class="s1">COMPLEX_CONSTRAINTS</span><span class="s2">, (</span><span class="s3">'complex'</span><span class="s2">,)),</span>
<span class="s2">]</span>

<span class="s0">for </span><span class="s1">constraints</span><span class="s2">, </span><span class="s1">schemas </span><span class="s0">in </span><span class="s1">constraint_schema_pairings</span><span class="s2">:</span>
    <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">constraints</span><span class="s2">:</span>
        <span class="s1">CONSTRAINTS_TO_ALLOWED_SCHEMAS</span><span class="s2">[</span><span class="s1">c</span><span class="s2">].</span><span class="s1">update</span><span class="s2">(</span><span class="s1">schemas</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">as_jsonable_value</span><span class="s2">(</span><span class="s1">v</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
    <span class="s0">if </span><span class="s1">type</span><span class="s2">(</span><span class="s1">v</span><span class="s2">) </span><span class="s0">not in </span><span class="s2">(</span><span class="s1">int</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">, </span><span class="s1">type</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)):</span>
        <span class="s0">return </span><span class="s1">to_jsonable_python</span><span class="s2">(</span><span class="s1">v</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">v</span>


<span class="s0">def </span><span class="s1">expand_grouped_metadata</span><span class="s2">(</span><span class="s1">annotations</span><span class="s2">: </span><span class="s1">Iterable</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">]) </span><span class="s1">-&gt; Iterable</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">]:</span>
    <span class="s5">&quot;&quot;&quot;Expand the annotations. 
 
    Args: 
        annotations: An iterable of annotations. 
 
    Returns: 
        An iterable of expanded annotations. 
 
    Example: 
        ```python 
        from annotated_types import Ge, Len 
 
        from pydantic._internal._known_annotated_metadata import expand_grouped_metadata 
 
        print(list(expand_grouped_metadata([Ge(4), Len(5)]))) 
        #&gt; [Ge(ge=4), MinLen(min_length=5)] 
        ``` 
    &quot;&quot;&quot;</span>
    <span class="s0">import </span><span class="s1">annotated_types </span><span class="s0">as </span><span class="s1">at</span>

    <span class="s1">FieldInfo </span><span class="s2">= </span><span class="s1">import_cached_field_info</span><span class="s2">()</span>

    <span class="s0">for </span><span class="s1">annotation </span><span class="s0">in </span><span class="s1">annotations</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">, </span><span class="s1">at</span><span class="s2">.</span><span class="s1">GroupedMetadata</span><span class="s2">):</span>
            <span class="s0">yield from </span><span class="s1">annotation</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">, </span><span class="s1">FieldInfo</span><span class="s2">):</span>
            <span class="s0">yield from </span><span class="s1">annotation</span><span class="s2">.</span><span class="s1">metadata</span>
            <span class="s4"># this is a bit problematic in that it results in duplicate metadata</span>
            <span class="s4"># all of our &quot;consumers&quot; can handle it, but it is not ideal</span>
            <span class="s4"># we probably should split up FieldInfo into:</span>
            <span class="s4"># - annotated types metadata</span>
            <span class="s4"># - individual metadata known only to Pydantic</span>
            <span class="s1">annotation </span><span class="s2">= </span><span class="s1">copy</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">)</span>
            <span class="s1">annotation</span><span class="s2">.</span><span class="s1">metadata </span><span class="s2">= []</span>
            <span class="s0">yield </span><span class="s1">annotation</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">yield </span><span class="s1">annotation</span>


<span class="s2">@</span><span class="s1">lru_cache</span>
<span class="s0">def </span><span class="s1">_get_at_to_constraint_map</span><span class="s2">() </span><span class="s1">-&gt; dict</span><span class="s2">[</span><span class="s1">type</span><span class="s2">, </span><span class="s1">str</span><span class="s2">]:</span>
    <span class="s5">&quot;&quot;&quot;Return a mapping of annotated types to constraints. 
 
    Normally, we would define a mapping like this in the module scope, but we can't do that 
    because we don't permit module level imports of `annotated_types`, in an attempt to speed up 
    the import time of `pydantic`. We still only want to have this dictionary defined in one place, 
    so we use this function to cache the result. 
    &quot;&quot;&quot;</span>
    <span class="s0">import </span><span class="s1">annotated_types </span><span class="s0">as </span><span class="s1">at</span>

    <span class="s0">return </span><span class="s2">{</span>
        <span class="s1">at</span><span class="s2">.</span><span class="s1">Gt</span><span class="s2">: </span><span class="s3">'gt'</span><span class="s2">,</span>
        <span class="s1">at</span><span class="s2">.</span><span class="s1">Ge</span><span class="s2">: </span><span class="s3">'ge'</span><span class="s2">,</span>
        <span class="s1">at</span><span class="s2">.</span><span class="s1">Lt</span><span class="s2">: </span><span class="s3">'lt'</span><span class="s2">,</span>
        <span class="s1">at</span><span class="s2">.</span><span class="s1">Le</span><span class="s2">: </span><span class="s3">'le'</span><span class="s2">,</span>
        <span class="s1">at</span><span class="s2">.</span><span class="s1">MultipleOf</span><span class="s2">: </span><span class="s3">'multiple_of'</span><span class="s2">,</span>
        <span class="s1">at</span><span class="s2">.</span><span class="s1">MinLen</span><span class="s2">: </span><span class="s3">'min_length'</span><span class="s2">,</span>
        <span class="s1">at</span><span class="s2">.</span><span class="s1">MaxLen</span><span class="s2">: </span><span class="s3">'max_length'</span><span class="s2">,</span>
    <span class="s2">}</span>


<span class="s0">def </span><span class="s1">apply_known_metadata</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">schema</span><span class="s2">: </span><span class="s1">CoreSchema</span><span class="s2">) </span><span class="s1">-&gt; CoreSchema </span><span class="s2">| </span><span class="s0">None</span><span class="s2">:  </span><span class="s4"># noqa: C901</span>
    <span class="s5">&quot;&quot;&quot;Apply `annotation` to `schema` if it is an annotation we know about (Gt, Le, etc.). 
    Otherwise return `None`. 
 
    This does not handle all known annotations. If / when it does, it can always 
    return a CoreSchema and return the unmodified schema if the annotation should be ignored. 
 
    Assumes that GroupedMetadata has already been expanded via `expand_grouped_metadata`. 
 
    Args: 
        annotation: The annotation. 
        schema: The schema. 
 
    Returns: 
        An updated schema with annotation if it is an annotation we know about, `None` otherwise. 
 
    Raises: 
        PydanticCustomError: If `Predicate` fails. 
    &quot;&quot;&quot;</span>
    <span class="s0">import </span><span class="s1">annotated_types </span><span class="s0">as </span><span class="s1">at</span>

    <span class="s0">from </span><span class="s2">.</span><span class="s1">_validators </span><span class="s0">import </span><span class="s1">NUMERIC_VALIDATOR_LOOKUP</span><span class="s2">, </span><span class="s1">forbid_inf_nan_check</span>

    <span class="s1">schema </span><span class="s2">= </span><span class="s1">schema</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
    <span class="s1">schema_update</span><span class="s2">, </span><span class="s1">other_metadata </span><span class="s2">= </span><span class="s1">collect_known_metadata</span><span class="s2">([</span><span class="s1">annotation</span><span class="s2">])</span>
    <span class="s1">schema_type </span><span class="s2">= </span><span class="s1">schema</span><span class="s2">[</span><span class="s3">'type'</span><span class="s2">]</span>

    <span class="s1">chain_schema_constraints</span><span class="s2">: </span><span class="s1">set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = {</span>
        <span class="s3">'pattern'</span><span class="s2">,</span>
        <span class="s3">'strip_whitespace'</span><span class="s2">,</span>
        <span class="s3">'to_lower'</span><span class="s2">,</span>
        <span class="s3">'to_upper'</span><span class="s2">,</span>
        <span class="s3">'coerce_numbers_to_str'</span><span class="s2">,</span>
    <span class="s2">}</span>
    <span class="s1">chain_schema_steps</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">CoreSchema</span><span class="s2">] = []</span>

    <span class="s0">for </span><span class="s1">constraint</span><span class="s2">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">schema_update</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
        <span class="s0">if </span><span class="s1">constraint </span><span class="s0">not in </span><span class="s1">CONSTRAINTS_TO_ALLOWED_SCHEMAS</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f'Unknown constraint </span><span class="s0">{</span><span class="s1">constraint</span><span class="s0">}</span><span class="s3">'</span><span class="s2">)</span>
        <span class="s1">allowed_schemas </span><span class="s2">= </span><span class="s1">CONSTRAINTS_TO_ALLOWED_SCHEMAS</span><span class="s2">[</span><span class="s1">constraint</span><span class="s2">]</span>

        <span class="s4"># if it becomes necessary to handle more than one constraint</span>
        <span class="s4"># in this recursive case with function-after or function-wrap, we should refactor</span>
        <span class="s4"># this is a bit challenging because we sometimes want to apply constraints to the inner schema,</span>
        <span class="s4"># whereas other times we want to wrap the existing schema with a new one that enforces a new constraint.</span>
        <span class="s0">if </span><span class="s1">schema_type </span><span class="s0">in </span><span class="s2">{</span><span class="s3">'function-before'</span><span class="s2">, </span><span class="s3">'function-wrap'</span><span class="s2">, </span><span class="s3">'function-after'</span><span class="s2">} </span><span class="s0">and </span><span class="s1">constraint </span><span class="s2">== </span><span class="s3">'strict'</span><span class="s2">:</span>
            <span class="s1">schema</span><span class="s2">[</span><span class="s3">'schema'</span><span class="s2">] = </span><span class="s1">apply_known_metadata</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">, </span><span class="s1">schema</span><span class="s2">[</span><span class="s3">'schema'</span><span class="s2">])  </span><span class="s4"># type: ignore  # schema is function schema</span>
            <span class="s0">return </span><span class="s1">schema</span>

        <span class="s4"># if we're allowed to apply constraint directly to the schema, like le to int, do that</span>
        <span class="s0">if </span><span class="s1">schema_type </span><span class="s0">in </span><span class="s1">allowed_schemas</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">constraint </span><span class="s2">== </span><span class="s3">'union_mode' </span><span class="s0">and </span><span class="s1">schema_type </span><span class="s2">== </span><span class="s3">'union'</span><span class="s2">:</span>
                <span class="s1">schema</span><span class="s2">[</span><span class="s3">'mode'</span><span class="s2">] = </span><span class="s1">value  </span><span class="s4"># type: ignore  # schema is UnionSchema</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">schema_type </span><span class="s2">== </span><span class="s3">'decimal' </span><span class="s0">and </span><span class="s1">constraint </span><span class="s0">in </span><span class="s2">{</span><span class="s3">'multiple_of'</span><span class="s2">, </span><span class="s3">'le'</span><span class="s2">, </span><span class="s3">'ge'</span><span class="s2">, </span><span class="s3">'lt'</span><span class="s2">, </span><span class="s3">'gt'</span><span class="s2">}:</span>
                    <span class="s1">schema</span><span class="s2">[</span><span class="s1">constraint</span><span class="s2">] = </span><span class="s1">Decimal</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">schema</span><span class="s2">[</span><span class="s1">constraint</span><span class="s2">] = </span><span class="s1">value</span>
            <span class="s0">continue</span>

        <span class="s4">#  else, apply a function after validator to the schema to enforce the corresponding constraint</span>
        <span class="s0">if </span><span class="s1">constraint </span><span class="s0">in </span><span class="s1">chain_schema_constraints</span><span class="s2">:</span>

            <span class="s0">def </span><span class="s1">_apply_constraint_with_incompatibility_info</span><span class="s2">(</span>
                <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">handler</span><span class="s2">: </span><span class="s1">cs</span><span class="s2">.</span><span class="s1">ValidatorFunctionWrapHandler</span>
            <span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">x </span><span class="s2">= </span><span class="s1">handler</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
                <span class="s0">except </span><span class="s1">ValidationError </span><span class="s0">as </span><span class="s1">ve</span><span class="s2">:</span>
                    <span class="s4"># if the error is about the type, it's likely that the constraint is incompatible the type of the field</span>
                    <span class="s4"># for example, the following invalid schema wouldn't be caught during schema build, but rather at this point</span>
                    <span class="s4"># with a cryptic 'string_type' error coming from the string validator,</span>
                    <span class="s4"># that we'd rather express as a constraint incompatibility error (TypeError)</span>
                    <span class="s4"># Annotated[list[int], Field(pattern='abc')]</span>
                    <span class="s0">if </span><span class="s3">'type' </span><span class="s0">in </span><span class="s1">ve</span><span class="s2">.</span><span class="s1">errors</span><span class="s2">()[</span><span class="s6">0</span><span class="s2">][</span><span class="s3">'type'</span><span class="s2">]:</span>
                        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                            <span class="s3">f&quot;Unable to apply constraint '</span><span class="s0">{</span><span class="s1">constraint</span><span class="s0">}</span><span class="s3">' to supplied value </span><span class="s0">{</span><span class="s1">value</span><span class="s0">} </span><span class="s3">for schema of type '</span><span class="s0">{</span><span class="s1">schema_type</span><span class="s0">}</span><span class="s3">'&quot;  </span><span class="s4"># noqa: B023</span>
                        <span class="s2">)</span>
                    <span class="s0">raise </span><span class="s1">ve</span>
                <span class="s0">return </span><span class="s1">x</span>

            <span class="s1">chain_schema_steps</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span>
                <span class="s1">cs</span><span class="s2">.</span><span class="s1">no_info_wrap_validator_function</span><span class="s2">(</span>
                    <span class="s1">_apply_constraint_with_incompatibility_info</span><span class="s2">, </span><span class="s1">cs</span><span class="s2">.</span><span class="s1">str_schema</span><span class="s2">(**{</span><span class="s1">constraint</span><span class="s2">: </span><span class="s1">value</span><span class="s2">})</span>
                <span class="s2">)</span>
            <span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">constraint </span><span class="s0">in </span><span class="s1">NUMERIC_VALIDATOR_LOOKUP</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">constraint </span><span class="s0">in </span><span class="s1">LENGTH_CONSTRAINTS</span><span class="s2">:</span>
                <span class="s1">inner_schema </span><span class="s2">= </span><span class="s1">schema</span>
                <span class="s0">while </span><span class="s1">inner_schema</span><span class="s2">[</span><span class="s3">'type'</span><span class="s2">] </span><span class="s0">in </span><span class="s2">{</span><span class="s3">'function-before'</span><span class="s2">, </span><span class="s3">'function-wrap'</span><span class="s2">, </span><span class="s3">'function-after'</span><span class="s2">}:</span>
                    <span class="s1">inner_schema </span><span class="s2">= </span><span class="s1">inner_schema</span><span class="s2">[</span><span class="s3">'schema'</span><span class="s2">]  </span><span class="s4"># type: ignore</span>
                <span class="s1">inner_schema_type </span><span class="s2">= </span><span class="s1">inner_schema</span><span class="s2">[</span><span class="s3">'type'</span><span class="s2">]</span>
                <span class="s0">if </span><span class="s1">inner_schema_type </span><span class="s2">== </span><span class="s3">'list' </span><span class="s0">or </span><span class="s2">(</span>
                    <span class="s1">inner_schema_type </span><span class="s2">== </span><span class="s3">'json-or-python' </span><span class="s0">and </span><span class="s1">inner_schema</span><span class="s2">[</span><span class="s3">'json_schema'</span><span class="s2">][</span><span class="s3">'type'</span><span class="s2">] == </span><span class="s3">'list'  </span><span class="s4"># type: ignore</span>
                <span class="s2">):</span>
                    <span class="s1">js_constraint_key </span><span class="s2">= </span><span class="s3">'minItems' </span><span class="s0">if </span><span class="s1">constraint </span><span class="s2">== </span><span class="s3">'min_length' </span><span class="s0">else </span><span class="s3">'maxItems'</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">js_constraint_key </span><span class="s2">= </span><span class="s3">'minLength' </span><span class="s0">if </span><span class="s1">constraint </span><span class="s2">== </span><span class="s3">'min_length' </span><span class="s0">else </span><span class="s3">'maxLength'</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">js_constraint_key </span><span class="s2">= </span><span class="s1">constraint</span>

            <span class="s1">schema </span><span class="s2">= </span><span class="s1">cs</span><span class="s2">.</span><span class="s1">no_info_after_validator_function</span><span class="s2">(</span>
                <span class="s1">partial</span><span class="s2">(</span><span class="s1">NUMERIC_VALIDATOR_LOOKUP</span><span class="s2">[</span><span class="s1">constraint</span><span class="s2">], **{</span><span class="s1">constraint</span><span class="s2">: </span><span class="s1">value</span><span class="s2">}), </span><span class="s1">schema</span>
            <span class="s2">)</span>
            <span class="s1">metadata </span><span class="s2">= </span><span class="s1">schema</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s3">'metadata'</span><span class="s2">, {})</span>
            <span class="s0">if </span><span class="s2">(</span><span class="s1">existing_json_schema_updates </span><span class="s2">:= </span><span class="s1">metadata</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s3">'pydantic_js_updates'</span><span class="s2">)) </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">metadata</span><span class="s2">[</span><span class="s3">'pydantic_js_updates'</span><span class="s2">] = {</span>
                    <span class="s2">**</span><span class="s1">existing_json_schema_updates</span><span class="s2">,</span>
                    <span class="s2">**{</span><span class="s1">js_constraint_key</span><span class="s2">: </span><span class="s1">as_jsonable_value</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)},</span>
                <span class="s2">}</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">metadata</span><span class="s2">[</span><span class="s3">'pydantic_js_updates'</span><span class="s2">] = {</span><span class="s1">js_constraint_key</span><span class="s2">: </span><span class="s1">as_jsonable_value</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)}</span>
            <span class="s1">schema</span><span class="s2">[</span><span class="s3">'metadata'</span><span class="s2">] = </span><span class="s1">metadata</span>
        <span class="s0">elif </span><span class="s1">constraint </span><span class="s2">== </span><span class="s3">'allow_inf_nan' </span><span class="s0">and </span><span class="s1">value </span><span class="s0">is False</span><span class="s2">:</span>
            <span class="s1">schema </span><span class="s2">= </span><span class="s1">cs</span><span class="s2">.</span><span class="s1">no_info_after_validator_function</span><span class="s2">(</span>
                <span class="s1">forbid_inf_nan_check</span><span class="s2">,</span>
                <span class="s1">schema</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s4"># It's rare that we'd get here, but it's possible if we add a new constraint and forget to handle it</span>
            <span class="s4"># Most constraint errors are caught at runtime during attempted application</span>
            <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s3">f&quot;Unable to apply constraint '</span><span class="s0">{</span><span class="s1">constraint</span><span class="s0">}</span><span class="s3">' to schema of type '</span><span class="s0">{</span><span class="s1">schema_type</span><span class="s0">}</span><span class="s3">'&quot;</span><span class="s2">)</span>

    <span class="s0">for </span><span class="s1">annotation </span><span class="s0">in </span><span class="s1">other_metadata</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s2">(</span><span class="s1">annotation_type </span><span class="s2">:= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">)) </span><span class="s0">in </span><span class="s2">(</span><span class="s1">at_to_constraint_map </span><span class="s2">:= </span><span class="s1">_get_at_to_constraint_map</span><span class="s2">()):</span>
            <span class="s1">constraint </span><span class="s2">= </span><span class="s1">at_to_constraint_map</span><span class="s2">[</span><span class="s1">annotation_type</span><span class="s2">]</span>
            <span class="s1">validator </span><span class="s2">= </span><span class="s1">NUMERIC_VALIDATOR_LOOKUP</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">constraint</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">validator </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f'Unknown constraint </span><span class="s0">{</span><span class="s1">constraint</span><span class="s0">}</span><span class="s3">'</span><span class="s2">)</span>
            <span class="s1">schema </span><span class="s2">= </span><span class="s1">cs</span><span class="s2">.</span><span class="s1">no_info_after_validator_function</span><span class="s2">(</span>
                <span class="s1">partial</span><span class="s2">(</span><span class="s1">validator</span><span class="s2">, {</span><span class="s1">constraint</span><span class="s2">: </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">, </span><span class="s1">constraint</span><span class="s2">)}), </span><span class="s1">schema</span>
            <span class="s2">)</span>
            <span class="s0">continue</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">, (</span><span class="s1">at</span><span class="s2">.</span><span class="s1">Predicate</span><span class="s2">, </span><span class="s1">at</span><span class="s2">.</span><span class="s1">Not</span><span class="s2">)):</span>
            <span class="s1">predicate_name </span><span class="s2">= </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">annotation</span><span class="s2">.</span><span class="s1">func</span><span class="s2">.</span><span class="s1">__qualname__</span><span class="s0">}</span><span class="s3">' </span><span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">.</span><span class="s1">func</span><span class="s2">, </span><span class="s3">'__qualname__'</span><span class="s2">) </span><span class="s0">else </span><span class="s3">''</span>

            <span class="s0">def </span><span class="s1">val_func</span><span class="s2">(</span><span class="s1">v</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
                <span class="s1">predicate_satisfied </span><span class="s2">= </span><span class="s1">annotation</span><span class="s2">.</span><span class="s1">func</span><span class="s2">(</span><span class="s1">v</span><span class="s2">)  </span><span class="s4"># noqa: B023</span>

                <span class="s4"># annotation.func may also raise an exception, let it pass through</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">, </span><span class="s1">at</span><span class="s2">.</span><span class="s1">Predicate</span><span class="s2">):  </span><span class="s4"># noqa: B023</span>
                    <span class="s0">if not </span><span class="s1">predicate_satisfied</span><span class="s2">:</span>
                        <span class="s0">raise </span><span class="s1">PydanticCustomError</span><span class="s2">(</span>
                            <span class="s3">'predicate_failed'</span><span class="s2">,</span>
                            <span class="s3">f'Predicate </span><span class="s0">{</span><span class="s1">predicate_name</span><span class="s0">} </span><span class="s3">failed'</span><span class="s2">,  </span><span class="s4"># type: ignore  # noqa: B023</span>
                        <span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">if </span><span class="s1">predicate_satisfied</span><span class="s2">:</span>
                        <span class="s0">raise </span><span class="s1">PydanticCustomError</span><span class="s2">(</span>
                            <span class="s3">'not_operation_failed'</span><span class="s2">,</span>
                            <span class="s3">f'Not of </span><span class="s0">{</span><span class="s1">predicate_name</span><span class="s0">} </span><span class="s3">failed'</span><span class="s2">,  </span><span class="s4"># type: ignore  # noqa: B023</span>
                        <span class="s2">)</span>

                <span class="s0">return </span><span class="s1">v</span>

            <span class="s1">schema </span><span class="s2">= </span><span class="s1">cs</span><span class="s2">.</span><span class="s1">no_info_after_validator_function</span><span class="s2">(</span><span class="s1">val_func</span><span class="s2">, </span><span class="s1">schema</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s4"># ignore any other unknown metadata</span>
            <span class="s0">return None</span>

    <span class="s0">if </span><span class="s1">chain_schema_steps</span><span class="s2">:</span>
        <span class="s1">chain_schema_steps </span><span class="s2">= [</span><span class="s1">schema</span><span class="s2">] + </span><span class="s1">chain_schema_steps</span>
        <span class="s0">return </span><span class="s1">cs</span><span class="s2">.</span><span class="s1">chain_schema</span><span class="s2">(</span><span class="s1">chain_schema_steps</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">schema</span>


<span class="s0">def </span><span class="s1">collect_known_metadata</span><span class="s2">(</span><span class="s1">annotations</span><span class="s2">: </span><span class="s1">Iterable</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">]) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">]]:</span>
    <span class="s5">&quot;&quot;&quot;Split `annotations` into known metadata and unknown annotations. 
 
    Args: 
        annotations: An iterable of annotations. 
 
    Returns: 
        A tuple contains a dict of known metadata and a list of unknown annotations. 
 
    Example: 
        ```python 
        from annotated_types import Gt, Len 
 
        from pydantic._internal._known_annotated_metadata import collect_known_metadata 
 
        print(collect_known_metadata([Gt(1), Len(42), ...])) 
        #&gt; ({'gt': 1, 'min_length': 42}, [Ellipsis]) 
        ``` 
    &quot;&quot;&quot;</span>
    <span class="s1">annotations </span><span class="s2">= </span><span class="s1">expand_grouped_metadata</span><span class="s2">(</span><span class="s1">annotations</span><span class="s2">)</span>

    <span class="s1">res</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] = {}</span>
    <span class="s1">remaining</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">] = []</span>

    <span class="s0">for </span><span class="s1">annotation </span><span class="s0">in </span><span class="s1">annotations</span><span class="s2">:</span>
        <span class="s4"># isinstance(annotation, PydanticMetadata) also covers ._fields:_PydanticGeneralMetadata</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">, </span><span class="s1">PydanticMetadata</span><span class="s2">):</span>
            <span class="s1">res</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">)</span>
        <span class="s4"># we don't use dataclasses.asdict because that recursively calls asdict on the field values</span>
        <span class="s0">elif </span><span class="s2">(</span><span class="s1">annotation_type </span><span class="s2">:= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">)) </span><span class="s0">in </span><span class="s2">(</span><span class="s1">at_to_constraint_map </span><span class="s2">:= </span><span class="s1">_get_at_to_constraint_map</span><span class="s2">()):</span>
            <span class="s1">constraint </span><span class="s2">= </span><span class="s1">at_to_constraint_map</span><span class="s2">[</span><span class="s1">annotation_type</span><span class="s2">]</span>
            <span class="s1">res</span><span class="s2">[</span><span class="s1">constraint</span><span class="s2">] = </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">, </span><span class="s1">constraint</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">, </span><span class="s1">type</span><span class="s2">) </span><span class="s0">and </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">, </span><span class="s1">PydanticMetadata</span><span class="s2">):</span>
            <span class="s4"># also support PydanticMetadata classes being used without initialisation,</span>
            <span class="s4"># e.g. `Annotated[int, Strict]` as well as `Annotated[int, Strict()]`</span>
            <span class="s1">res</span><span class="s2">.</span><span class="s1">update</span><span class="s2">({</span><span class="s1">k</span><span class="s2">: </span><span class="s1">v </span><span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">vars</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">).</span><span class="s1">items</span><span class="s2">() </span><span class="s0">if not </span><span class="s1">k</span><span class="s2">.</span><span class="s1">startswith</span><span class="s2">(</span><span class="s3">'_'</span><span class="s2">)})</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">remaining</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">)</span>
    <span class="s4"># Nones can sneak in but pydantic-core will reject them</span>
    <span class="s4"># it'd be nice to clean things up so we don't put in None (we probably don't _need_ to, it was just easier)</span>
    <span class="s4"># but this is simple enough to kick that can down the road</span>
    <span class="s1">res </span><span class="s2">= {</span><span class="s1">k</span><span class="s2">: </span><span class="s1">v </span><span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">res</span><span class="s2">.</span><span class="s1">items</span><span class="s2">() </span><span class="s0">if </span><span class="s1">v </span><span class="s0">is not None</span><span class="s2">}</span>
    <span class="s0">return </span><span class="s1">res</span><span class="s2">, </span><span class="s1">remaining</span>


<span class="s0">def </span><span class="s1">check_metadata</span><span class="s2">(</span><span class="s1">metadata</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">], </span><span class="s1">allowed</span><span class="s2">: </span><span class="s1">Iterable</span><span class="s2">[</span><span class="s1">str</span><span class="s2">], </span><span class="s1">source_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s5">&quot;&quot;&quot;A small utility function to validate that the given metadata can be applied to the target. 
    More than saving lines of code, this gives us a consistent error message for all of our internal implementations. 
 
    Args: 
        metadata: A dict of metadata. 
        allowed: An iterable of allowed metadata. 
        source_type: The source type. 
 
    Raises: 
        TypeError: If there is metadatas that can't be applied on source type. 
    &quot;&quot;&quot;</span>
    <span class="s1">unknown </span><span class="s2">= </span><span class="s1">metadata</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">() - </span><span class="s1">set</span><span class="s2">(</span><span class="s1">allowed</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">unknown</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
            <span class="s3">f'The following constraints cannot be applied to </span><span class="s0">{</span><span class="s1">source_type</span><span class="s0">!r}</span><span class="s3">: </span><span class="s0">{</span><span class="s3">&quot;, &quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">([</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">k</span><span class="s0">!r}</span><span class="s3">&quot; </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">unknown</span><span class="s2">])</span><span class="s0">}</span><span class="s3">'</span>
        <span class="s2">)</span>
</pre>
</body>
</html>